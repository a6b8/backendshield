Directory structure:
โโโ ava-labs-encryptederc/
    โโโ README.md
    โโโ biome.json
    โโโ hardhat.config.ts
    โโโ LICENSE.md
    โโโ package.json
    โโโ tsconfig.json
    โโโ .env.example
    โโโ .nvmrc
    โโโ .prettierignore
    โโโ .prettierrc
    โโโ .solcover.js
    โโโ .solhint.json
    โโโ .solhintignore
    โโโ circom/
    โ   โโโ burn.circom
    โ   โโโ components.circom
    โ   โโโ mint.circom
    โ   โโโ registration.circom
    โ   โโโ transfer.circom
    โ   โโโ withdraw.circom
    โ   โโโ circomlib/
    โ       โโโ aliascheck.circom
    โ       โโโ babyjub.circom
    โ       โโโ bitify.circom
    โ       โโโ comparators.circom
    โ       โโโ compconstant.circom
    โ       โโโ escalarmulany.circom
    โ       โโโ escalarmulfix.circom
    โ       โโโ montgomery.circom
    โ       โโโ mux3.circom
    โ       โโโ poseidon.circom
    โ       โโโ poseidon_old.circom
    โโโ contracts/
    โ   โโโ EncryptedERC.sol
    โ   โโโ EncryptedUserBalances.sol
    โ   โโโ Registrar.sol
    โ   โโโ auditor/
    โ   โ   โโโ AuditorManager.sol
    โ   โโโ errors/
    โ   โ   โโโ Errors.sol
    โ   โโโ interfaces/
    โ   โ   โโโ IEncryptedERC.sol
    โ   โ   โโโ IRegistrar.sol
    โ   โ   โโโ verifiers/
    โ   โ       โโโ IBurnVerifier.sol
    โ   โ       โโโ IMintVerifier.sol
    โ   โ       โโโ IRegistrationVerifier.sol
    โ   โ       โโโ ITransferVerifier.sol
    โ   โ       โโโ IWithdrawVerifier.sol
    โ   โโโ libraries/
    โ   โ   โโโ BabyJubJub.sol
    โ   โโโ metadata/
    โ   โ   โโโ EncryptedMetadata.sol
    โ   โ   โโโ IEncryptedMetadata.sol
    โ   โโโ prod/
    โ   โ   โโโ BurnVerifier.sol
    โ   โ   โโโ MintVerifier.sol
    โ   โ   โโโ RegistrationVerifier.sol
    โ   โ   โโโ TransferVerifier.sol
    โ   โ   โโโ WithdrawVerifier.sol
    โ   โโโ tokens/
    โ   โ   โโโ FeeERC20.sol
    โ   โ   โโโ SimpleERC20.sol
    โ   โ   โโโ TokenTracker.sol
    โ   โโโ types/
    โ   โ   โโโ Types.sol
    โ   โโโ verifiers/
    โ       โโโ BurnCircuitGroth16Verifier.sol
    โ       โโโ MintCircuitGroth16Verifier.sol
    โ       โโโ RegistrationCircuitGroth16Verifier.sol
    โ       โโโ TransferCircuitGroth16Verifier.sol
    โ       โโโ WithdrawCircuitGroth16Verifier.sol
    โโโ scripts/
    โ   โโโ constants.ts
    โ   โโโ deploy-converter.ts
    โ   โโโ deploy-standalone.ts
    โโโ src/
    โ   โโโ constants.ts
    โ   โโโ index.ts
    โ   โโโ metadata.ts
    โ   โโโ jub/
    โ   โ   โโโ index.ts
    โ   โ   โโโ jub.ts
    โ   โโโ poseidon/
    โ       โโโ index.ts
    โ       โโโ poseidon.ts
    โโโ test/
    โ   โโโ EncryptedERC-Converter.ts
    โ   โโโ EncryptedERC-Standalone.ts
    โ   โโโ EncryptedMetadata.ts
    โ   โโโ helpers.ts
    โ   โโโ user.ts
    โโโ zk/
    โ   โโโ go.mod
    โ   โโโ go.sum
    โ   โโโ Makefile
    โ   โโโ cmd/
    โ       โโโ main.go
    โโโ .github/
        โโโ workflows/
            โโโ ci.yml


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div  align="center">

<img  src="images/banner.png">

</div>

[![Coverage](https://img.shields.io/badge/Coverage-97%25-brightgreen)](https://github.com/ava-labs/EncryptedERC/actions/workflows/ci.yml)
[![Security Audit](https://img.shields.io/badge/Security%20Audit-Passed-green)](https://github.com/ava-labs/EncryptedERC/tree/main/audit)
[![Documentation](https://img.shields.io/badge/docs-available-green)](https://docs.avacloud.io/encrypted-erc)

# Encrypted ERC-20 Protocol

The Encrypted ERC-20 (eERC) standard, developed by [AvaCloud](https://avacloud.io), enables secure and confidential token transfers on Avalanche blockchains. Leveraging zk-SNARKs and partially homomorphic encryption, the eERC protocol offers robust privacy without requiring protocol-level modifications or off-chain intermediaries.
AvaCloud API documentation can be found [here](https://docs.avacloud.io/encrypted-erc/getting-started/what-is-encrypted-erc)

## Key features

- **Confidential Transactions**: User balances and transaction amounts remain completely hidden, ensuring financial confidentiality.

- **Large Integers**: Efficiently handles large token amounts up to 251 bits (2^251), providing greater flexibility.

- **Client-Side Operations**: Users retain control, performing encryption, decryption, and zk-proof generation directly on their own devices.

- **Fully On-chain Nature**: Operates entirely on-chain without the need for relayers or off-chain actors.


- **Built-in Compliance**: Supports external and rotatable auditors, ensuring regulatory compliance.


- **Dual-Mode Operation**: Supports both creating new private tokens and converting existing ERC-20 tokens their private versions.

- **Zero-Knowledge Proofs**: Uses efficient zk-SNARKs to validate statements without revealing sensitive information.

- **Chain Agnostic**: Can be deployed on any EVM-compatible blockchain.

- **(NEW) Encrypted Metadata**: Allows users to send arbitrary-length encrypted metadata along with transactions.


## Architecture

The eERC protocol consists of several key components:

### Core Contracts

- **EncryptedERC** ([contracts/EncryptedERC.sol](contracts/EncryptedERC.sol)): The main contract that implements the privacy-preserving ERC-20 functionality. It handles:

  - Private token operations (mint, burn, transfer)
  - Privacy-preserving balance management
  - Integration with other core components

- **Registrar**: Manages user registration and public key association.

  - Handles user registration
  - Stores public keys
  - Validates user identities
  - Manages registration proofs

- **EncryptedUserBalances**: Handles encrypted balance storage and updates.

  - Stores encrypted balances
  - Manages balance updates in encrypted manner
  - Ensures balance privacy
  - Handles encrypted balance verification

- **TokenTracker**: Manages token registration and tracking.

  - Tracks registered tokens
  - Manages token metadata
  - Handles token blacklisting

- **AuditorManager**: Provides auditor-related functionality for compliance.
  - Manages auditor permissions
  - Stores auditor address with it's public key

### Cryptographic Components

- **BabyJubJub**: Library for elliptic curve operations on the BabyJubJub curve.

- **Zero-Knowledge Circuits**: Circom-based circuits for proof generation and verification.

  - **Registration Circuit**: Validates user registration
  - **Mint Circuit**: Verifies minting operations
  - **Transfer Circuit**: Validates private transfers
  - **Withdraw Circuit**: Verifies withdrawal operations

### Operation Modes

1. **Standalone Mode**:

   - Creates entirely new private ERC-20 (eERC) tokens
   - Relies on minting and burning to manage token supply
   - Keeps total supply private all the time, offering better privacy compared to converter mode

2. **Converter Mode**:
   - Wraps existing ERC20 tokens to eERC tokens
   - Relies on deposits and withdrawals to manage token supply
   - Maintains compatibility with original tokens

## File structure

- [contracts](#contracts) Smart contract source files

  - `EncryptedERC.sol` - Main contract implementation

  - `Registrar.sol` - User registration management

  - `EncryptedUserBalances.sol` - Encrypted balance handling

  - `tokens/TokenTracker.sol` - Token registration and tracking

  - `auditor/AuditorManager.sol` - Auditor functionality

  - `libraries/BabyJubJub.sol` - Cryptographic operations

  - `types/Types.sol` - Data structures and types

  - `interfaces/` - Contract interfaces

  - `verifiers/` - Zero-knowledge proof verifiers

- [scripts](#scripts) Utility and deployment scripts

- [src](#src) Encryption utilities for TypeScript

- [tests](#tests) Test scripts and helpers

- [circom](#circom) Zero-knowledge proof circuits

## Getting Started

### Prerequisites

You need following dependencies for setup:

- `NodeJS >= v22.x`

- `Circom >= 2.1.9`

### Installation

1. Clone the repo

```sh
git clone https://github.com/ava-labs/EncryptedERC.git
```

2. Install NPM packages

```sh
npm install
```

3. Compile the contracts

```sh
npx hardhat compile
```

4. Compile Circuits

```sh
npx hardhat zkit make --force # compiles circuits
npx hardhat zkit verifiers    # generates verifiers
```

## Deployment (Local)

### Standalone

The Standalone version lets users create entirely new private ERC-20 tokens with built-in privacy, supporting confidential minting and burning.

1. Start the local node

```sh
npx hardhat node
```

2. Deploy the contract

```sh
npx hardhat run scripts/deploy-standalone.ts --network localhost
```

Refer to the [scripts/deploy-standalone.ts](scripts/deploy-standalone.ts) script for deployment examples.

### Converter

The Converter version adds privacy features to existing ERC-20 tokens, enabling users to convert standard ERC-20 tokens to private ones and switch between public and private states through deposit and withdrawal functions.

1. Start the local node

```sh
npx hardhat node
```

2. Deploy the contract

```sh
npx hardhat run scripts/deploy-converter.ts --network localhost
```

Refer to the [scripts/deploy-converter.ts](scripts/deploy-converter.ts) script for deployment examples.

## Architecture Overview

```mermaid
---
config:
  theme: neo-dark
---
  flowchart LR
  subgraph subGraph0["eERC SDK"]
          KeyMgmt["Key Generation"]
          ProofGen["Proof Generation"]
          TxBuild["Transaction Building"]
          BalanceEnc["Balance Encryption/Decryption"]
          SDK["Client SDK"]
    end
  subgraph subGraph1["Core Layer"]
          EERC["EncryptedERC"]
          StoreKeys["Store Public Keys"]
          ManageBalances["Manage Encrypted Balances"]
          HandleAudits["Handle Auditors"]
          PrivateOps["Private Token Operations"]
          VerifyProof["Verify ZK Proof"]
    end
  subgraph subGraph1["Contract Layer"]
          Registrar["Registrar"]
          EncryptedUserBalances["EncryptedUserBalances"]
          AuditorManager["AuditorManager"]
          ZKVerifiers["ZK Verifiers"]
          RegVerifier["Registration Verifier"]
          TransVerifier["Transfer Verifier"]
          MintVerifier["Mint Verifier"]
          WithdrawVerifier["Withdraw Verifier"]
    end
      User["User"] -- All Client Operations --> SDK
      SDK --> KeyMgmt & ProofGen & TxBuild & BalanceEnc
      subGraph0 -- Submit Tx + ZK Proof --> EERC
      EERC --> StoreKeys & ManageBalances & HandleAudits & PrivateOps & VerifyProof
      StoreKeys --> Registrar
      ManageBalances --> EncryptedUserBalances
      HandleAudits --> AuditorManager
      VerifyProof --> ZKVerifiers
      ZKVerifiers --> RegVerifier & TransVerifier & MintVerifier & WithdrawVerifier
```

## Run Tests/Coverage

Contract tests:

```sh
npx hardhat test
```

Coverage report:

```sh
npx hardhat coverage
```

## ๐ Efficiency Overview

### โฝ Avg. On-Chain Gas Costs (Avalanche C-Chain Mainnet)

```sh
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Solidity and Network Configuration                                                                                                                                                โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Solidity: 0.8.27                                                                              ยท  Optim: true    ยท  Runs: 200    ยท  viaIR: false   ยท     Block: 30,000,000 gas     โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Network: AVALANCHE                                                                            ยท  L1: 0.14345 gwei               ยท                 ยท        16.36 usd/avax         โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Contracts / Methods                                                                           ยท  Min            ยท  Max          ยท  Avg            ยท    calls       ยท  usd (avg)   โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  EncryptedERC                                                                                  ยท                                                                                   โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      deposit(uint256,address,uint256[7])                                                       ยท         71,680  ยท      841,771  ยท        564,892  ยท            16  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      privateBurn(((uint256[2],uint256[2][2],uint256[2]),uint256[32]),uint256[7])               ยท        890,507  ยท    1,227,920  ยท      1,028,678  ยท             4  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      privateMint(address,((uint256[2],uint256[2][2],uint256[2]),uint256[24]))                  ยท        712,316  ยท      760,624  ยท        722,016  ยท            10  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      setAuditorPublicKey(address)                                                              ยท              -  ยท            -  ยท        103,851  ยท             4  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      setTokenBlacklist(address,bool)                                                           ยท              -  ยท            -  ยท         46,443  ยท             1  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      transfer(address,uint256,((uint256[2],uint256[2][2],uint256[2]),uint256[32]),uint256[7])  ยท        947,295  ยท      947,331  ยท        947,313  ยท             4  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      withdraw(uint256,((uint256[2],uint256[2][2],uint256[2]),uint256[16]),uint256[7])          ยท        775,186  ยท      828,341  ยท        796,263  ยท             6  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Registrar                                                                                     ยท                                                                                   โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      register(((uint256[2],uint256[2][2],uint256[2]),uint256[5]))                              ยท        322,114  ยท      322,150  ยท        322,143  ยท            20  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Deployments                                                                                                     ยท                                 ยท  % of limit    ยท              โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  BabyJubJub                                                                                    ยท              -  ยท            -  ยท        447,616  ยท         1.5 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  EncryptedERC                                                                                  ยท      3,704,671  ยท    3,729,773  ยท      3,717,222  ยท        12.4 %  ยท        0.01  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  MintCircuitGroth16Verifier                                                                    ยท              -  ยท            -  ยท      1,690,470  ยท         5.6 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Registrar                                                                                     ยท              -  ยท            -  ยท        508,067  ยท         1.7 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  RegistrationCircuitGroth16Verifier                                                            ยท              -  ยท            -  ยท        810,848  ยท         2.7 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  TransferCircuitGroth16Verifier                                                                ยท              -  ยท            -  ยท      2,052,092  ยท         6.8 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  WithdrawCircuitGroth16Verifier                                                                ยท              -  ยท            -  ยท      1,319,158  ยท         4.4 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Key                                                                                                                                                                               โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  โณ  Cost was non-zero but below the precision setting for the currency display                                                                                                     โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
```

## Security Audits

1. **Circom Audit**

   - Date: March 2025
   - Scope: Circom circuits for various zero-knowledge proofs
   - Report: [avacloud-eerc-circom-audit.pdf](audit/avacloud-eerc-circom-audit.pdf)

2. **Gnark Audit**
   - Date: March 2025
   - Scope: Core protocol and Gnark circuits for zero-knowledge proofs
   - Report: [avacloud-eerc-audit.pdf](audit/avacloud-eerc-audit.pdf)

## Security Considerations

- **Auditor Integration**: The protocol includes built-in auditor functionality for compliance.

- **Blacklisting**: Supports optionalblacklisting for security purposes.

### Notes

For production deployments, set `isProd` to `true` in the deployment scripts to use the production verifiers. These verifiers use secure trusted setups from the [zkevm](https://github.com/iden3/snarkjs?tab=readme-ov-file#7-prepare-phase-2).

Corresponding `zkey` and `verification_key.json` files are present in the `circuits/build` directory. After compiling circuits present in the `circuits` folder, and downloading the proper `.ptau` files, these can be verified using the `snarkjs` tool with the following command:

```sh
snarkjs zkey verify <circuit_name>.r1cs powersOfTau28_hez_final_<Size>.ptau <circuit_name>.zkey
```

- For transfer/mint circuit => `powersOfTau28_hez_final_15.ptau`
- For withdraw circuit => `powersOfTau28_hez_final_14.ptau`
- For registration circuit => `powersOfTau28_hez_final_11.ptau`

## License

This project is licensed under the Ecosystem License - see the LICENSE file for details.



================================================
FILE: biome.json
================================================
{
	"$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
	"vcs": {
		"enabled": false,
		"clientKind": "git",
		"useIgnoreFile": false
	},
	"files": {
		"ignoreUnknown": false,
		"ignore": [
			"typechain-types",
			"coverage",
			"artifacts",
			".vscode",
			"generated-types"
		]
	},
	"formatter": {
		"enabled": true,
		"indentStyle": "tab"
	},
	"organizeImports": {
		"enabled": true
	},
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true
		}
	},
	"javascript": {
		"formatter": {
			"quoteStyle": "double"
		}
	}
}



================================================
FILE: hardhat.config.ts
================================================
import "@nomicfoundation/hardhat-chai-matchers";
import "@nomicfoundation/hardhat-ethers";
import "@solarity/chai-zkit";
import "@solarity/hardhat-zkit";
import "@typechain/hardhat";
import "hardhat-gas-reporter";
import type { HardhatUserConfig } from "hardhat/config";
import "solidity-coverage";

import dotenv from "dotenv";
dotenv.config();

const RPC_URL = process.env.RPC_URL || "https://api.avax.network/ext/bc/C/rpc";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.27",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
    },
  },
  networks: {
    hardhat: {
      forking: {
        url: RPC_URL,
        blockNumber: 59121339,
        enabled: !!process.env.FORKING,
      },
    },
  },
  gasReporter: {
    enabled: !!process.env.REPORT_GAS,
    currency: "USD",
    coinmarketcap: process.env.COINMARKETCAP_API_KEY,
    excludeContracts: ["contracts/mocks/"],
    outputFile: "gas-report.txt",
    L1: "avalanche",
    showMethodSig: true,
  },
  zkit: {
    compilerVersion: "2.1.9",
    circuitsDir: "circom",
    compilationSettings: {
      artifactsDir: "zkit/artifacts",
      onlyFiles: [],
      skipFiles: [],
      c: false,
      json: false,
      optimization: "O2",
    },
    setupSettings: {
      contributionSettings: {
        provingSystem: "groth16",
        contributions: 0,
      },
      onlyFiles: [],
      skipFiles: [],
      ptauDir: undefined,
      ptauDownload: true,
    },
    verifiersSettings: {
      verifiersDir: "contracts/verifiers",
      verifiersType: "sol",
    },
    typesDir: "generated-types/zkit",
    quiet: false,
  },
};

export default config;



================================================
FILE: LICENSE.md
================================================
Copyright (C) 2025, Ava Labs, Inc. All rights reserved.

Ecosystem License
Version: 1.1

Subject to the terms herein, Ava Labs, Inc. (**โAva Labsโ**) hereby grants you
a limited, royalty-free, worldwide, non-sublicensable, non-transferable,
non-exclusive license to use, copy, modify, create derivative works based on,
and redistribute the Software, in source code, binary, or any other form,
including any modifications or derivative works of the Software (collectively,
**โLicensed Softwareโ**), in each case subject to this Ecosystem License
(**โLicenseโ**).

This License applies to all copies, modifications, derivative works, and any
other form or usage of the Licensed Software. You will include and display
this License, without modification, with all uses of the Licensed Software,
regardless of form.

You will use the Licensed Software solely (i) in connection with the Avalanche
Public Blockchain platform, having a NetworkID of 1 (Mainnet) or 5 (Fuji), and
associated blockchains, comprised exclusively of the Avalanche X-Chain,
C-Chain, P-Chain and any subnets linked to the P-Chain (โAvalanche Authorized
Platformโ) or (ii) for non-production, testing or research purposes within the
Avalanche ecosystem, in each case, without any commercial application
(โNon-Commercial Useโ); provided that this License does not permit use of the
Licensed Software in connection with (a) any forks of the Avalanche Authorized
Platform or (b) in any manner not operationally connected to the Avalanche
Authorized Platform other than, for the avoidance of doubt, the limited
exception for Non-Commercial Use. Ava Labs may publicly announce changes or
additions to the Avalanche Authorized Platform, which may expand or modify
usage of the Licensed Software. Upon such announcement, the Avalanche
Authorized Platform will be deemed to be the then-current iteration of such
platform.

You hereby acknowledge and agree to the terms set forth at
www.avalabs.org/important-notice.

If you use the Licensed Software in violation of this License, this License
will automatically terminate and Ava Labs reserves all rights to seek any
remedy for such violation.

Except for uses explicitly permitted in this License, Ava Labs retains all
rights in the Licensed Software, including without limitation the ability to
modify it.

Except as required or explicitly permitted by this License, you will not use
any Ava Labs names, logos, or trademarks without Ava Labsโ prior written
consent.

You may use this License for software other than the โLicensed Softwareโ
specified above, as long as the only change to this License is the definition
of the term โLicensed Software.โ

The Licensed Software may reference third party components. You acknowledge
and agree that these third party components may be governed by a separate
license or terms and that you will comply with them.

**TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE LICENSED SOFTWARE IS PROVIDED
ON AN โAS ISโ BASIS, AND AVA LABS EXPRESSLY DISCLAIMS AND EXCLUDES ALL
REPRESENTATIONS, WARRANTIES AND OTHER TERMS AND CONDITIONS, WHETHER EXPRESS OR
IMPLIED, INCLUDING WITHOUT LIMITATION BY OPERATION OF LAW OR BY CUSTOM,
STATUTE OR OTHERWISE, AND INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTY,
TERM, OR CONDITION OF NON-INFRINGEMENT, MERCHANTABILITY, TITLE, OR FITNESS FOR
PARTICULAR PURPOSE. YOU USE THE LICENSED SOFTWARE AT YOUR OWN RISK. AVA LABS
EXPRESSLY DISCLAIMS ALL LIABILITY (INCLUDING FOR ALL DIRECT, CONSEQUENTIAL OR
OTHER DAMAGES OR LOSSES) RELATED TO ANY USE OF THE LICENSED SOFTWARE.**



================================================
FILE: package.json
================================================
{
	"name": "encryptederc",
	"version": "1.0.0",
	"devDependencies": {
		"@biomejs/biome": "^1.9.4",
		"@nomicfoundation/hardhat-chai-matchers": "^2.0.8",
		"@nomicfoundation/hardhat-ethers": "^3.0.8",
		"@openzeppelin/contracts": "^5.1.0",
		"@solarity/chai-zkit": "^0.3.1",
		"@solarity/hardhat-zkit": "^0.5.15",
		"@typechain/hardhat": "^9.1.0",
		"@types/jest": "^29.5.14",
		"@types/mocha": "^10.0.10",
		"@zk-kit/baby-jubjub": "^1.0.3",
		"dotenv": "^16.4.7",
		"hardhat": "^2.22.15",
		"hardhat-gas-reporter": "^2.2.2",
		"maci-crypto": "^2.0.0",
		"poseidon-lite": "^0.3.0",
		"prettier": "^3.5.3",
		"prettier-plugin-solidity": "^1.4.2",
		"solhint": "^5.0.5",
		"solidity-coverage": "^0.8.14"
	},
	"scripts": {
		"test": "mocha 'src/**/*.test.js'",
		"postinstall": "npx hardhat compile & npx hardhat zkit make --force && npx hardhat zkit verifiers",
		"lint:sol": "solhint '**/*.sol' --config ./.solhint.json --ignore-path ./.solhintignore --max-warnings 0 && npx prettier --check '**/*.sol' --config ./.prettierrc",
		"lint:ts": "npx biome lint .",
		"lint": "npm run lint:sol && npm run lint:ts"
	},
	"keywords": [],
	"author": "",
	"repository": {
		"url": "https://github.com/ava-labs/EncryptedERC",
		"type": "git"
	}
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": [
    "./src/**/*.ts",
    "./test/**/*.ts",
    "./scripts/**/*.ts",
    "./typechain-types"
  ],
  "exclude": [],
  "files": ["./hardhat.config.ts"]
}



================================================
FILE: .env.example
================================================
COINMARKETCAP_API_KEY=""
REPORT_GAS=""
FORKING=""


================================================
FILE: .nvmrc
================================================
v22.14.0



================================================
FILE: .prettierignore
================================================
contracts/verifiers/*
contracts/prod/*
circom/build/*


================================================
FILE: .prettierrc
================================================
{
	"plugins": ["prettier-plugin-solidity"],
	"overrides": [
		{
			"files": "*.sol",
			"options": {
				"parser": "solidity-parse",
				"printWidth": 80,
				"tabWidth": 4,
				"useTabs": false,
				"singleQuote": false,
				"bracketSpacing": false
			}
		}
	]
}



================================================
FILE: .solcover.js
================================================
module.exports = {
  skipFiles: [
    "SimpleERC20.sol",
    "FeeERC20.sol",
    "x",
    "verifiers"
  ],
};



================================================
FILE: .solhint.json
================================================
{
  "extends": "solhint:recommended",
  "rules": {
    "compiler-version": [
      "error",
      "0.8.27"
    ],
    "no-unused-vars": "error",
    "func-visibility": [
      "error",
      {
        "ignoreConstructors": true
      }
    ],
    "private-vars-leading-underscore": [
      "warn",
      {
        "strict": true
      }
    ],
    "reason-string": [
      "warn",
      {
        "maxLength": 75
      }
    ],
    "gas-custom-errors": "off",
    "ordering": "error",
    "immutable-vars-naming": [
      "warn",
      {
        "immutablesAsConstants": false
      }
    ],
    "func-named-parameters": [
      "error",
      5
    ],
    "one-contract-per-file": "off",
    "no-console": "off"
  }
}


================================================
FILE: .solhintignore
================================================
node_modules/
contracts/verifiers/*
contracts/prod/*
circom/build/*




================================================
FILE: circom/burn.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template BurnCircuit () {
    signal input ValueToBurn;
    
    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderBalance;
    signal input SenderBalanceC1[2];
    signal input SenderBalanceC2[2];

    signal input SenderVTBC1[2];
    signal input SenderVTBC2[2];

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;

    // Verify that the transfer amount is less than or equal to the sender's balance and is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;   

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToBurn;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== ValueToBurn;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component bitCheck3 = Num2Bits(252);
    bitCheck3.in <== SenderBalance + 1;

    component checkValue = LessThan(252);
    checkValue.in[0] <== ValueToBurn;
    checkValue.in[1] <== SenderBalance + 1;
    checkValue.out === 1;


    // Verify that the sender's public key is well-formed
    component checkSenderPK = CheckPublicKey();
    checkSenderPK.privKey <== SenderPrivateKey;
    checkSenderPK.pubKey[0] <== SenderPublicKey[0];
    checkSenderPK.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's encrypted balance is well-formed
    component checkSenderBalance = CheckValue();
    checkSenderBalance.value <== SenderBalance;
    checkSenderBalance.privKey <== SenderPrivateKey;
    checkSenderBalance.valueC1[0] <== SenderBalanceC1[0];
    checkSenderBalance.valueC1[1] <== SenderBalanceC1[1];
    checkSenderBalance.valueC2[0] <== SenderBalanceC2[0];
    checkSenderBalance.valueC2[1] <== SenderBalanceC2[1];

    // Verify that the sender's encrypted value to burn is the burn amount
    component checkSenderVTB = CheckValue();
    checkSenderVTB.value <== ValueToBurn;
    checkSenderVTB.privKey <== SenderPrivateKey;
    checkSenderVTB.valueC1[0] <== SenderVTBC1[0];
    checkSenderVTB.valueC1[1] <== SenderVTBC1[1];
    checkSenderVTB.valueC2[0] <== SenderVTBC2[0];
    checkSenderVTB.valueC2[1] <== SenderVTBC2[1];

    // Verify auditor's encrypted summary includes the burn amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToBurn;
}

component main { public [ SenderPublicKey, AuditorPublicKey, SenderBalanceC1, SenderBalanceC2, SenderVTBC1, SenderVTBC2, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce ] } = BurnCircuit();


================================================
FILE: circom/components.circom
================================================
pragma circom 2.1.9;

include "./circomlib/poseidon.circom";
include "./circomlib/babyjub.circom";
include "./circomlib/escalarmulany.circom";

// Performs a Poseidon decryption of a given length
// Taken from https://github.com/Shigoto-dev19/poseidon-encryption-circom2/blob/master-circom2/circom/poseidon.circom
template PoseidonDecrypt(l) {
    var decryptedLength = l;
    while (decryptedLength % 3 != 0) {
        decryptedLength += 1;
    }

    signal input ciphertext[decryptedLength + 1];
    signal input nonce;
    signal input key[2];
    signal output decrypted[decryptedLength];

    var two128 = 2 ** 128;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== nonce;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== two128;

    component lt = LessThan(252);
    lt.in[0] <== nonce;
    lt.in[1] <== two128;
    lt.out === 1;

    var n = (decryptedLength + 1) \ 3;

    component strategies[n + 1];
    strategies[0] = PoseidonEx(3, 4);
    strategies[0].initialState <== 0;
    strategies[0].inputs[0] <== key[0];
    strategies[0].inputs[1] <== key[1];
    strategies[0].inputs[2] <== nonce + (l * two128);

    for (var i = 0; i < n; i ++) {
        for (var j = 0; j < 3; j ++) {
            decrypted[i * 3 + j] <== ciphertext[i * 3 + j] - strategies[i].out[j + 1];
        }

        strategies[i + 1] = PoseidonEx(3, 4);
        strategies[i + 1].initialState <== strategies[i].out[0];
        for (var j = 0; j < 3; j ++) {
            strategies[i + 1].inputs[j] <== ciphertext[i * 3 + j];
        }
    }

    // Check the last ciphertext element
    ciphertext[decryptedLength] === strategies[n].out[1];

    // If length > 3, check if the last (3 - (l mod 3)) elements of the message
    // are 0
    if (l % 3 > 0) {
        if (l % 3 == 1) {
            decrypted[decryptedLength - 1] === 0;
        } else if (l % 3 == 2) {
            decrypted[decryptedLength - 1] === 0;
            decrypted[decryptedLength - 2] === 0;
        }
    }
}

// BabyJubJub Scalar Multiplication
// Converted from https://github.com/iden3/circomlib/blob/master/circuits/babyjub.circom BabyPbk()
template BabyScalarMul() {
    signal input  scalar;
    signal input point[2];
    signal output Ax;
    signal output Ay;

    component checkPoint = BabyCheck();
    checkPoint.x <== point[0];
    checkPoint.y <== point[1];

    component scalarBits = Num2Bits(253);
    scalarBits.in <== scalar;

    component mulAny = EscalarMulAny(253);
    mulAny.p[0] <== point[0];
    mulAny.p[1] <== point[1];

    var i;
    for (i=0; i<253; i++) {
        mulAny.e[i] <== scalarBits.out[i];
    }
    Ax  <== mulAny.out[0];
    Ay  <== mulAny.out[1];
}


// ElGamal encryption over BabyJubJub curve while preserving the additively homomorphic property.
// The scheme maps a scalar to a point on the curve and then adds it to the public key point. It outputs the two points of the resulting ciphertext (c1, c2).
template ElGamalEncrypt() {
    signal input random;
    signal input pk[2];
    signal input msg[2];
    signal output encryptedC1X;
    signal output encryptedC1Y;
    signal output encryptedC2X;
    signal output encryptedC2Y;

    component checkPoint = BabyCheck();
    checkPoint.x <== pk[0];
    checkPoint.y <== pk[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== msg[0];
    checkPoint2.y <== msg[1];

    component randomBits = Num2Bits(253);
    randomBits.in <== random;

    component randomToPoint = BabyPbk();
    randomToPoint.in <== random;

    component pkandr = EscalarMulAny(253);
    for (var i = 0; i < 253; i ++) {
        pkandr.e[i] <== randomBits.out[i];
    }
    pkandr.p[0] <== pk[0];
    pkandr.p[1] <== pk[1];
    
    component addRes = BabyAdd();
    addRes.x1 <== msg[0];
    addRes.y1 <== msg[1];
    addRes.x2 <== pkandr.out[0];
    addRes.y2 <== pkandr.out[1];

    encryptedC1X <== randomToPoint.Ax;
    encryptedC1Y <== randomToPoint.Ay;
    encryptedC2X <== addRes.xout;
    encryptedC2Y <== addRes.yout;

}

// ElGamal Decryption scheme over BabyJub curve while preserving the additively homomorphic property.
// The scheme takes the two points of the ciphertext (c1, c2) and the private key and outputs the message, mapped to a point.
template ElGamalDecrypt() {
    signal input c1[2];
    signal input c2[2];
    signal input privKey;
    signal output outx;
    signal output outy;

    component checkPoint = BabyCheck();
    checkPoint.x <== c1[0];
    checkPoint.y <== c1[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== c2[0];
    checkPoint2.y <== c2[1];

    // Convert the private key to bits
    component privKeyBits = Num2Bits(253);
    privKeyBits.in <== privKey;

    // c1 ** x
    component c1x = EscalarMulAny(253);
    for (var i = 0; i < 253; i ++) {
        c1x.e[i] <== privKeyBits.out[i];
    }
    c1x.p[0] <== c1[0];
    c1x.p[1] <== c1[1];

    // (c1 * x) * -1
    signal c1xInverseX;
    c1xInverseX <== 0 - c1x.out[0];

    // ((c1 * x) * - 1) * c2
    component decryptedPoint = BabyAdd();
    decryptedPoint.x1 <== c1xInverseX;
    decryptedPoint.y1 <== c1x.out[1];
    decryptedPoint.x2 <== c2[0];
    decryptedPoint.y2 <== c2[1];

    outx <== decryptedPoint.xout;
    outy <== decryptedPoint.yout;
}

template CheckPublicKey() {
    signal input privKey;
    signal input pubKey[2];

    // Verify the private key is not zero
    component checkIsZero = IsZero();
    checkIsZero.in <== privKey;
    checkIsZero.out === 0;

    component checkPoint = BabyCheck();
    checkPoint.x <== pubKey[0];
    checkPoint.y <== pubKey[1];
    
    // Verify the private key is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== privKey;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== privKey;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component checkPK = BabyPbk();
    checkPK.in <== privKey;

    checkPK.Ax === pubKey[0];
    checkPK.Ay === pubKey[1];
}

template CheckValue() {
    signal input value;
    signal input privKey;
    signal input valueC1[2];
    signal input valueC2[2];

    component checkPoint = BabyCheck();
    checkPoint.x <== valueC1[0];
    checkPoint.y <== valueC1[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== valueC2[0];
    checkPoint2.y <== valueC2[1];
    
    // Verify the value is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== value;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== value;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component checkValue = ElGamalDecrypt();
    checkValue.c1[0] <== valueC1[0];
    checkValue.c1[1] <== valueC1[1];
    checkValue.c2[0] <== valueC2[0];
    checkValue.c2[1] <== valueC2[1];
    checkValue.privKey <== privKey;
    
    component valueToPoint = BabyPbk();
    valueToPoint.in <== value;

    valueToPoint.Ax === checkValue.outx;
    valueToPoint.Ay === checkValue.outy;
}


template CheckReceiverValue() {
    signal input receiverValue;
    signal input receiverPublicKey[2];
    signal input receiverRandom;
    signal input receiverValueC1[2];
    signal input receiverValueC2[2];

    component checkPoint = BabyCheck();
    checkPoint.x <== receiverValueC1[0];
    checkPoint.y <== receiverValueC1[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== receiverValueC2[0];
    checkPoint2.y <== receiverValueC2[1];

    // Verify the receiver value is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== receiverValue;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== receiverValue;
    lt.in[1] <== baseOrder;
    lt.out === 1;
    
    component receiverValueToPoint = BabyPbk();
    receiverValueToPoint.in <== receiverValue;

    component receiverValueEncrypt = ElGamalEncrypt();
    receiverValueEncrypt.random <== receiverRandom;
    receiverValueEncrypt.pk[0] <== receiverPublicKey[0];
    receiverValueEncrypt.pk[1] <== receiverPublicKey[1];
    receiverValueEncrypt.msg[0] <== receiverValueToPoint.Ax;
    receiverValueEncrypt.msg[1] <== receiverValueToPoint.Ay;

    receiverValueEncrypt.encryptedC1X === receiverValueC1[0];
    receiverValueEncrypt.encryptedC1Y === receiverValueC1[1];
    receiverValueEncrypt.encryptedC2X === receiverValueC2[0];
    receiverValueEncrypt.encryptedC2Y === receiverValueC2[1];
}

template CheckPCT() {
    signal input publicKey[2];
    signal input pct[4];
    signal input authKey[2];
    signal input nonce;
    signal input random;
    signal input value;

    component checkPoint = BabyCheck();
    checkPoint.x <== publicKey[0];
    checkPoint.y <== publicKey[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== authKey[0];
    checkPoint2.y <== authKey[1];

    // Verify the random is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== random;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== random;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component checkAuthKey = BabyPbk();
    checkAuthKey.in <== random;

    checkAuthKey.Ax === authKey[0];
    checkAuthKey.Ay === authKey[1];

    component checkEncKey = BabyScalarMul();
    checkEncKey.scalar <== random;
    checkEncKey.point[0] <== publicKey[0];
    checkEncKey.point[1] <== publicKey[1];

    component decryptedPCT = PoseidonDecrypt(1);
    decryptedPCT.ciphertext <== pct;
    decryptedPCT.nonce <== nonce;
    decryptedPCT.key[0] <== checkEncKey.Ax;
    decryptedPCT.key[1] <== checkEncKey.Ay;


    decryptedPCT.decrypted[0] === value;
}

template CheckNullifierHash() {
    signal input nullifierHash;
    signal input chainID;
    signal input auditorCiphertext[4];

    component hash = Poseidon(5);
    hash.inputs[0] <== chainID;
    hash.inputs[1] <== auditorCiphertext[0];
    hash.inputs[2] <== auditorCiphertext[1];
    hash.inputs[3] <== auditorCiphertext[2];
    hash.inputs[4] <== auditorCiphertext[3];

    hash.out === nullifierHash;
}

template CheckRegistrationHash() {
    signal input registrationHash;
    signal input chainID;
    signal input senderPrivateKey;
    signal input senderAddress;

    component hash = Poseidon(3);
    hash.inputs[0] <== chainID;
    hash.inputs[1] <== senderPrivateKey;
    hash.inputs[2] <== senderAddress;

    hash.out === registrationHash;
}


================================================
FILE: circom/mint.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template MintCircuit () {
    signal input ValueToMint;

    signal input ChainID;
    signal input NullifierHash;

    signal input ReceiverPublicKey[2];
    signal input ReceiverVTTC1[2];
    signal input ReceiverVTTC2[2];
    signal input ReceiverVTTRandom;
    
    signal input ReceiverPCT[4];
    signal input ReceiverPCTAuthKey[2];
    signal input ReceiverPCTNonce;
    signal input ReceiverPCTRandom;

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;

    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;
    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToMint;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== ValueToMint;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    // Verify receiver's encrypted value is the mint amount
    component checkReceiverValue = CheckReceiverValue();
    checkReceiverValue.receiverValue <== ValueToMint;
    checkReceiverValue.receiverPublicKey[0] <== ReceiverPublicKey[0];
    checkReceiverValue.receiverPublicKey[1] <== ReceiverPublicKey[1];
    checkReceiverValue.receiverRandom <== ReceiverVTTRandom;
    checkReceiverValue.receiverValueC1[0] <== ReceiverVTTC1[0];
    checkReceiverValue.receiverValueC1[1] <== ReceiverVTTC1[1];
    checkReceiverValue.receiverValueC2[0] <== ReceiverVTTC2[0];
    checkReceiverValue.receiverValueC2[1] <== ReceiverVTTC2[1];

	// Verify nullifier hash is not used
    component checkNullifierHash = CheckNullifierHash();
    checkNullifierHash.nullifierHash <== NullifierHash;
    checkNullifierHash.chainID <== ChainID;
    checkNullifierHash.auditorCiphertext[0] <== AuditorPCT[0];
    checkNullifierHash.auditorCiphertext[1] <== AuditorPCT[1];
    checkNullifierHash.auditorCiphertext[2] <== AuditorPCT[2];
    checkNullifierHash.auditorCiphertext[3] <== AuditorPCT[3];

    // Verify receiver's encrypted summary includes the mint amount and is encrypted with the receiver's public key
    component checkReceiverPCT = CheckPCT();
    checkReceiverPCT.publicKey[0] <== ReceiverPublicKey[0];
    checkReceiverPCT.publicKey[1] <== ReceiverPublicKey[1];
    checkReceiverPCT.pct <== ReceiverPCT;
    checkReceiverPCT.authKey[0] <== ReceiverPCTAuthKey[0];
    checkReceiverPCT.authKey[1] <== ReceiverPCTAuthKey[1];
    checkReceiverPCT.nonce <== ReceiverPCTNonce;
    checkReceiverPCT.random <== ReceiverPCTRandom;
    checkReceiverPCT.value <== ValueToMint;

    // Verify auditor's encrypted summary includes the mint amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToMint;
    
}

component main { public [ ReceiverPublicKey, AuditorPublicKey, ReceiverVTTC1, ReceiverVTTC2, ReceiverPCT, ReceiverPCTAuthKey, ReceiverPCTNonce, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce, ChainID, NullifierHash ] } = MintCircuit();


================================================
FILE: circom/registration.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template RegistrationCircuit() {
    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderAddress;
    signal input ChainID;
    signal input RegistrationHash;

    // Verify that the sender's public key is well-formed
    component checkSenderPublicKey = CheckPublicKey();
    checkSenderPublicKey.privKey <== SenderPrivateKey;
    checkSenderPublicKey.pubKey[0] <== SenderPublicKey[0];
    checkSenderPublicKey.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's registration hash is well-formed
    component checkRegistrationHash = CheckRegistrationHash();
    checkRegistrationHash.registrationHash <== RegistrationHash;
    checkRegistrationHash.chainID <== ChainID;
    checkRegistrationHash.senderPrivateKey <== SenderPrivateKey;
    checkRegistrationHash.senderAddress <== SenderAddress;
}

component main { public [ SenderPublicKey, SenderAddress, ChainID, RegistrationHash ] } = RegistrationCircuit();


================================================
FILE: circom/transfer.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template TransferCircuit () {
    signal input ValueToTransfer;
    
    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderBalance;
    signal input SenderBalanceC1[2];
    signal input SenderBalanceC2[2];

    signal input SenderVTTC1[2];
    signal input SenderVTTC2[2];
    
    signal input ReceiverPublicKey[2];
    signal input ReceiverVTTC1[2];
    signal input ReceiverVTTC2[2];
    signal input ReceiverVTTRandom;
    
    signal input ReceiverPCT[4];
    signal input ReceiverPCTAuthKey[2];
    signal input ReceiverPCTNonce;
    signal input ReceiverPCTRandom;

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;

    // Verify that the transfer amount is less than or equal to the sender's balance and is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;   

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToTransfer;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== ValueToTransfer;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component bitCheck3 = Num2Bits(252);
    bitCheck3.in <== SenderBalance + 1;

    component checkValue = LessThan(252);
    checkValue.in[0] <== ValueToTransfer;
    checkValue.in[1] <== SenderBalance + 1;
    checkValue.out === 1;


    // Verify that the sender's public key is well-formed
    component checkSenderPK = CheckPublicKey();
    checkSenderPK.privKey <== SenderPrivateKey;
    checkSenderPK.pubKey[0] <== SenderPublicKey[0];
    checkSenderPK.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's encrypted balance is well-formed
    component checkSenderBalance = CheckValue();
    checkSenderBalance.value <== SenderBalance;
    checkSenderBalance.privKey <== SenderPrivateKey;
    checkSenderBalance.valueC1[0] <== SenderBalanceC1[0];
    checkSenderBalance.valueC1[1] <== SenderBalanceC1[1];
    checkSenderBalance.valueC2[0] <== SenderBalanceC2[0];
    checkSenderBalance.valueC2[1] <== SenderBalanceC2[1];

    // Verify that the sender's encrypted value to transfer is the transfer amount
    component checkSenderVTTC1 = CheckValue();
    checkSenderVTTC1.value <== ValueToTransfer;
    checkSenderVTTC1.privKey <== SenderPrivateKey;
    checkSenderVTTC1.valueC1[0] <== SenderVTTC1[0];
    checkSenderVTTC1.valueC1[1] <== SenderVTTC1[1];
    checkSenderVTTC1.valueC2[0] <== SenderVTTC2[0];
    checkSenderVTTC1.valueC2[1] <== SenderVTTC2[1];

	// Verify that the receiver's encrypted value is the transfer amount by encryption
    component checkReceiverValue = CheckReceiverValue();
    checkReceiverValue.receiverValue <== ValueToTransfer;
    checkReceiverValue.receiverPublicKey[0] <== ReceiverPublicKey[0];
    checkReceiverValue.receiverPublicKey[1] <== ReceiverPublicKey[1];
    checkReceiverValue.receiverRandom <== ReceiverVTTRandom;
    checkReceiverValue.receiverValueC1[0] <== ReceiverVTTC1[0];
    checkReceiverValue.receiverValueC1[1] <== ReceiverVTTC1[1];
    checkReceiverValue.receiverValueC2[0] <== ReceiverVTTC2[0]; 
    checkReceiverValue.receiverValueC2[1] <== ReceiverVTTC2[1];

    // Verify receiver's encrypted summary includes the transfer amount and is encrypted with the receiver's public key
    component checkReceiverPCT = CheckPCT();
    checkReceiverPCT.publicKey[0] <== ReceiverPublicKey[0];
    checkReceiverPCT.publicKey[1] <== ReceiverPublicKey[1];
    checkReceiverPCT.pct <== ReceiverPCT;
    checkReceiverPCT.authKey[0] <== ReceiverPCTAuthKey[0];
    checkReceiverPCT.authKey[1] <== ReceiverPCTAuthKey[1];
    checkReceiverPCT.nonce <== ReceiverPCTNonce;
    checkReceiverPCT.random <== ReceiverPCTRandom;
    checkReceiverPCT.value <== ValueToTransfer;

    // Verify auditor's encrypted summary includes the transfer amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToTransfer;
}

component main { public [ SenderPublicKey, ReceiverPublicKey, AuditorPublicKey, SenderBalanceC1, SenderBalanceC2, SenderVTTC1, SenderVTTC2, ReceiverVTTC1, ReceiverVTTC2, ReceiverPCT, ReceiverPCTAuthKey, ReceiverPCTNonce, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce ] } = TransferCircuit();


================================================
FILE: circom/withdraw.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template WithdrawCircuit() {
    signal input ValueToWithdraw;

    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderBalance;
    signal input SenderBalanceC1[2];
    signal input SenderBalanceC2[2];

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;


    // Verify the withdrawal amount is less than or equal to the sender's balance and is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;
    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToWithdraw;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component checkWithdrawalAmount = LessThan(252);
    checkWithdrawalAmount.in[0] <== ValueToWithdraw;
    checkWithdrawalAmount.in[1] <== baseOrder;
    checkWithdrawalAmount.out === 1;

    component bitCheck3 = Num2Bits(252);
    bitCheck3.in <== SenderBalance + 1;

    component checkValue = LessThan(252);
    checkValue.in[0] <== ValueToWithdraw;
    checkValue.in[1] <== SenderBalance + 1;
    checkValue.out === 1;

    // Verify that the sender's public key is well-formed
    component checkSenderPK = CheckPublicKey();
    checkSenderPK.privKey <== SenderPrivateKey;
    checkSenderPK.pubKey[0] <== SenderPublicKey[0];
    checkSenderPK.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's encrypted balance is well-formed
    component checkSenderBalance = CheckValue();
    checkSenderBalance.value <== SenderBalance;
    checkSenderBalance.privKey <== SenderPrivateKey;
    checkSenderBalance.valueC1[0] <== SenderBalanceC1[0];
    checkSenderBalance.valueC1[1] <== SenderBalanceC1[1];
    checkSenderBalance.valueC2[0] <== SenderBalanceC2[0];
    checkSenderBalance.valueC2[1] <== SenderBalanceC2[1];

    // Verify auditor's encrypted summary includes the withdrawal amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToWithdraw;
}

component main { public [ SenderPublicKey, SenderBalanceC1, SenderBalanceC2, AuditorPublicKey, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce, ValueToWithdraw ] } = WithdrawCircuit();


================================================
FILE: circom/circomlib/aliascheck.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "compconstant.circom";


template AliasCheck() {

    signal input in[254];

    component  compConstant = CompConstant(-1);

    for (var i=0; i<254; i++) in[i] ==> compConstant.in[i];

    compConstant.out === 0;
}



================================================
FILE: circom/circomlib/babyjub.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "bitify.circom";
include "escalarmulfix.circom";

template BabyAdd() {
    signal input x1;
    signal input y1;
    signal input x2;
    signal input y2;
    signal output xout;
    signal output yout;

    signal beta;
    signal gamma;
    signal delta;
    signal tau;

    var a = 168700;
    var d = 168696;

    beta <== x1*y2;
    gamma <== y1*x2;
    delta <== (-a*x1+y1)*(x2 + y2);
    tau <== beta * gamma;

    xout <-- (beta + gamma) / (1+ d*tau);
    (1+ d*tau) * xout === (beta + gamma);

    yout <-- (delta + a*beta - gamma) / (1-d*tau);
    (1-d*tau)*yout === (delta + a*beta - gamma);
}

template BabyDbl() {
    signal input x;
    signal input y;
    signal output xout;
    signal output yout;

    component adder = BabyAdd();
    adder.x1 <== x;
    adder.y1 <== y;
    adder.x2 <== x;
    adder.y2 <== y;

    adder.xout ==> xout;
    adder.yout ==> yout;
}


template BabyCheck() {
    signal input x;
    signal input y;

    signal x2;
    signal y2;

    var a = 168700;
    var d = 168696;

    x2 <== x*x;
    y2 <== y*y;

    a*x2 + y2 === 1 + d*x2*y2;
}

// Extracts the public key from private key
template BabyPbk() {
    signal input  in;
    signal output Ax;
    signal output Ay;

    var BASE8[2] = [
        5299619240641551281634865583518297030282874472190772894086521144482721001553,
        16950150798460657717958625567821834550301663161624707787222815936182638968203
    ];

    component pvkBits = Num2Bits(253);
    pvkBits.in <== in;

    component mulFix = EscalarMulFix(253, BASE8);

    var i;
    for (i=0; i<253; i++) {
        mulFix.e[i] <== pvkBits.out[i];
    }
    Ax  <== mulFix.out[0];
    Ay  <== mulFix.out[1];
}



================================================
FILE: circom/circomlib/bitify.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "comparators.circom";
include "aliascheck.circom";


template Num2Bits(n) {
    signal input in;
    signal output out[n];
    var lc1=0;

    var e2=1;
    for (var i = 0; i<n; i++) {
        out[i] <-- (in >> i) & 1;
        out[i] * (out[i] -1 ) === 0;
        lc1 += out[i] * e2;
        e2 = e2+e2;
    }

    lc1 === in;
}

template Num2Bits_strict() {
    signal input in;
    signal output out[254];

    component aliasCheck = AliasCheck();
    component n2b = Num2Bits(254);
    in ==> n2b.in;

    for (var i=0; i<254; i++) {
        n2b.out[i] ==> out[i];
        n2b.out[i] ==> aliasCheck.in[i];
    }
}

template Bits2Num(n) {
    signal input in[n];
    signal output out;
    var lc1=0;

    var e2 = 1;
    for (var i = 0; i<n; i++) {
        lc1 += in[i] * e2;
        e2 = e2 + e2;
    }

    lc1 ==> out;
}

template Bits2Num_strict() {
    signal input in[254];
    signal output out;

    component aliasCheck = AliasCheck();
    component b2n = Bits2Num(254);

    for (var i=0; i<254; i++) {
        in[i] ==> b2n.in[i];
        in[i] ==> aliasCheck.in[i];
    }

    b2n.out ==> out;
}

template Num2BitsNeg(n) {
    signal input in;
    signal output out[n];
    var lc1=0;

    component isZero;

    isZero = IsZero();

    var neg = n == 0 ? 0 : 2**n - in;

    for (var i = 0; i<n; i++) {
        out[i] <-- (neg >> i) & 1;
        out[i] * (out[i] -1 ) === 0;
        lc1 += out[i] * 2**i;
    }

    in ==> isZero.in;



    lc1 + isZero.out * 2**n === 2**n - in;
}



================================================
FILE: circom/circomlib/comparators.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

template IsZero() {
    signal input in;
    signal output out;

    signal inv;

    inv <-- in!=0 ? 1/in : 0;

    out <== -in*inv +1;
    in*out === 0;
}

template LessThan(n) {
    assert(n <= 252);
    signal input in[2];
    signal output out;

    component n2b = Num2Bits(n+1);

    n2b.in <== in[0]+ (1<<n) - in[1];

    out <== 1-n2b.out[n];
}


================================================
FILE: circom/circomlib/compconstant.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "bitify.circom";

// Returns 1 if in (in binary) > ct
template CompConstant(ct) {
    signal input in[254];
    signal output out;

    signal parts[127];
    signal sout;

    var clsb;
    var cmsb;
    var slsb;
    var smsb;

    var sum=0;

    var b = (1 << 128) -1;
    var a = 1;
    var e = 1;
    var i;

    for (i=0;i<127; i++) {
        clsb = (ct >> (i*2)) & 1;
        cmsb = (ct >> (i*2+1)) & 1;
        slsb = in[i*2];
        smsb = in[i*2+1];

        if ((cmsb==0)&&(clsb==0)) {
            parts[i] <== -b*smsb*slsb + b*smsb + b*slsb;
        } else if ((cmsb==0)&&(clsb==1)) {
            parts[i] <== a*smsb*slsb - a*slsb + b*smsb - a*smsb + a;
        } else if ((cmsb==1)&&(clsb==0)) {
            parts[i] <== b*smsb*slsb - a*smsb + a;
        } else {
            parts[i] <== -a*smsb*slsb + a;
        }

        sum = sum + parts[i];

        b = b -e;
        a = a +e;
        e = e*2;
    }

    sout <== sum;

    component num2bits = Num2Bits(135);

    num2bits.in <== sout;

    out <== num2bits.out[127];
}



================================================
FILE: circom/circomlib/escalarmulany.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "montgomery.circom";
include "babyjub.circom";
include "comparators.circom";

template Multiplexor2() {
    signal input sel;
    signal input in[2][2];
    signal output out[2];

    out[0] <== (in[1][0] - in[0][0])*sel + in[0][0];
    out[1] <== (in[1][1] - in[0][1])*sel + in[0][1];
}

template BitElementMulAny() {
    signal input sel;
    signal input dblIn[2];
    signal input addIn[2];
    signal output dblOut[2];
    signal output addOut[2];

    component doubler = MontgomeryDouble();
    component adder = MontgomeryAdd();
    component selector = Multiplexor2();


    sel ==> selector.sel;

    dblIn[0] ==> doubler.in[0];
    dblIn[1] ==> doubler.in[1];
    doubler.out[0] ==> adder.in1[0];
    doubler.out[1] ==> adder.in1[1];
    addIn[0] ==> adder.in2[0];
    addIn[1] ==> adder.in2[1];
    addIn[0] ==> selector.in[0][0];
    addIn[1] ==> selector.in[0][1];
    adder.out[0] ==> selector.in[1][0];
    adder.out[1] ==> selector.in[1][1];

    doubler.out[0] ==> dblOut[0];
    doubler.out[1] ==> dblOut[1];
    selector.out[0] ==> addOut[0];
    selector.out[1] ==> addOut[1];
}

// p is montgomery point
// n must be <= 248
// returns out in twisted edwards
// Double is in montgomery to be linked;

template SegmentMulAny(n) {
    signal input e[n];
    signal input p[2];
    signal output out[2];
    signal output dbl[2];

    component bits[n-1];

    component e2m = Edwards2Montgomery();

    p[0] ==> e2m.in[0];
    p[1] ==> e2m.in[1];

    var i;

    bits[0] = BitElementMulAny();
    e2m.out[0] ==> bits[0].dblIn[0];
    e2m.out[1] ==> bits[0].dblIn[1];
    e2m.out[0] ==> bits[0].addIn[0];
    e2m.out[1] ==> bits[0].addIn[1];
    e[1] ==> bits[0].sel;

    for (i=1; i<n-1; i++) {
        bits[i] = BitElementMulAny();

        bits[i-1].dblOut[0] ==> bits[i].dblIn[0];
        bits[i-1].dblOut[1] ==> bits[i].dblIn[1];
        bits[i-1].addOut[0] ==> bits[i].addIn[0];
        bits[i-1].addOut[1] ==> bits[i].addIn[1];
        e[i+1] ==> bits[i].sel;
    }

    bits[n-2].dblOut[0] ==> dbl[0];
    bits[n-2].dblOut[1] ==> dbl[1];

    component m2e = Montgomery2Edwards();

    bits[n-2].addOut[0] ==> m2e.in[0];
    bits[n-2].addOut[1] ==> m2e.in[1];

    component eadder = BabyAdd();

    m2e.out[0] ==> eadder.x1;
    m2e.out[1] ==> eadder.y1;
    -p[0] ==> eadder.x2;
    p[1] ==> eadder.y2;

    component lastSel = Multiplexor2();

    e[0] ==> lastSel.sel;
    eadder.xout ==> lastSel.in[0][0];
    eadder.yout ==> lastSel.in[0][1];
    m2e.out[0] ==> lastSel.in[1][0];
    m2e.out[1] ==> lastSel.in[1][1];

    lastSel.out[0] ==> out[0];
    lastSel.out[1] ==> out[1];
}

// This function assumes that p is in the subgroup and it is different to 0

template EscalarMulAny(n) {
    signal input e[n];              // Input in binary format
    signal input p[2];              // Point (Twisted format)
    signal output out[2];           // Point (Twisted format)

    var nsegments = (n-1)\148 +1;
    var nlastsegment = n - (nsegments-1)*148;

    component segments[nsegments];
    component doublers[nsegments-1];
    component m2e[nsegments-1];
    component adders[nsegments-1];
    component zeropoint = IsZero();
    zeropoint.in <== p[0];

    var s;
    var i;
    var nseg;

    for (s=0; s<nsegments; s++) {

        nseg = (s < nsegments-1) ? 148 : nlastsegment;

        segments[s] = SegmentMulAny(nseg);

        for (i=0; i<nseg; i++) {
            e[s*148+i] ==> segments[s].e[i];
        }

        if (s==0) {
            // force G8 point if input point is zero
            segments[s].p[0] <== p[0] + (5299619240641551281634865583518297030282874472190772894086521144482721001553 - p[0])*zeropoint.out;
            segments[s].p[1] <== p[1] + (16950150798460657717958625567821834550301663161624707787222815936182638968203 - p[1])*zeropoint.out;
        } else {
            doublers[s-1] = MontgomeryDouble();
            m2e[s-1] = Montgomery2Edwards();
            adders[s-1] = BabyAdd();

            segments[s-1].dbl[0] ==> doublers[s-1].in[0];
            segments[s-1].dbl[1] ==> doublers[s-1].in[1];

            doublers[s-1].out[0] ==> m2e[s-1].in[0];
            doublers[s-1].out[1] ==> m2e[s-1].in[1];

            m2e[s-1].out[0] ==> segments[s].p[0];
            m2e[s-1].out[1] ==> segments[s].p[1];

            if (s==1) {
                segments[s-1].out[0] ==> adders[s-1].x1;
                segments[s-1].out[1] ==> adders[s-1].y1;
            } else {
                adders[s-2].xout ==> adders[s-1].x1;
                adders[s-2].yout ==> adders[s-1].y1;
            }
            segments[s].out[0] ==> adders[s-1].x2;
            segments[s].out[1] ==> adders[s-1].y2;
        }
    }

    if (nsegments == 1) {
        segments[0].out[0]*(1-zeropoint.out) ==> out[0];
        segments[0].out[1]+(1-segments[0].out[1])*zeropoint.out ==> out[1];
    } else {
        adders[nsegments-2].xout*(1-zeropoint.out) ==> out[0];
        adders[nsegments-2].yout+(1-adders[nsegments-2].yout)*zeropoint.out ==> out[1];
    }
}



================================================
FILE: circom/circomlib/escalarmulfix.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "mux3.circom";
include "montgomery.circom";
include "babyjub.circom";

/*
    Window of 3 elements, it calculates
        out = base + base*in[0] + 2*base*in[1] + 4*base*in[2]
        out4 = 4*base

    The result should be compensated.
 */

/*

    The scalar is s = a0 + a1*2^3 + a2*2^6 + ...... + a81*2^243
    First We calculate Q = B + 2^3*B + 2^6*B + ......... + 2^246*B

    Then we calculate S1 = 2*2^246*B + (1 + a0)*B + (2^3 + a1)*B + .....+ (2^243 + a81)*B

    And Finaly we compute the result: RES = SQ - Q

    As you can see the input of the adders cannot be equal nor zero, except for the last
    substraction that it's done in montgomery.

    A good way to see it is that the accumulator input of the adder >= 2^247*B and the other input
    is the output of the windows that it's going to be <= 2^246*B
 */
template WindowMulFix() {
    signal input in[3];
    signal input base[2];
    signal output out[2];
    signal output out8[2];   // Returns 8*Base (To be linked)

    component mux = MultiMux3(2);

    mux.s[0] <== in[0];
    mux.s[1] <== in[1];
    mux.s[2] <== in[2];

    component dbl2 = MontgomeryDouble();
    component adr3 = MontgomeryAdd();
    component adr4 = MontgomeryAdd();
    component adr5 = MontgomeryAdd();
    component adr6 = MontgomeryAdd();
    component adr7 = MontgomeryAdd();
    component adr8 = MontgomeryAdd();

// in[0]  -> 1*BASE

    mux.c[0][0] <== base[0];
    mux.c[1][0] <== base[1];

// in[1] -> 2*BASE
    dbl2.in[0] <== base[0];
    dbl2.in[1] <== base[1];
    mux.c[0][1] <== dbl2.out[0];
    mux.c[1][1] <== dbl2.out[1];

// in[2] -> 3*BASE
    adr3.in1[0] <== base[0];
    adr3.in1[1] <== base[1];
    adr3.in2[0] <== dbl2.out[0];
    adr3.in2[1] <== dbl2.out[1];
    mux.c[0][2] <== adr3.out[0];
    mux.c[1][2] <== adr3.out[1];

// in[3] -> 4*BASE
    adr4.in1[0] <== base[0];
    adr4.in1[1] <== base[1];
    adr4.in2[0] <== adr3.out[0];
    adr4.in2[1] <== adr3.out[1];
    mux.c[0][3] <== adr4.out[0];
    mux.c[1][3] <== adr4.out[1];

// in[4] -> 5*BASE
    adr5.in1[0] <== base[0];
    adr5.in1[1] <== base[1];
    adr5.in2[0] <== adr4.out[0];
    adr5.in2[1] <== adr4.out[1];
    mux.c[0][4] <== adr5.out[0];
    mux.c[1][4] <== adr5.out[1];

// in[5] -> 6*BASE
    adr6.in1[0] <== base[0];
    adr6.in1[1] <== base[1];
    adr6.in2[0] <== adr5.out[0];
    adr6.in2[1] <== adr5.out[1];
    mux.c[0][5] <== adr6.out[0];
    mux.c[1][5] <== adr6.out[1];

// in[6] -> 7*BASE
    adr7.in1[0] <== base[0];
    adr7.in1[1] <== base[1];
    adr7.in2[0] <== adr6.out[0];
    adr7.in2[1] <== adr6.out[1];
    mux.c[0][6] <== adr7.out[0];
    mux.c[1][6] <== adr7.out[1];

// in[7] -> 8*BASE
    adr8.in1[0] <== base[0];
    adr8.in1[1] <== base[1];
    adr8.in2[0] <== adr7.out[0];
    adr8.in2[1] <== adr7.out[1];
    mux.c[0][7] <== adr8.out[0];
    mux.c[1][7] <== adr8.out[1];

    out8[0] <== adr8.out[0];
    out8[1] <== adr8.out[1];

    out[0] <== mux.out[0];
    out[1] <== mux.out[1];
}


/*
    This component does a multiplication of a escalar times a fix base
    Signals:
        e: The scalar in bits
        base: the base point in edwards format
        out:  The result
        dbl: Point in Edwards to be linked to the next segment.
 */

template SegmentMulFix(nWindows) {
    signal input e[nWindows*3];
    signal input base[2];
    signal output out[2];
    signal output dbl[2];

    var i;
    var j;

    // Convert the base to montgomery

    component e2m = Edwards2Montgomery();
    e2m.in[0] <== base[0];
    e2m.in[1] <== base[1];

    component windows[nWindows];
    component adders[nWindows];
    component cadders[nWindows];

    // In the last step we add an extra doubler so that numbers do not match.
    component dblLast = MontgomeryDouble();

    for (i=0; i<nWindows; i++) {
        windows[i] = WindowMulFix();
        cadders[i] = MontgomeryAdd();
        if (i==0) {
            windows[i].base[0] <== e2m.out[0];
            windows[i].base[1] <== e2m.out[1];
            cadders[i].in1[0] <== e2m.out[0];
            cadders[i].in1[1] <== e2m.out[1];
        } else {
            windows[i].base[0] <== windows[i-1].out8[0];
            windows[i].base[1] <== windows[i-1].out8[1];
            cadders[i].in1[0] <== cadders[i-1].out[0];
            cadders[i].in1[1] <== cadders[i-1].out[1];
        }
        for (j=0; j<3; j++) {
            windows[i].in[j] <== e[3*i+j];
        }
        if (i<nWindows-1) {
            cadders[i].in2[0] <== windows[i].out8[0];
            cadders[i].in2[1] <== windows[i].out8[1];
        } else {
            dblLast.in[0] <== windows[i].out8[0];
            dblLast.in[1] <== windows[i].out8[1];
            cadders[i].in2[0] <== dblLast.out[0];
            cadders[i].in2[1] <== dblLast.out[1];
        }
    }

    for (i=0; i<nWindows; i++) {
        adders[i] = MontgomeryAdd();
        if (i==0) {
            adders[i].in1[0] <== dblLast.out[0];
            adders[i].in1[1] <== dblLast.out[1];
        } else {
            adders[i].in1[0] <== adders[i-1].out[0];
            adders[i].in1[1] <== adders[i-1].out[1];
        }
        adders[i].in2[0] <== windows[i].out[0];
        adders[i].in2[1] <== windows[i].out[1];
    }

    component m2e = Montgomery2Edwards();
    component cm2e = Montgomery2Edwards();

    m2e.in[0] <== adders[nWindows-1].out[0];
    m2e.in[1] <== adders[nWindows-1].out[1];
    cm2e.in[0] <== cadders[nWindows-1].out[0];
    cm2e.in[1] <== cadders[nWindows-1].out[1];

    component cAdd = BabyAdd();
    cAdd.x1 <== m2e.out[0];
    cAdd.y1 <== m2e.out[1];
    cAdd.x2 <== -cm2e.out[0];
    cAdd.y2 <== cm2e.out[1];

    cAdd.xout ==> out[0];
    cAdd.yout ==> out[1];

    windows[nWindows-1].out8[0] ==> dbl[0];
    windows[nWindows-1].out8[1] ==> dbl[1];
}


/*
This component multiplies a escalar times a fixed point BASE (twisted edwards format)
    Signals
        e: The escalar in binary format
        out: The output point in twisted edwards
 */
template EscalarMulFix(n, BASE) {
    signal input e[n];              // Input in binary format
    signal output out[2];           // Point (Twisted format)

    var nsegments = (n-1)\246 +1;       // 249 probably would work. But I'm not sure and for security I keep 246
    var nlastsegment = n - (nsegments-1)*249;

    component segments[nsegments];

    component m2e[nsegments-1];
    component adders[nsegments-1];

    var s;
    var i;
    var nseg;
    var nWindows;

    for (s=0; s<nsegments; s++) {

        nseg = (s < nsegments-1) ? 249 : nlastsegment;
        nWindows = ((nseg - 1)\3)+1;

        segments[s] = SegmentMulFix(nWindows);

        for (i=0; i<nseg; i++) {
            segments[s].e[i] <== e[s*249+i];
        }

        for (i = nseg; i<nWindows*3; i++) {
            segments[s].e[i] <== 0;
        }

        if (s==0) {
            segments[s].base[0] <== BASE[0];
            segments[s].base[1] <== BASE[1];
        } else {
            m2e[s-1] = Montgomery2Edwards();
            adders[s-1] = BabyAdd();

            segments[s-1].dbl[0] ==> m2e[s-1].in[0];
            segments[s-1].dbl[1] ==> m2e[s-1].in[1];

            m2e[s-1].out[0] ==> segments[s].base[0];
            m2e[s-1].out[1] ==> segments[s].base[1];

            if (s==1) {
                segments[s-1].out[0] ==> adders[s-1].x1;
                segments[s-1].out[1] ==> adders[s-1].y1;
            } else {
                adders[s-2].xout ==> adders[s-1].x1;
                adders[s-2].yout ==> adders[s-1].y1;
            }
            segments[s].out[0] ==> adders[s-1].x2;
            segments[s].out[1] ==> adders[s-1].y2;
        }
    }

    if (nsegments == 1) {
        segments[0].out[0] ==> out[0];
        segments[0].out[1] ==> out[1];
    } else {
        adders[nsegments-2].xout ==> out[0];
        adders[nsegments-2].yout ==> out[1];
    }
}



================================================
FILE: circom/circomlib/montgomery.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/

/*
    Source: https://en.wikipedia.org/wiki/Montgomery_curve

                1 + y       1 + y
    [u, v] = [ -------  , ---------- ]
                1 - y      (1 - y)x

 */
 pragma circom 2.1.9;

template Edwards2Montgomery() {
    signal input in[2];
    signal output out[2];

    out[0] <-- (1 + in[1]) / (1 - in[1]);
    out[1] <-- out[0] / in[0];


    out[0] * (1-in[1]) === (1 + in[1]);
    out[1] * in[0] === out[0];
}

/*

                u    u - 1
    [x, y] = [ ---, ------- ]
                v    u + 1

 */
template Montgomery2Edwards() {
    signal input in[2];
    signal output out[2];

    out[0] <-- in[0] / in[1];
    out[1] <-- (in[0] - 1) / (in[0] + 1);

    out[0] * in[1] === in[0];
    out[1] * (in[0] + 1) === in[0] - 1;
}


/*
             x2 - x1
    lamda = ---------
             y2 - y1

                                                    x3 + A + x1 + x2
    x3 = B * lamda^2 - A - x1 -x2    =>  lamda^2 = ------------------
                                                         B

    y3 = (2*x1 + x2 + A)*lamda - B*lamda^3 - y1  =>


    =>  y3 = lamda * ( 2*x1 + x2 + A  - x3 - A - x1 - x2)  - y1 =>

    =>  y3 = lamda * ( x1 - x3 ) - y1

----------

             y2 - y1
    lamda = ---------
             x2 - x1

    x3 = B * lamda^2 - A - x1 -x2

    y3 = lamda * ( x1 - x3 ) - y1

 */

template MontgomeryAdd() {
    signal input in1[2];
    signal input in2[2];
    signal output out[2];

    var a = 168700;
    var d = 168696;

    var A = (2 * (a + d)) / (a - d);
    var B = 4 / (a - d);

    signal lamda;

    lamda <-- (in2[1] - in1[1]) / (in2[0] - in1[0]);
    lamda * (in2[0] - in1[0]) === (in2[1] - in1[1]);

    out[0] <== B*lamda*lamda - A - in1[0] -in2[0];
    out[1] <== lamda * (in1[0] - out[0]) - in1[1];
}

/*

    x1_2 = x1*x1

             3*x1_2 + 2*A*x1 + 1
    lamda = ---------------------
                   2*B*y1

    x3 = B * lamda^2 - A - x1 -x1

    y3 = lamda * ( x1 - x3 ) - y1

 */
template MontgomeryDouble() {
    signal input in[2];
    signal output out[2];

    var a = 168700;
    var d = 168696;

    var A = (2 * (a + d)) / (a - d);
    var B = 4 / (a - d);

    signal lamda;
    signal x1_2;

    x1_2 <== in[0] * in[0];

    lamda <-- (3*x1_2 + 2*A*in[0] + 1 ) / (2*B*in[1]);
    lamda * (2*B*in[1]) === (3*x1_2 + 2*A*in[0] + 1 );

    out[0] <== B*lamda*lamda - A - 2*in[0];
    out[1] <== lamda * (in[0] - out[0]) - in[1];
}



================================================
FILE: circom/circomlib/mux3.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

template MultiMux3(n) {
    signal input c[n][8];  // Constants
    signal input s[3];   // Selector
    signal output out[n];

    signal a210[n];
    signal a21[n];
    signal a20[n];
    signal a2[n];

    signal a10[n];
    signal a1[n];
    signal a0[n];
    signal a[n];

    // 4 constrains for the intermediary variables
    signal  s10;
    s10 <== s[1] * s[0];

    for (var i=0; i<n; i++) {

         a210[i] <==  ( c[i][ 7]-c[i][ 6]-c[i][ 5]+c[i][ 4] - c[i][ 3]+c[i][ 2]+c[i][ 1]-c[i][ 0] ) * s10;
          a21[i] <==  ( c[i][ 6]-c[i][ 4]-c[i][ 2]+c[i][ 0] ) * s[1];
          a20[i] <==  ( c[i][ 5]-c[i][ 4]-c[i][ 1]+c[i][ 0] ) * s[0];
           a2[i] <==  ( c[i][ 4]-c[i][ 0] );

          a10[i] <==  ( c[i][ 3]-c[i][ 2]-c[i][ 1]+c[i][ 0] ) * s10;
           a1[i] <==  ( c[i][ 2]-c[i][ 0] ) * s[1];
           a0[i] <==  ( c[i][ 1]-c[i][ 0] ) * s[0];
            a[i] <==  ( c[i][ 0] );

          out[i] <== ( a210[i] + a21[i] + a20[i] + a2[i] ) * s[2] +
                     (  a10[i] +  a1[i] +  a0[i] +  a[i] );

    }
}



================================================
FILE: circom/circomlib/poseidon.circom
================================================
pragma circom 2.1.9;

include "./poseidon_constants.circom";

template Sigma() {
    signal input in;
    signal output out;

    signal in2;
    signal in4;

    in2 <== in*in;
    in4 <== in2*in2;

    out <== in4*in;
}

template Ark(t, C, r) {
    signal input in[t];
    signal output out[t];

    for (var i=0; i<t; i++) {
        out[i] <== in[i] + C[i + r];
    }
}

template Mix(t, M) {
    signal input in[t];
    signal output out[t];

    var lc;
    for (var i=0; i<t; i++) {
        lc = 0;
        for (var j=0; j<t; j++) {
            lc += M[j][i]*in[j];
        }
        out[i] <== lc;
    }
}

template MixLast(t, M, s) {
    signal input in[t];
    signal output out;

    var lc = 0;
    for (var j=0; j<t; j++) {
        lc += M[j][s]*in[j];
    }
    out <== lc;
}

template MixS(t, S, r) {
    signal input in[t];
    signal output out[t];


    var lc = 0;
    for (var i=0; i<t; i++) {
        lc += S[(t*2-1)*r+i]*in[i];
    }
    out[0] <== lc;
    for (var i=1; i<t; i++) {
        out[i] <== in[i] +  in[0] * S[(t*2-1)*r + t + i -1];
    }
}

template PoseidonEx(nInputs, nOuts) {
    signal input inputs[nInputs];
    signal input initialState;
    signal output out[nOuts];

    // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
    // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    // And rounded up to nearest integer that divides by t
    var N_ROUNDS_P[16] = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
    var t = nInputs + 1;
    var nRoundsF = 8;
    var nRoundsP = N_ROUNDS_P[t - 2];
    var C[t*nRoundsF + nRoundsP] = POSEIDON_C(t);
    var S[  N_ROUNDS_P[t-2]  *  (t*2-1)  ]  = POSEIDON_S(t);
    var M[t][t] = POSEIDON_M(t);
    var P[t][t] = POSEIDON_P(t);

    component ark[nRoundsF];
    component sigmaF[nRoundsF][t];
    component sigmaP[nRoundsP];
    component mix[nRoundsF-1];
    component mixS[nRoundsP];
    component mixLast[nOuts];


    ark[0] = Ark(t, C, 0);
    for (var j=0; j<t; j++) {
        if (j>0) {
            ark[0].in[j] <== inputs[j-1];
        } else {
            ark[0].in[j] <== initialState;
        }
    }

    for (var r = 0; r < nRoundsF\2-1; r++) {
        for (var j=0; j<t; j++) {
            sigmaF[r][j] = Sigma();
            if(r==0) {
                sigmaF[r][j].in <== ark[0].out[j];
            } else {
                sigmaF[r][j].in <== mix[r-1].out[j];
            }
        }

        ark[r+1] = Ark(t, C, (r+1)*t);
        for (var j=0; j<t; j++) {
            ark[r+1].in[j] <== sigmaF[r][j].out;
        }

        mix[r] = Mix(t,M);
        for (var j=0; j<t; j++) {
            mix[r].in[j] <== ark[r+1].out[j];
        }

    }

    for (var j=0; j<t; j++) {
        sigmaF[nRoundsF\2-1][j] = Sigma();
        sigmaF[nRoundsF\2-1][j].in <== mix[nRoundsF\2-2].out[j];
    }

    ark[nRoundsF\2] = Ark(t, C, (nRoundsF\2)*t );
    for (var j=0; j<t; j++) {
        ark[nRoundsF\2].in[j] <== sigmaF[nRoundsF\2-1][j].out;
    }

    mix[nRoundsF\2-1] = Mix(t,P);
    for (var j=0; j<t; j++) {
        mix[nRoundsF\2-1].in[j] <== ark[nRoundsF\2].out[j];
    }


    for (var r = 0; r < nRoundsP; r++) {
        sigmaP[r] = Sigma();
        if (r==0) {
            sigmaP[r].in <== mix[nRoundsF\2-1].out[0];
        } else {
            sigmaP[r].in <== mixS[r-1].out[0];
        }

        mixS[r] = MixS(t, S, r);
        for (var j=0; j<t; j++) {
            if (j==0) {
                mixS[r].in[j] <== sigmaP[r].out + C[(nRoundsF\2+1)*t + r];
            } else {
                if (r==0) {
                    mixS[r].in[j] <== mix[nRoundsF\2-1].out[j];
                } else {
                    mixS[r].in[j] <== mixS[r-1].out[j];
                }
            }
        }
    }

    for (var r = 0; r < nRoundsF\2-1; r++) {
        for (var j=0; j<t; j++) {
            sigmaF[nRoundsF\2 + r][j] = Sigma();
            if (r==0) {
                sigmaF[nRoundsF\2 + r][j].in <== mixS[nRoundsP-1].out[j];
            } else {
                sigmaF[nRoundsF\2 + r][j].in <== mix[nRoundsF\2+r-1].out[j];
            }
        }

        ark[ nRoundsF\2 + r + 1] = Ark(t, C,  (nRoundsF\2+1)*t + nRoundsP + r*t );
        for (var j=0; j<t; j++) {
            ark[nRoundsF\2 + r + 1].in[j] <== sigmaF[nRoundsF\2 + r][j].out;
        }

        mix[nRoundsF\2 + r] = Mix(t,M);
        for (var j=0; j<t; j++) {
            mix[nRoundsF\2 + r].in[j] <== ark[nRoundsF\2 + r + 1].out[j];
        }

    }

    for (var j=0; j<t; j++) {
        sigmaF[nRoundsF-1][j] = Sigma();
        sigmaF[nRoundsF-1][j].in <== mix[nRoundsF-2].out[j];
    }

    for (var i=0; i<nOuts; i++) {
        mixLast[i] = MixLast(t,M,i);
        for (var j=0; j<t; j++) {
            mixLast[i].in[j] <== sigmaF[nRoundsF-1][j].out;
        }
        out[i] <== mixLast[i].out;
    }

}

template Poseidon(nInputs) {
    signal input inputs[nInputs];
    signal output out;

    component pEx = PoseidonEx(nInputs, 1);
    pEx.initialState <== 0;
    for (var i=0; i<nInputs; i++) {
        pEx.inputs[i] <== inputs[i];
    }
    out <== pEx.out[0];
}



================================================
FILE: circom/circomlib/poseidon_old.circom
================================================
pragma circom 2.1.9;

include "./poseidon_constants.circom";

template Sigma() {
    signal input in;
    signal output out;

    signal in2;
    signal in4;

    in2 <== in*in;
    in4 <== in2*in2;

    out <== in4*in;
}

template Ark(t, C, r) {
    signal input in[t];
    signal output out[t];

    for (var i=0; i<t; i++) {
        out[i] <== in[i] + C[i + r];
    }
}

template Mix(t, M) {
    signal input in[t];
    signal output out[t];

    var lc;
    for (var i=0; i<t; i++) {
        lc = 0;
        for (var j=0; j<t; j++) {
            lc += M[i][j]*in[j];
        }
        out[i] <== lc;
    }
}

template Poseidon(nInputs) {
    signal input inputs[nInputs];
    signal output out;

    // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
    // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    // And rounded up to nearest integer that divides by t
    var N_ROUNDS_P[16] = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
    var t = nInputs + 1;
    var nRoundsF = 8;
    var nRoundsP = N_ROUNDS_P[t - 2];
    var C[t*(nRoundsF + nRoundsP)] = POSEIDON_C(t);
    var M[t][t] = POSEIDON_M(t);

    component ark[nRoundsF + nRoundsP];
    component sigmaF[nRoundsF][t];
    component sigmaP[nRoundsP];
    component mix[nRoundsF + nRoundsP];

    var k;

    for (var i=0; i<nRoundsF + nRoundsP; i++) {
        ark[i] = Ark(t, C, t*i);
        for (var j=0; j<t; j++) {
            if (i==0) {
                if (j>0) {
                    ark[i].in[j] <== inputs[j-1];
                } else {
                    ark[i].in[j] <== 0;
                }
            } else {
                ark[i].in[j] <== mix[i-1].out[j];
            }
        }

        if (i < nRoundsF/2 || i >= nRoundsP + nRoundsF/2) {
            k = i < nRoundsF/2 ? i : i - nRoundsP;
            mix[i] = Mix(t, M);
            for (var j=0; j<t; j++) {
                sigmaF[k][j] = Sigma();
                sigmaF[k][j].in <== ark[i].out[j];
                mix[i].in[j] <== sigmaF[k][j].out;
            }
        } else {
            k = i - nRoundsF/2;
            mix[i] = Mix(t, M);
            sigmaP[k] = Sigma();
            sigmaP[k].in <== ark[i].out[0];
            mix[i].in[0] <== sigmaP[k].out;
            for (var j=1; j<t; j++) {
                mix[i].in[j] <== ark[i].out[j];
            }
        }
    }

    out <== mix[nRoundsF + nRoundsP -1].out[0];
}



================================================
FILE: contracts/EncryptedERC.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem
pragma solidity 0.8.27;

// contracts
import {TokenTracker} from "./tokens/TokenTracker.sol";
import {EncryptedUserBalances} from "./EncryptedUserBalances.sol";
import {AuditorManager} from "./auditor/AuditorManager.sol";
import {EncryptedMetadata} from "./metadata/EncryptedMetadata.sol";

// libraries
import {BabyJubJub} from "./libraries/BabyJubJub.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

// types
import {CreateEncryptedERCParams, Point, EGCT, EncryptedBalance, AmountPCT, MintProof, TransferProof, WithdrawProof, BurnProof, TransferInputs} from "./types/Types.sol";

// errors
import {UserNotRegistered, InvalidProof, TransferFailed, UnknownToken, InvalidChainId, InvalidNullifier, ZeroAddress} from "./errors/Errors.sol";

// interfaces
import {IRegistrar} from "./interfaces/IRegistrar.sol";
import {IMintVerifier} from "./interfaces/verifiers/IMintVerifier.sol";
import {IWithdrawVerifier} from "./interfaces/verifiers/IWithdrawVerifier.sol";
import {ITransferVerifier} from "./interfaces/verifiers/ITransferVerifier.sol";
import {IBurnVerifier} from "./interfaces/verifiers/IBurnVerifier.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

//             /$$$$$$$$ /$$$$$$$   /$$$$$$
//            | $$_____/| $$__  $$ /$$__  $$
//    /$$$$$$ | $$      | $$  \ $$| $$  \__/
//   /$$__  $$| $$$$$   | $$$$$$$/| $$  | $$
//  | $$_____/| $$      | $$  \ $$| $$  | $$
//  |  $$$$$$$| $$$$$$$$| $$  | $$|  $$$$$$/
//   \_______/|________/|__/  |__/ \______/
//
/**
 * @title EncryptedERC
 * @notice A privacy-preserving ERC20 token implementation that uses zero-knowledge proofs for managing balances in encrypted manner.
 * @dev This contract implements Encrypted ERC operations using zero-knowledge proofs.
 *
 * Key features:
 * - Encrypted ERC has 2 modes:
 *   - Standalone Mode: Act like a standalone ERC20 token (mint, burn, transfer)
 *   - Converter Mode: Wraps existing ERC20 tokens and encrypted ERC20 tokens (deposit, withdraw, transfer)
 * - Auditor Manager: Manages auditor's public key
 * - Token Tracker: Manages ERC20 token registration for deposit and withdrawal
 * - Encrypted User Balances: Manages encrypted balances for users in encrypted manner
 *
 * The contract uses three main components:
 * 1. TokenTracker: Manages token registration and tracking
 * 2. EncryptedUserBalances: Handles encrypted balance storage and updates
 * 3. AuditorManager: Manages auditor-related functionality
 */
contract EncryptedERC is
    TokenTracker,
    EncryptedUserBalances,
    AuditorManager,
    EncryptedMetadata
{
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice Address of the registrar contract that manages user registration
    IRegistrar public registrar;

    /// @notice Verifier contracts for each operation
    IMintVerifier public mintVerifier;
    IWithdrawVerifier public withdrawVerifier;
    ITransferVerifier public transferVerifier;
    IBurnVerifier public burnVerifier;

    /// @notice Token metadata
    string public name;
    string public symbol;
    uint8 public immutable decimals;

    /// @notice Mapping to track used mint nullifiers to prevent double-minting
    mapping(uint256 mintNullifier => bool isUsed) public alreadyMinted;

    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when a private mint operation occurs
     * @param user Address of the user receiving the minted tokens
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when tokens are privately minted to a user
     */
    event PrivateMint(
        address indexed user,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    /**
     * @notice Emitted when a private burn operation occurs
     * @param user Address of the user burning the tokens
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when tokens are privately burned by a user
     */
    event PrivateBurn(
        address indexed user,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    /**
     * @notice Emitted when a private transfer operation occurs
     * @param from Address of the sender
     * @param to Address of the receiver
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when tokens are privately transferred between users
     */
    event PrivateTransfer(
        address indexed from,
        address indexed to,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    /**
     * @notice Emitted when a deposit operation occurs
     * @param user Address of the user making the deposit
     * @param amount Amount of tokens deposited
     * @param dust Amount of dust (remainder) from the deposit
     * @param tokenId ID of the token being deposited
     * @dev This event is emitted when a user deposits tokens into the contract
     */
    event Deposit(
        address indexed user,
        uint256 amount,
        uint256 dust,
        uint256 tokenId
    );

    /**
     * @notice Emitted when a withdrawal operation occurs
     * @param user Address of the user making the withdrawal
     * @param amount Amount of tokens withdrawn
     * @param tokenId ID of the token being withdrawn
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when a user withdraws tokens from the contract
     */
    event Withdraw(
        address indexed user,
        uint256 amount,
        uint256 tokenId,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    ///////////////////////////////////////////////////
    ///                   Modifiers                 ///
    ///////////////////////////////////////////////////
    modifier onlyIfUserRegistered(address user) {
        bool isRegistered = registrar.isUserRegistered(user);
        if (!isRegistered) {
            revert UserNotRegistered();
        }
        _;
    }

    ///////////////////////////////////////////////////
    ///                   Constructor               ///
    ///////////////////////////////////////////////////

    /**
     * @notice Initializes the EncryptedERC contract with the given parameters
     * @param params The initialization parameters containing contract addresses and token metadata
     * @dev This constructor sets up the contract with necessary verifiers, registrar, and token metadata.
     *      It also determines whether the contract will function as a converter or standalone token.
     */
    constructor(
        CreateEncryptedERCParams memory params
    ) TokenTracker(params.isConverter) {
        // Validate contract addresses
        if (
            params.registrar == address(0) ||
            params.mintVerifier == address(0) ||
            params.withdrawVerifier == address(0) ||
            params.transferVerifier == address(0) ||
            params.burnVerifier == address(0)
        ) {
            revert ZeroAddress();
        }

        // Initialize contracts
        registrar = IRegistrar(params.registrar);
        mintVerifier = IMintVerifier(params.mintVerifier);
        withdrawVerifier = IWithdrawVerifier(params.withdrawVerifier);
        transferVerifier = ITransferVerifier(params.transferVerifier);
        burnVerifier = IBurnVerifier(params.burnVerifier);

        // if contract is not a converter, then set the name and symbol
        if (!params.isConverter) {
            name = params.name;
            symbol = params.symbol;
        }

        decimals = params.decimals;
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Sets the auditor's public key for a registered user
     * @param user Address of the user to set as auditor
     * @dev This function:
     *      1. Verifies the user is registered
     *      2. Retrieves the user's public key
     *      3. Updates the auditor's information
     *
     * Requirements:
     * - Caller must be the contract owner
     * - User must be registered
     */
    function setAuditorPublicKey(
        address user
    ) external onlyOwner onlyIfUserRegistered(user) {
        uint256[2] memory publicKey_ = registrar.getUserPublicKey(user);
        _updateAuditor(user, publicKey_);
    }

    /**
     * @notice Performs a private mint operation for a registered user
     * @param user The address of the user to mint tokens to
     * @param proof The zero-knowledge proof proving the validity of the mint operation
     * @dev This function:
     *      1. Validates the chain ID and user registration
     *      2. Verifies the user's public key matches the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Checks the mint nullifier hasn't been used
     *      5. Verifies the zero-knowledge proof
     *      6. Updates the user's encrypted balance
     *
     * Requirements:
     * - Caller must be the contract owner
     * - Auditor must be set
     * - Contract must be in standalone mode
     * - User must be registered
     * - Proof must be valid
     */
    function privateMint(
        address user,
        MintProof calldata proof
    )
        external
        onlyOwner
        onlyIfAuditorSet
        onlyForStandalone
        onlyIfUserRegistered(user)
    {
        // executes the private mint operation
        _executePrivateMint(user, proof, bytes(""));
    }

    /**
     * @notice Performs a private mint operation for a registered user with additional metadata
     * @param user The address of the user to mint tokens to
     * @param proof The zero-knowledge proof proving the validity of the mint operation
     * @param message Additional metadata message to be emitted with the mint event
     * @dev This function:
     *      1. Validates the chain ID and user registration
     *      2. Verifies the user's public key matches the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Checks the mint nullifier hasn't been used
     *      5. Verifies the zero-knowledge proof
     *      6. Updates the user's encrypted balance
     *      7. Emits the mint event with the provided message
     *
     * Requirements:
     * - Caller must be the contract owner
     * - Auditor must be set
     * - Contract must be in standalone mode
     * - User must be registered
     * - Proof must be valid
     */
    function privateMint(
        address user,
        MintProof calldata proof,
        bytes calldata message
    )
        external
        onlyOwner
        onlyIfAuditorSet
        onlyForStandalone
        onlyIfUserRegistered(user)
    {
        // executes the private mint operation with message
        _executePrivateMint(user, proof, message);
    }

    /**
     * @notice Performs a private burn operation
     * @param proof The transfer proof proving the validity of the burn operation
     * @param balancePCT The balance PCT for the sender after the burn
     * @dev This function:
     *      1. Validates the sender is registered
     *      2. Verifies the sender's public key matches the proof
     *      3. Verifies the burn address's public key matches the proof
     *      4. Verifies the auditor's public key matches the proof
     *      5. Verifies the zero-knowledge proof
     *      6. Transfers the encrypted amount to the burn address
     *
     * Requirements:
     * - Auditor must be set
     * - Contract must be in standalone mode
     * - Sender must be registered
     * - Proof must be valid
     */
    function privateBurn(
        BurnProof calldata proof,
        uint256[7] calldata balancePCT
    )
        external
        onlyIfAuditorSet
        onlyForStandalone
        onlyIfUserRegistered(msg.sender)
    {
        _executePrivateBurn(proof, balancePCT, bytes(""));
    }

    /**
     * @notice Performs a private burn operation with additional metadata
     * @param user The address of the user to burn tokens from
     * @param proof The zero-knowledge proof proving the validity of the burn operation
     * @param balancePCT The balance PCT for the user after the burn
     * @param message Additional metadata message to be emitted with the burn event
     */
    function privateBurn(
        address user,
        BurnProof calldata proof,
        uint256[7] calldata balancePCT,
        bytes calldata message
    ) external onlyIfAuditorSet onlyForStandalone onlyIfUserRegistered(user) {
        _executePrivateBurn(proof, balancePCT, message);
    }

    /**
     * @notice Performs a private transfer between two users
     * @param to Address of the receiver
     * @param tokenId ID of the token to transfer
     * @param proof The transfer proof proving the validity of the transfer
     * @param balancePCT The balance PCT for the sender after the transfer
     * @dev This function:
     *      1. Validates both sender and receiver are registered
     *      2. Verifies both public keys match the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Verifies the zero-knowledge proof
     *      5. Updates both users' encrypted balances
     *
     * Requirements:
     * - Auditor must be set
     * - Both sender and receiver must be registered
     * - Proof must be valid
     */
    function transfer(
        address to,
        uint256 tokenId,
        TransferProof memory proof,
        uint256[7] calldata balancePCT
    )
        external
        onlyIfAuditorSet
        onlyIfUserRegistered(msg.sender)
        onlyIfUserRegistered(to)
    {
        _executePrivateTransfer(to, tokenId, proof, balancePCT, bytes(""));
    }

    /**
     * @notice Performs a private transfer between two users with additional metadata
     * @param to Address of the receiver
     * @param tokenId ID of the token to transfer
     * @param proof The transfer proof proving the validity of the transfer
     * @param balancePCT The balance PCT for the sender after the transfer
     * @param message Additional metadata message to be emitted with the transfer event
     */
    function transfer(
        address to,
        uint256 tokenId,
        TransferProof memory proof,
        uint256[7] calldata balancePCT,
        bytes calldata message
    )
        external
        onlyIfAuditorSet
        onlyIfUserRegistered(msg.sender)
        onlyIfUserRegistered(to)
    {
        _executePrivateTransfer(to, tokenId, proof, balancePCT, message);
    }

    /**
     * @notice Deposits an existing ERC20 token into the contract
     * @param amount Amount of tokens to deposit
     * @param tokenAddress Address of the token to deposit
     * @param amountPCT Amount PCT for the deposit
     * @dev This function:
     *      1. Validates the user is registered
     *      2. Transfers the tokens from the user to the contract
     *      3. Converts the tokens to encrypted tokens
     *      4. Adds the encrypted amount to the user's balance
     *      5. Returns any dust (remainder) to the user
     *
     * Requirements:
     * - Auditor must be set
     * - Contract must be in converter mode
     * - Token must not be blacklisted
     * - User must be registered
     */
    function deposit(
        uint256 amount,
        address tokenAddress,
        uint256[7] memory amountPCT
    )
        external
        onlyIfAuditorSet
        onlyForConverter
        revertIfBlacklisted(tokenAddress)
        onlyIfUserRegistered(msg.sender)
    {
        _executeDeposit(amount, tokenAddress, amountPCT, bytes(""));
    }

    /**
     * @notice Deposits an existing ERC20 token into the contract with additional metadata
     * @param amount Amount of tokens to deposit
     * @param tokenAddress Address of the token to deposit
     * @param amountPCT Amount PCT for the deposit
     * @param message Additional metadata message to be emitted with the deposit event
     */
    function deposit(
        uint256 amount,
        address tokenAddress,
        uint256[7] memory amountPCT,
        bytes calldata message
    )
        external
        onlyIfAuditorSet
        onlyForConverter
        revertIfBlacklisted(tokenAddress)
        onlyIfUserRegistered(msg.sender)
    {
        _executeDeposit(amount, tokenAddress, amountPCT, message);
    }

    /**
     * @notice Withdraws encrypted tokens as regular ERC20 tokens
     * @param tokenId ID of the token to withdraw
     * @param proof The withdraw proof proving the validity of the withdrawal
     * @param balancePCT The balance PCT for the user after the withdrawal
     * @dev This function:
     *      1. Validates the user is registered
     *      2. Verifies the user's public key matches the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Verifies the zero-knowledge proof
     *      5. Subtracts the encrypted amount from the user's balance
     *      6. Converts the tokens to regular ERC20 tokens
     *
     * Requirements:
     * - Auditor must be set
     * - Contract must be in converter mode
     * - User must be registered
     * - Proof must be valid
     */
    function withdraw(
        uint256 tokenId,
        WithdrawProof memory proof,
        uint256[7] memory balancePCT
    )
        external
        onlyIfAuditorSet
        onlyForConverter
        onlyIfUserRegistered(msg.sender)
    {
        _executeWithdraw(tokenId, proof, balancePCT, bytes(""));
    }

    /**
     * @notice Withdraws encrypted tokens as regular ERC20 tokens with additional metadata
     * @param tokenId ID of the token to withdraw
     * @param proof The withdraw proof proving the validity of the withdrawal
     * @param balancePCT The balance PCT for the user after the withdrawal
     * @param message Additional metadata message to be emitted with the withdrawal event
     */
    function withdraw(
        uint256 tokenId,
        WithdrawProof memory proof,
        uint256[7] memory balancePCT,
        bytes calldata message
    )
        external
        onlyIfAuditorSet
        onlyForConverter
        onlyIfUserRegistered(msg.sender)
    {
        _executeWithdraw(tokenId, proof, balancePCT, message);
    }

    function sendEncryptedMetadata(
        address to,
        bytes calldata message
    ) external onlyIfUserRegistered(msg.sender) onlyIfUserRegistered(to) {
        _sendEncryptedMetadata(to, message);
    }

    /**
     * @notice Gets the encrypted balance for a token address
     * @param user Address of the user
     * @param tokenAddress Address of the token
     * @return eGCT The ElGamal ciphertext representing the encrypted balance
     * @return nonce The current nonce used for balance validation
     * @return amountPCTs Array of amount PCTs for transaction history
     * @return balancePCT The current balance PCT
     * @return transactionIndex The current transaction index
     * @dev This is a convenience function that looks up the token ID and calls balanceOf
     */
    function getBalanceFromTokenAddress(
        address user,
        address tokenAddress
    )
        public
        view
        returns (
            EGCT memory eGCT,
            uint256 nonce,
            AmountPCT[] memory amountPCTs,
            uint256[7] memory balancePCT,
            uint256 transactionIndex
        )
    {
        uint256 tokenId = tokenIds[tokenAddress];
        return balanceOf(user, tokenId);
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Performs the internal logic for a private withdrawal
     * @param from Address of the user withdrawing tokens
     * @param amount Amount of tokens to withdraw
     * @param tokenId ID of the token to withdraw
     * @param publicInputs Public inputs from the proof
     * @param balancePCT The balance PCT for the user after the withdrawal
     * @dev This function:
     *      1. Validates the token exists
     *      2. Verifies the provided balance is valid
     *      3. Subtracts the encrypted amount from the user's balance
     *      4. Converts the tokens to regular ERC20 tokens
     */
    function _withdraw(
        address from,
        uint256 amount,
        uint256 tokenId,
        uint256[16] memory publicInputs,
        uint256[7] memory balancePCT
    ) internal {
        address tokenAddress = tokenAddresses[tokenId];
        if (tokenAddress == address(0)) {
            revert UnknownToken();
        }

        {
            // Extract the provided balance from the proof
            EGCT memory providedBalance = EGCT({
                c1: Point({x: publicInputs[3], y: publicInputs[4]}),
                c2: Point({x: publicInputs[5], y: publicInputs[6]})
            });

            // Encrypt the withdrawn amount
            EGCT memory encryptedWithdrawnAmount = BabyJubJub.encrypt(
                Point({x: publicInputs[1], y: publicInputs[2]}),
                amount
            );

            _privateBurn(
                from,
                tokenId,
                providedBalance,
                encryptedWithdrawnAmount,
                balancePCT
            );
        }

        // Convert and transfer the tokens
        _convertTo(from, amount, tokenAddress);
    }

    /**
     * @notice Converts regular ERC20 tokens to encrypted tokens
     * @param to Address of the receiver
     * @param amount Amount of tokens to convert
     * @param tokenAddress Address of the token to convert
     * @param amountPCT Amount PCT for the conversion
     * @return dust The dust (remainder) from the conversion
     * @return tokenId The ID of the token
     * @dev This function:
     *      1. Handles decimal scaling between tokens
     *      2. Registers the token if it's new
     *      3. Encrypts the amount with the receiver's public key
     *      4. Adds the encrypted amount to the receiver's balance
     */
    function _convertFrom(
        address to,
        uint256 amount,
        address tokenAddress,
        uint256[7] memory amountPCT
    ) internal returns (uint256 dust, uint256 tokenId) {
        // Get token decimals and handle scaling
        uint8 tokenDecimals = IERC20Metadata(tokenAddress).decimals();

        uint256 value = amount;
        dust = 0;

        // Scale down if token has more decimals
        if (tokenDecimals > decimals) {
            uint256 scalingFactor = 10 ** (tokenDecimals - decimals);
            value = amount / scalingFactor;
            dust = amount % scalingFactor;
        }
        // Scale up if token has fewer decimals
        else if (tokenDecimals < decimals) {
            uint256 scalingFactor = 10 ** (decimals - tokenDecimals);
            value = amount * scalingFactor;
            dust = 0;
        }

        // Register the token if it's new
        if (tokenIds[tokenAddress] == 0) {
            _addToken(tokenAddress);
        }
        tokenId = tokenIds[tokenAddress];

        // Return early if the scaled value is zero
        if (value == 0) {
            return (dust, tokenId);
        }

        // Encrypt and add to balance
        {
            // Get the receiver's public key
            uint256[2] memory publicKey = registrar.getUserPublicKey(to);

            // Encrypt the value with the receiver's public key
            EGCT memory eGCT = BabyJubJub.encrypt(
                Point({x: publicKey[0], y: publicKey[1]}),
                value
            );

            // Add to the receiver's balance
            EncryptedBalance storage balance = balances[to][tokenId];

            if (balance.eGCT.c1.x == 0 && balance.eGCT.c1.y == 0) {
                balance.eGCT = eGCT;
            } else {
                balance.eGCT.c1 = BabyJubJub._add(balance.eGCT.c1, eGCT.c1);
                balance.eGCT.c2 = BabyJubJub._add(balance.eGCT.c2, eGCT.c2);
            }

            // Update transaction history
            balance.amountPCTs.push(
                AmountPCT({pct: amountPCT, index: balance.transactionIndex})
            );
            balance.transactionIndex++;

            // Commit the new balance
            _commitUserBalance(to, tokenId);
        }

        return (dust, tokenId);
    }

    /**
     * @notice Converts encrypted tokens to regular ERC20 tokens
     * @param to Address of the receiver
     * @param amount Amount of tokens to convert
     * @param tokenAddress Address of the token to convert to
     * @dev This function:
     *      1. Handles decimal scaling between tokens
     *      2. Transfers the tokens to the receiver
     */
    function _convertTo(
        address to,
        uint256 amount,
        address tokenAddress
    ) internal {
        // Get token decimals and handle scaling
        uint256 tokenDecimals = IERC20Metadata(tokenAddress).decimals();

        uint256 value = amount;
        uint256 scalingFactor = 0;

        // Scale up if token has more decimals
        if (tokenDecimals > decimals) {
            scalingFactor = 10 ** (tokenDecimals - decimals);
            value = amount * scalingFactor;
        }
        // Scale down if token has fewer decimals
        else if (tokenDecimals < decimals) {
            scalingFactor = 10 ** (decimals - tokenDecimals);
            value = amount / scalingFactor;
        }

        // Transfer the tokens to the receiver
        IERC20 token = IERC20(tokenAddress);
        SafeERC20.safeTransfer(token, to, value);
    }

    /**
     * @notice Performs the internal logic for a private transfer
     * @param from address The address of the sender
     * @param to address The address of the receiver
     * @param tokenId uint256 The ID of the token to transfer
     * @param providedBalance EGCT The provided balance from the proof
     * @param senderEncryptedAmount EGCT The encrypted amount to subtract from the sender's balance
     * @param receiverEncryptedAmount EGCT The encrypted amount to add to the receiver's balance
     * @param balancePCT uint256[7] The balance PCT for the sender after the transfer
     * @param amountPCT uint256[7] The amount PCT for the transfer
     * @dev This function:
     *      1. Verifies the sender's balance is valid
     *      2. Subtracts the encrypted amount from the sender's balance
     *      3. Adds the encrypted amount to the receiver's balance
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId,
        EGCT memory providedBalance,
        EGCT memory senderEncryptedAmount,
        EGCT memory receiverEncryptedAmount,
        uint256[7] memory balancePCT,
        uint256[7] memory amountPCT
    ) internal {
        {
            // 1. for sender operation is very similar to the private burn
            _privateBurn(
                from,
                tokenId,
                providedBalance,
                senderEncryptedAmount,
                balancePCT
            );
        }

        {
            // 2. for receiver operation is very similar to the private mint
            _addToUserBalance(to, tokenId, receiverEncryptedAmount, amountPCT);
        }
    }

    /**
     * @notice Executes a private transfer operation
     * @param to Address of the receiver
     * @param tokenId ID of the token to transfer
     * @param proof The zero-knowledge proof proving the validity of the transfer operation
     * @param balancePCT The balance PCT for the sender after the transfer
     */
    function _executePrivateTransfer(
        address to,
        uint256 tokenId,
        TransferProof memory proof,
        uint256[7] memory balancePCT,
        bytes memory message
    ) internal {
        uint256[32] memory publicInputs = proof.publicSignals;

        // validate user's public key
        _validatePublicKey(msg.sender, [publicInputs[0], publicInputs[1]]);
        _validatePublicKey(to, [publicInputs[10], publicInputs[11]]);

        _validateAuditorPublicKey([publicInputs[23], publicInputs[24]]);

        // Verify the zero-knowledge proof
        bool isVerified = transferVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        // Extract the inputs for the transfer operation
        TransferInputs memory transferInputs = _extractTransferInputs(
            publicInputs
        );

        // Perform the transfer
        _transfer({
            from: msg.sender,
            to: to,
            tokenId: tokenId,
            providedBalance: transferInputs.providedBalance,
            senderEncryptedAmount: transferInputs.senderEncryptedAmount,
            receiverEncryptedAmount: transferInputs.receiverEncryptedAmount,
            balancePCT: balancePCT,
            amountPCT: transferInputs.amountPCT
        });

        // Extract auditor PCT and emit event
        {
            uint256[7] memory auditorPCT;
            for (uint256 i = 0; i < 7; i++) {
                auditorPCT[i] = publicInputs[25 + i];
            }

            emit PrivateTransfer(msg.sender, to, auditorPCT, auditor);
        }

        // emit metadata if message is provided
        _emitMetadata(msg.sender, to, "PRIVATE_TRANSFER", message);
    }

    /**
     * @notice Performs the internal logic for a private burn
     * @param from Address of the user to burn tokens from
     * @param tokenId ID of the token to burn
     * @param providedBalance The provided balance from the proof
     * @param encryptedAmount The encrypted amount to subtract
     * @param balancePCT The balance PCT for the user after the burn
     * @dev This function:
     *      1. Verifies the user's balance is valid
     *      2. Subtracts the encrypted amount from the user's balance
     */
    function _privateBurn(
        address from,
        uint256 tokenId,
        EGCT memory providedBalance,
        EGCT memory encryptedAmount,
        uint256[7] memory balancePCT
    ) internal {
        // verify user encrypted balance
        uint256 transactionIndex = _verifyUserBalance(
            from,
            tokenId,
            providedBalance
        );

        // subtract from user's balance
        _subtractFromUserBalance(
            from,
            tokenId,
            encryptedAmount,
            balancePCT,
            transactionIndex
        );
    }

    /**
     * @notice Performs the internal logic for a private mint
     * @param user Address of the user to mint tokens to
     * @param proof The zero-knowledge proof proving the validity of the mint operation
     * @param message Additional metadata message to be emitted with the mint event
     */
    function _executePrivateMint(
        address user,
        MintProof calldata proof,
        bytes memory message
    ) internal {
        uint256[24] memory publicInputs = proof.publicSignals;

        // Validate chain ID
        if (block.chainid != publicInputs[0]) {
            revert InvalidChainId();
        }

        // validate public keys
        _validatePublicKey(user, [publicInputs[2], publicInputs[3]]);
        _validateAuditorPublicKey([publicInputs[15], publicInputs[16]]);

        // Validate and check mint nullifier
        uint256 mintNullifier = publicInputs[1];
        if (mintNullifier >= BabyJubJub.Q) {
            revert InvalidNullifier();
        }
        if (alreadyMinted[mintNullifier]) {
            revert InvalidProof();
        }

        // Verify the zero-knowledge proof
        bool isVerified = mintVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        {
            // Extract the encrypted amount from the proof
            EGCT memory encryptedAmount = EGCT({
                c1: Point({x: publicInputs[4], y: publicInputs[5]}),
                c2: Point({x: publicInputs[6], y: publicInputs[7]})
            });

            // Extract amount PCT
            uint256[7] memory amountPCT;
            for (uint256 i = 0; i < 7; i++) {
                amountPCT[i] = publicInputs[8 + i];
            }

            // since private mint is only for the standalone ERC, tokenId is always 0
            _addToUserBalance(user, 0, encryptedAmount, amountPCT);
        }

        // mark the mint nullifier as used
        alreadyMinted[mintNullifier] = true;

        uint256[7] memory auditorPCT;
        for (uint256 i = 0; i < auditorPCT.length; i++) {
            auditorPCT[i] = publicInputs[17 + i];
        }

        emit PrivateMint(user, auditorPCT, auditor);

        // emit metadata if message is provided
        _emitMetadata(msg.sender, user, "PRIVATE_MINT", message);
    }

    /**
     * @notice Executes a private burn operation
     * @param proof The zero-knowledge proof proving the validity of the burn operation
     * @param balancePCT The balance PCT for the user after the burn
     * @param message Additional metadata message to be emitted with the burn event
     */
    function _executePrivateBurn(
        BurnProof calldata proof,
        uint256[7] calldata balancePCT,
        bytes memory message
    ) internal {
        uint256[19] calldata publicInputs = proof.publicSignals;
        address from = msg.sender;

        // validate public key
        _validatePublicKey(from, [publicInputs[0], publicInputs[1]]);

        // validate auditor public key
        _validateAuditorPublicKey([publicInputs[10], publicInputs[11]]);

        // Verify the zero-knowledge proof
        bool isVerified = burnVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        // provided encrypted balance
        EGCT memory providedBalance = EGCT({
            c1: Point({x: publicInputs[2], y: publicInputs[3]}),
            c2: Point({x: publicInputs[4], y: publicInputs[5]})
        });

        // extract encrypted burn amount
        EGCT memory encryptedBurnAmount = EGCT({
            c1: Point({x: publicInputs[6], y: publicInputs[7]}),
            c2: Point({x: publicInputs[8], y: publicInputs[9]})
        });

        // perform the burn (since burn is only for Standalone, always passing tokenId as 0)
        _privateBurn(from, 0, providedBalance, encryptedBurnAmount, balancePCT);

        // extract auditor PCT
        uint256[7] memory auditorPCT;
        for (uint256 i = 0; i < auditorPCT.length; i++) {
            auditorPCT[i] = publicInputs[12 + i];
        }

        emit PrivateBurn(from, auditorPCT, auditor);

        // emit metadata if message is provided
        _emitMetadata(msg.sender, from, "PRIVATE_BURN", message);
    }

    /**
     * @notice Executes a private deposit operation
     * @param amount The amount of tokens to deposit
     * @param tokenAddress The address of the token to deposit
     * @param amountPCT The amount PCT for the deposit
     * @param message Additional metadata message to be emitted with the deposit event
     */
    function _executeDeposit(
        uint256 amount,
        address tokenAddress,
        uint256[7] memory amountPCT,
        bytes memory message
    ) internal {
        IERC20 token = IERC20(tokenAddress);
        uint256 dust;
        uint256 tokenId;
        address to = msg.sender;

        // Get the contract's balance before the transfer
        uint256 balanceBefore = token.balanceOf(address(this));

        // Transfer tokens from user to contract
        SafeERC20.safeTransferFrom(token, to, address(this), amount);

        // Get the contract's balance after the transfer
        uint256 balanceAfter = token.balanceOf(address(this));

        // Verify that the actual transferred amount matches the expected amount
        uint256 actualTransferred = balanceAfter - balanceBefore;
        if (actualTransferred != amount) {
            revert TransferFailed();
        }

        // Convert tokens to encrypted tokens
        (dust, tokenId) = _convertFrom(to, amount, tokenAddress, amountPCT);

        // Return dust to user
        if (dust > 0) {
            SafeERC20.safeTransfer(token, to, dust);
        }

        // Emit deposit event
        emit Deposit(to, amount, dust, tokenId);

        // emit metadata if message is provided
        _emitMetadata(msg.sender, to, "DEPOSIT", message);
    }

    function _executeWithdraw(
        uint256 tokenId,
        WithdrawProof memory proof,
        uint256[7] memory balancePCT,
        bytes memory message
    ) internal {
        address from = msg.sender;
        uint256[16] memory publicInputs = proof.publicSignals;
        uint256 amount = publicInputs[0];

        // validate public keys
        _validatePublicKey(from, [publicInputs[1], publicInputs[2]]);
        _validateAuditorPublicKey([publicInputs[7], publicInputs[8]]);

        // Verify the zero-knowledge proof
        bool isVerified = withdrawVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        // Perform the withdrawal
        _withdraw(from, amount, tokenId, publicInputs, balancePCT);

        // Extract auditor PCT and emit event
        {
            uint256[7] memory auditorPCT;
            for (uint256 i = 0; i < 7; i++) {
                auditorPCT[i] = publicInputs[9 + i];
            }

            emit Withdraw(from, amount, tokenId, auditorPCT, auditor);
        }

        // emit metadata if message is provided
        _emitMetadata(msg.sender, from, "WITHDRAW", message);
    }

    /**
     * @notice Validates a user's public key
     * @param user The address of the user
     * @param providedPublicKey The public key to validate
     * @dev Function fetches the user's public key from the registrar contract
     * @dev If the public key is not valid, it reverts with InvalidProof error
     */
    function _validatePublicKey(
        address user,
        uint256[2] memory providedPublicKey
    ) internal view {
        uint256[2] memory userPublicKey = registrar.getUserPublicKey(user);

        if (
            userPublicKey[0] != providedPublicKey[0] ||
            userPublicKey[1] != providedPublicKey[1]
        ) {
            revert InvalidProof();
        }
    }

    /**
     * @notice Validates the auditor's public key
     * @param providedPublicKey The public key to validate
     * @dev If the public key is not match with the auditor's public key, it reverts with InvalidProof error
     */
    function _validateAuditorPublicKey(
        uint256[2] memory providedPublicKey
    ) internal view {
        if (
            auditorPublicKey.x != providedPublicKey[0] ||
            auditorPublicKey.y != providedPublicKey[1]
        ) {
            revert InvalidProof();
        }
    }

    /**
     * @notice Extracts the inputs for a transfer operation
     * @param input The input array containing the transfer data
     * @return transferInputs TransferInputs struct containing:
     *         - providedBalance (EGCT): The provided balance from the proof
     *         - senderEncryptedAmount (EGCT): The encrypted amount to subtract from sender
     *         - receiverEncryptedAmount (EGCT): The encrypted amount to add to receiver
     *         - amountPCT (uint256[7]): The amount PCT for the transfer
     */
    function _extractTransferInputs(
        uint256[32] memory input
    ) internal pure returns (TransferInputs memory transferInputs) {
        transferInputs.providedBalance = EGCT({
            c1: Point({x: input[2], y: input[3]}),
            c2: Point({x: input[4], y: input[5]})
        });

        transferInputs.senderEncryptedAmount = EGCT({
            c1: Point({x: input[6], y: input[7]}),
            c2: Point({x: input[8], y: input[9]})
        });

        transferInputs.receiverEncryptedAmount = EGCT({
            c1: Point({x: input[12], y: input[13]}),
            c2: Point({x: input[14], y: input[15]})
        });

        for (uint256 i = 0; i < 7; i++) {
            transferInputs.amountPCT[i] = input[16 + i];
        }
    }
}



================================================
FILE: contracts/EncryptedUserBalances.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {EncryptedBalance, EGCT, BalanceHistory, AmountPCT} from "./types/Types.sol";
import {InvalidProof} from "./errors/Errors.sol";
import {BabyJubJub} from "./libraries/BabyJubJub.sol";

/**
 * @title EncryptedUserBalances
 * @notice Contract for managing encrypted user balances in the privacy-preserving ERC system
 * @dev This contract handles:
 *      1. Storage and retrieval of encrypted balances
 *      2. Balance history tracking for transaction validation
 *      3. Cryptographic operations on encrypted balances
 *
 * The contract uses ElGamal encryption (EGCT) to store balances privately,
 * allowing users to prove they have sufficient funds without revealing the actual amount.
 */
contract EncryptedUserBalances {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice Mapping of user addresses to their encrypted balances for each token
    /// @dev Structure: user => tokenId => EncryptedBalance
    mapping(address user => mapping(uint256 tokenId => EncryptedBalance balance))
        public balances;

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Returns the encrypted balance for a user's standalone token
     * @param user The address of the user
     * @return eGCT The ElGamal ciphertext representing the encrypted balance
     * @return nonce The current nonce used for balance validation
     * @return amountPCTs Array of amount PCT
     * @return balancePCT The current balance PCT
     * @return transactionIndex The current transaction index
     * @dev Since in standalone mode, the tokenId is always 0
     */
    function balanceOfStandalone(
        address user
    )
        external
        view
        returns (
            EGCT memory eGCT,
            uint256 nonce,
            AmountPCT[] memory amountPCTs,
            uint256[7] memory balancePCT,
            uint256 transactionIndex
        )
    {
        return balanceOf(user, 0);
    }

    /**
     * @notice Returns the encrypted balance for a user's specified token
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @return eGCT The ElGamal ciphertext representing the encrypted balance
     * @return nonce The current nonce used for balance validation
     * @return amountPCTs Array of amount PCT
     * @return balancePCT The current balance PCT
     * @return transactionIndex The current transaction index
     */
    function balanceOf(
        address user,
        uint256 tokenId
    )
        public
        view
        returns (
            EGCT memory eGCT,
            uint256 nonce,
            AmountPCT[] memory amountPCTs,
            uint256[7] memory balancePCT,
            uint256 transactionIndex
        )
    {
        EncryptedBalance storage balance = balances[user][tokenId];
        return (
            balance.eGCT,
            balance.nonce,
            balance.amountPCTs,
            balance.balancePCT,
            balance.transactionIndex
        );
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Adds an encrypted amount to a user's balance
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param eGCT The ElGamal ciphertext representing the amount to add
     * @param amountPCT The amount PCT for transaction history
     * @dev This function:
     *      1. Initializes the balance if it's the first transaction
     *      2. Adds the encrypted amount to the existing balance
     *      3. Updates the user history (by adding new amount PCT)
     */
    function _addToUserBalance(
        address user,
        uint256 tokenId,
        EGCT memory eGCT,
        uint256[7] memory amountPCT
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        // if user balance is not initialized, initialize it
        if (balance.eGCT.c1.x == 0 && balance.eGCT.c1.y == 0) {
            balance.eGCT = eGCT;
        } else {
            // if user balance is already initialized, add the encrypted amount to the balance
            balance.eGCT.c1 = BabyJubJub._add(balance.eGCT.c1, eGCT.c1);
            balance.eGCT.c2 = BabyJubJub._add(balance.eGCT.c2, eGCT.c2);
        }

        // in all the case
        _addToUserHistory(user, tokenId, amountPCT);
    }

    /**
     * @notice Subtracts an encrypted amount from a user's balance
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param eGCT The ElGamal ciphertext representing the amount to subtract
     * @param balancePCT The new balance PCT after subtraction
     * @param transactionIndex The transaction index to delete from history
     * @dev This function:
     *      1. Subtracts the encrypted amount from the balance
     *      2. Updates the user history (by removing the specified transaction)
     *      3. Updates the balance PCT for user
     */
    function _subtractFromUserBalance(
        address user,
        uint256 tokenId,
        EGCT memory eGCT,
        uint256[7] memory balancePCT,
        uint256 transactionIndex
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        balance.eGCT.c1 = BabyJubJub._sub(balance.eGCT.c1, eGCT.c1);
        balance.eGCT.c2 = BabyJubJub._sub(balance.eGCT.c2, eGCT.c2);

        // delete the amount pct from the balance
        _deleteUserHistory(user, tokenId, transactionIndex);

        // update balance pct
        balance.balancePCT = balancePCT;
    }

    /**
     * @notice Adds a transaction to the user's balance history
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param amountPCT The amount PCT for the transaction
     * @dev This function:
     *      1. Calculates a unique hash for the current balance state
     *      2. Marks this hash as valid in the balance history
     *      3. Adds the amount PCT to the transaction history
     *      4. Increments the transaction index
     *
     * The balance hash is unique for each transaction because it includes the nonce,
     * which is incremented after each transaction. This ensures that each transaction
     * can be uniquely identified and validated.
     */
    function _addToUserHistory(
        address user,
        uint256 tokenId,
        uint256[7] memory amountPCT
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        uint256 nonce = balance.nonce;
        uint256 balanceHash = _hashEGCT(balance.eGCT);
        balanceHash = uint256(keccak256(abi.encode(balanceHash, nonce)));

        // mark the balance hash as valid
        balance.balanceList[balanceHash] = BalanceHistory({
            index: balance.transactionIndex,
            isValid: true
        });

        // add the amount pct to the balance
        balance.amountPCTs.push(
            AmountPCT({pct: amountPCT, index: balance.transactionIndex})
        );

        balance.transactionIndex++;
    }

    /**
     * @notice Commits the current balance state to the user's history
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @dev This function:
     *      1. Calculates a unique hash for the current balance state
     *      2. Marks this hash as valid in the balance history
     *      3. Increments the transaction index
     *
     * This is used to create a checkpoint of the balance state after operations
     * that don't change the balance amount but need to be recorded in history.
     */
    function _commitUserBalance(address user, uint256 tokenId) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        uint256 nonce = balance.nonce;
        uint256 balanceHash = _hashEGCT(balance.eGCT);
        balanceHash = uint256(keccak256(abi.encode(balanceHash, nonce)));

        balance.balanceList[balanceHash] = BalanceHistory({
            index: balance.transactionIndex,
            isValid: true
        });

        balance.transactionIndex++;
    }

    /**
     * @notice Deletes transaction history up to a specific transaction index
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param transactionIndex The transaction index to delete up to
     * @dev This function:
     *      1. Removes amount PCTs from the history up to the specified index
     *      2. Increments the nonce (invalidate all previous balance hashes)
     *      3. Commits the new balance state to history
     *
     * Instead of deleting individual history entries, this function uses the nonce
     * to invalidate all previous balance hashes at once, which is more gas efficient.
     */
    function _deleteUserHistory(
        address user,
        uint256 tokenId,
        uint256 transactionIndex
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        for (uint256 i = balance.amountPCTs.length; i > 0; i--) {
            uint256 index = i - 1;

            if (balance.amountPCTs[index].index <= transactionIndex) {
                balance.amountPCTs[index] = balance.amountPCTs[
                    balance.amountPCTs.length - 1
                ];
                balance.amountPCTs.pop();
            }
        }

        balance.nonce++;

        _commitUserBalance(user, tokenId);
    }

    /**
     * @notice Checks if a balance hash is valid for a user
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param balanceHash The hash to validate
     * @return isValid True if the hash is valid, false otherwise
     * @return index The transaction index associated with the hash
     * This is used to validate that a user is using a recent and valid balance
     * in their transactions.
     */
    function _isBalanceValid(
        address user,
        uint256 tokenId,
        uint256 balanceHash
    ) internal view returns (bool, uint256) {
        uint256 nonce = balances[user][tokenId].nonce;
        uint256 hashWithNonce = uint256(
            keccak256(abi.encode(balanceHash, nonce))
        );
        return (
            balances[user][tokenId].balanceList[hashWithNonce].isValid,
            balances[user][tokenId].balanceList[hashWithNonce].index
        );
    }

    /**
     * @notice Verifies a user's balance
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param eGCT The ElGamal ciphertext representing the balance
     * @return transactionIndex The transaction index associated with the balance
     * @dev If balance is not valid, it reverts with InvalidProof error
     */
    function _verifyUserBalance(
        address user,
        uint256 tokenId,
        EGCT memory eGCT
    ) internal view returns (uint256) {
        // hash the encrypted balance
        uint256 balanceHash = _hashEGCT(eGCT);

        (bool isValid, uint256 transactionIndex) = _isBalanceValid(
            user,
            tokenId,
            balanceHash
        );
        if (!isValid) {
            revert InvalidProof();
        }

        return transactionIndex;
    }

    /**
     * @notice Calculates a hash of an ElGamal ciphertext
     * @param eGCT The ElGamal ciphertext to hash
     * @return The hash of the ciphertext
     * @dev This function creates a unique identifier for an encrypted balance
     *      by hashing all components of the ElGamal ciphertext.
     */
    function _hashEGCT(EGCT memory eGCT) internal pure returns (uint256) {
        return
            uint256(
                keccak256(
                    abi.encode(eGCT.c1.x, eGCT.c1.y, eGCT.c2.x, eGCT.c2.y)
                )
            );
    }
}



================================================
FILE: contracts/Registrar.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {Point, RegisterProof} from "./types/Types.sol";
import {IRegistrationVerifier} from "./interfaces/verifiers/IRegistrationVerifier.sol";
import {UserAlreadyRegistered, InvalidChainId, InvalidSender, InvalidRegistrationHash, InvalidProof} from "./errors/Errors.sol";

// libraries
import {BabyJubJub} from "./libraries/BabyJubJub.sol";

/**
 * @title Registrar
 * @notice Contract for managing user registration in the privacy-preserving ERC system
 * @dev This contract handles:
 *      1. User registration with public keys
 *      2. Verification of registration proofs
 *
 * The Registrar is a critical component that:
 * - Associates Ethereum addresses with public keys for encrypted operations
 */
contract Registrar {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice The verifier contract used to validate registration proofs
    IRegistrationVerifier public registrationVerifier;

    /// @notice Mapping of user addresses to their public keys
    mapping(address userAddress => Point userPublicKey) public userPublicKeys;

    /// @notice Mapping of registration hashes to registration status
    /// @dev Used to prevent duplicate registrations
    mapping(uint256 registrationHash => bool isRegistered) public isRegistered;

    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /// @notice Emitted when a user is registered
    /// @param user Address of the user
    /// @param publicKey Public key of the user
    event Register(address indexed user, Point publicKey);

    ///////////////////////////////////////////////////
    ///                   Constructor               ///
    ///////////////////////////////////////////////////

    /**
     * @notice Initializes the Registrar contract
     * @param registrationVerifier_ Address of the registration verifier contract
     */
    constructor(address registrationVerifier_) {
        registrationVerifier = IRegistrationVerifier(registrationVerifier_);
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Registers a user with their public key
     * @param proof The zero-knowledge proof proving the validity of the registration
     * @dev This function:
     *      1. Verifies the sender matches the account in the proof
     *      2. Checks the chain ID matches
     *      3. Validates the registration hash
     *      4. Verifies the zero-knowledge proof
     *      5. Registers the user with their public key
     *
     * Requirements:
     * - Sender must match the account in the proof
     * - Chain ID must match
     * - Registration hash must be valid
     * - User must not be already registered
     * - Proof must be valid
     */
    function register(RegisterProof calldata proof) external {
        // extract public inputs
        uint256[5] memory input = proof.publicSignals;

        address account = address(uint160(input[2]));

        // check if the sender matches the account in the proof
        if (msg.sender != account) {
            revert InvalidSender();
        }

        // check if the chain ID matches
        if (block.chainid != input[3]) {
            revert InvalidChainId();
        }

        // check if the registration hash is valid
        uint256 registrationHash = input[4];
        if (registrationHash >= BabyJubJub.Q) {
            revert InvalidRegistrationHash();
        }

        // check if the user is already registered
        if (isRegistered[registrationHash] && isUserRegistered(account)) {
            revert UserAlreadyRegistered();
        }

        // Verify the proof
        _verifyProof(proof);

        _register(account, Point({x: input[0], y: input[1]}), registrationHash);
    }

    /**
     * @notice Checks if a user is registered
     * @param user The address of the user to check
     * @return bool True if the user is registered, false otherwise
     * @dev A user is considered registered if their public key is not the zero point (0,0)
     */
    function isUserRegistered(address user) public view returns (bool) {
        return userPublicKeys[user].x != 0 && userPublicKeys[user].y != 0;
    }

    /**
     * @notice Gets the public key of a user
     * @param user The address of the user
     * @return publicKey The public key of the user as a uint256 array
     * @dev Returns the x and y coordinates of the user's public key
     */
    function getUserPublicKey(
        address user
    ) public view returns (uint256[2] memory publicKey) {
        return [userPublicKeys[user].x, userPublicKeys[user].y];
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Registers a user with their public key
     * @param user The address of the user
     * @param publicKey The public key of the user
     * @param registrationHash The registration hash
     * @dev This function:
     *      1. Sets the user's public key
     *      2. Marks the registration hash as used
     *      3. Emits a Register event
     */
    function _register(
        address user,
        Point memory publicKey,
        uint256 registrationHash
    ) internal {
        userPublicKeys[user] = publicKey;
        isRegistered[registrationHash] = true;
        emit Register(user, publicKey);
    }

    /**
     * @notice Verifies a registration proof
     * @param proof_ The proof to verify
     * @dev This function:
     *      1. Extracts the proof points and public inputs
     *      2. Calls the verifier contract to verify the proof
     *      3. Reverts if the proof is invalid
     */
    function _verifyProof(RegisterProof calldata proof_) internal view {
        uint256[2] memory pointA_ = proof_.proofPoints.a;
        uint256[2][2] memory pointB_ = proof_.proofPoints.b;
        uint256[2] memory pointC_ = proof_.proofPoints.c;
        uint256[5] memory input = proof_.publicSignals;

        // Verify the proof
        bool verified_ = registrationVerifier.verifyProof(
            pointA_,
            pointB_,
            pointC_,
            input
        );

        if (!verified_) {
            revert InvalidProof();
        }
    }
}



================================================
FILE: contracts/auditor/AuditorManager.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem
pragma solidity 0.8.27;

import {Point} from "../types/Types.sol";
import {ZeroAddress} from "../errors/Errors.sol";

/**
 * @title AuditorManager
 * @notice Abstract contract that manages auditor-related functionality for encrypted ERC operations
 * @dev This contract is responsible for:
 *      1. Storing and managing the auditor's address and public key
 *      2. Providing access control for auditor-related operations
 *      3. Emitting events when auditor information changes
 *
 * The auditor is a crucial component in the encrypted ERC system that:
 * - Ensures compliance with regulatory requirements
 * - Provides oversight for private operations
 */
abstract contract AuditorManager {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice The address of the current auditor
    /// @dev This address is used to identify the auditor and for access control
    address public auditor = address(0);

    /// @notice The public key of the current auditor
    /// @dev This is used in zero-knowledge proofs to validate auditor signatures
    ///      The point (0,1) is considered invalid as it's the identity point in the elliptic curve
    Point public auditorPublicKey = Point({x: 0, y: 0});

    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when the auditor's information is updated
     * @param oldAuditor The previous auditor's address
     * @param newAuditor The new auditor's address
     */
    event AuditorChanged(
        address indexed oldAuditor,
        address indexed newAuditor
    );

    ///////////////////////////////////////////////////
    ///                   Modifiers                 ///
    ///////////////////////////////////////////////////

    /**
     * @notice Ensures that an auditor is properly
     * @dev This modifier checks two conditions:
     *      1. The auditor's public key is valid (not the identity point)
     *      2. The auditor's address is not the zero address
     *
     * Requirements:
     * - Auditor public key must be set (not the identity point)
     * - Auditor address must be set (not zero address)
     */
    modifier onlyIfAuditorSet() {
        require(
            auditorPublicKey.x != 0 && auditorPublicKey.y != 1,
            "Auditor public key not set"
        );
        require(auditor != address(0), "Auditor not set");
        _;
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Checks if the auditor's public key is properly set
     * @return bool True if the auditor's public key is set and valid
     * @dev This function is used to verify if the contract is ready for
     *      operations that require auditor validation
     */
    function isAuditorKeySet() external view returns (bool) {
        return auditorPublicKey.x != 0 && auditorPublicKey.y != 1;
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Updates the auditor's information
     * @param newAuditor The address of the new auditor
     * @param publicKey The public key of the new auditor
     * @dev This function:
     *      1. Validates the new auditor's address
     *      2. Updates the auditor's information
     *      3. Emits an event to track the change
     *
     * Requirements:
     * - newAuditor must not be the zero address
     * - publicKey must be a valid point on the elliptic curve
     */
    function _updateAuditor(
        address newAuditor,
        uint256[2] memory publicKey
    ) internal {
        address oldAuditor = auditor;
        // check if the auditor is the zero address
        if (newAuditor == address(0)) {
            revert ZeroAddress();
        }

        auditor = newAuditor;
        auditorPublicKey = Point({x: publicKey[0], y: publicKey[1]});

        emit AuditorChanged(oldAuditor, newAuditor);
    }
}



================================================
FILE: contracts/errors/Errors.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

error UserAlreadyRegistered();
error UserNotRegistered();
error UnauthorizedAccess();
error AuditorKeyNotSet();
error InvalidProof();
error InvalidOperation();
error TransferFailed();
error UnknownToken();
error InvalidChainId();
error InvalidNullifier();
error InvalidSender();
error InvalidRegistrationHash();
error ZeroAddress();
error TokenBlacklisted(address token);



================================================
FILE: contracts/interfaces/IEncryptedERC.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IEncryptedERC {
    /**
     * @notice Sets the balance percentage for a user and token.
     * @param user User address
     * @param tokenId Token ID
     * @param pct Balance percentage array
     * @dev Only the registrar can set the balance percentage
     */
    function setUserBalancePCT(
        address user,
        uint256 tokenId,
        uint256[7] memory pct
    ) external;
}



================================================
FILE: contracts/interfaces/IRegistrar.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IRegistrar {
    /**
     * @dev Returns the public key of a user.
     * @param user Address of the user.
     * @return publicKey The public key of the user as an array of two uint256 values.
     */
    function getUserPublicKey(
        address user
    ) external view returns (uint256[2] memory publicKey);

    /**
     * @dev Returns true if the user is registered.
     * @param user Address of the user.
     * @return isRegistered True if the user is registered, false otherwise.
     */
    function isUserRegistered(address user) external view returns (bool);
}



================================================
FILE: contracts/interfaces/verifiers/IBurnVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IBurnVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[19] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/IMintVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IMintVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[24] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/IRegistrationVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IRegistrationVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[5] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/ITransferVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface ITransferVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[32] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/IWithdrawVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IWithdrawVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[16] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/libraries/BabyJubJub.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

// Structs
import {Point, EGCT} from "../types/Types.sol";

/**
 * @dev BabyJubJub curve operations
 */
library BabyJubJub {
    // Curve parameters
    // E: A^2 + y^2 = 1 + Dx^2y^2 (mod Q)
    uint256 internal constant A = 168700;
    uint256 internal constant D = 168696;
    uint256 public constant Q =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    uint256 internal constant H =
        10944121435919637611123202872628637544274182200208017171849102093287904247808;
    uint256 internal constant R =
        2736030358979909402780800718157159386076813972158567259200215660948447373041;

    /**
     * @dev Subtract a BabyJubJub point from another BabyJubJub point
     * @param _point1 the point which will be subtracted from
     * @param _point2 point to subtract
     * @return result
     */
    function _sub(
        Point memory _point1,
        Point memory _point2
    ) public view returns (Point memory) {
        return _add(_point1, negate(_point2));
    }

    /**
     * @dev Add 2 points on BabyJubJub curve
     * Formulae for adding 2 points on a twisted Edwards curve:
     * x3 = (x1y2 + y1x2) / (1 + dx1x2y1y2)
     * y3 = (y1y2 - ax1x2) / (1 - dx1x2y1y2)
     * @param _point1 first point
     * @param _point2 second point
     * @return resulting point
     */
    function _add(
        Point memory _point1,
        Point memory _point2
    ) public view returns (Point memory) {
        uint256 x1x2 = mulmod(_point1.x, _point2.x, Q);
        uint256 y1y2 = mulmod(_point1.y, _point2.y, Q);

        uint256 dx1x2y1y2 = mulmod(D, mulmod(x1x2, y1y2, Q), Q);

        uint256 x3Num = addmod(
            mulmod(_point1.x, _point2.y, Q),
            mulmod(_point1.y, _point2.x, Q),
            Q
        );
        uint256 y3Num = submod(y1y2, mulmod(A, x1x2, Q));

        return
            Point({
                x: mulmod(x3Num, invmod(addmod(1, dx1x2y1y2, Q)), Q),
                y: mulmod(y3Num, invmod(submod(1, dx1x2y1y2)), Q)
            });
    }

    /**
     * @dev Multiply a BabyJubJub point by a scalar
     * Use the double and add algorithm
     * @param _point point be multiplied by a scalar
     * @param _scalar scalar value
     * @return resulting point
     */
    function scalarMultiply(
        Point memory _point,
        uint256 _scalar
    ) public view returns (Point memory) {
        // Initial scalar remainder
        uint256 remaining = _scalar % R;

        // Copy initial point so that we don't mutate it
        Point memory initial = _point;

        // Initialize result
        Point memory result = Point({x: 0, y: 1});

        // Loop while remainder is greater than 0
        while (remaining != 0) {
            // If the right-most binary digit is 1 (number is odd) add initial point to result
            if ((remaining & 1) != 0) {
                result = _add(result, initial);
            }

            // Double initial point
            initial = double(initial);

            // Shift bits to the right
            remaining = remaining >> 1;
        }

        return result;
    }

    /**
     *
     * @param _publicKey Public Key that will be used in encryption
     * @param _msg Message in scalar form to be encrypted
     */
    function elGamalEncryption(
        Point memory _publicKey,
        uint256 _msg
    ) public view returns (EGCT memory) {
        uint256 random = 1;
        Point memory b8 = base8();

        Point memory c1 = scalarMultiply(b8, random);
        Point memory pkr = scalarMultiply(_publicKey, random);
        Point memory pMsg = scalarMultiply(b8, _msg);

        Point memory c2 = _add(pkr, pMsg);

        return EGCT({c1: c1, c2: c2});
    }

    // elgamal encryption with a given message
    function encrypt(
        Point memory _publicKey,
        uint256 _msg
    ) public view returns (EGCT memory) {
        return elGamalEncryption(_publicKey, _msg);
    }

    /**
     * @dev Default generator
     */
    function base8() public pure returns (Point memory) {
        return
            Point({
                x: 5299619240641551281634865583518297030282874472190772894086521144482721001553,
                y: 16950150798460657717958625567821834550301663161624707787222815936182638968203
            });
    }

    /**
     * @dev Double a point on BabyJubJub curve
     * @param _p point to double
     * @return doubled point
     */
    function double(Point memory _p) internal view returns (Point memory) {
        return _add(_p, _p);
    }

    /**
     * @dev Compute modular inverse of a number
     * @param _a the value to be inverted in mod Q
     */
    function invmod(uint256 _a) internal view returns (uint256) {
        // We can use Euler's theorem instead of the extended Euclidean algorithm
        // Since m = Q and Q is prime we have: a^-1 = a^(m - 2) (mod m)
        return
            expmod(
                _a,
                0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffffff
            );
    }

    /**
     * @dev Exponentiation modulo Q
     * @param _base the base of the exponentiation
     * @param _exponent the exponent
     * @return result
     */
    function expmod(
        uint256 _base,
        uint256 _exponent
    ) internal view returns (uint256) {
        uint256 result;

        // solhint-disable-next-line no-inline-assembly
        assembly {
            let
                localQ
            := 0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001
            let memPtr := mload(0x40)
            mstore(memPtr, 0x20) // Length of base _b
            mstore(add(memPtr, 0x20), 0x20) // Length of exponent _e
            mstore(add(memPtr, 0x40), 0x20) // Length of modulus Q
            mstore(add(memPtr, 0x60), _base) // Base _b
            mstore(add(memPtr, 0x80), _exponent) // Exponent _e
            mstore(add(memPtr, 0xa0), localQ) // Modulus Q

            // The bigModExp precompile is at 0x05
            let success := staticcall(gas(), 0x05, memPtr, 0xc0, memPtr, 0x20)
            switch success
            case 0 {
                revert(0x0, 0x0)
            }
            default {
                result := mload(memPtr)
            }
        }

        return result;
    }

    /**
     * @dev Negate a BabyJubJub point
     * @param _point point to negate
     * @return p = -(_p)
     */
    function negate(Point memory _point) internal pure returns (Point memory) {
        return Point({x: Q - _point.x, y: _point.y});
    }

    /**
     * @dev Modular subtract (mod n).
     * @param _a The first number
     * @param _b The number to be subtracted
     * @return result
     */
    function submod(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return addmod(_a, Q - _b, Q);
    }
}



================================================
FILE: contracts/metadata/EncryptedMetadata.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem
pragma solidity 0.8.27;

// types
import {Metadata} from "../types/Types.sol";

/**
 * @title EncryptedMetadata
 * @notice A contract that handles encrypted metadata functionality for privacy-preserving operations
 * @dev This contract provides the core functionality for creating and emitting encrypted metadata
 *      associated with various operations. It can be inherited by other contracts that need
 *      metadata capabilities.
 *
 * Key features:
 * - Encrypted metadata creation and emission
 * - Structured metadata with sender, receiver, type, and encrypted message
 * - Privacy-preserving message transmission
 * - Reusable across different contract types
 */
contract EncryptedMetadata {
    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when encrypted metadata is sent between users
     * @param from Address of the sender of the metadata
     * @param to Address of the receiver of the metadata
     * @param metadata Structured metadata containing message details and encrypted content
     * @dev This event is emitted when encrypted metadata is transmitted between registered users.
     *      The metadata includes the sender, receiver, message type, and encrypted message content.
     *      Only the intended receiver can decrypt the message using their private key.
     */
    event PrivateMessage(
        address indexed from,
        address indexed to,
        Metadata metadata
    );

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Sends encrypted metadata to a registered user
     * @param to Address of the recipient of the encrypted metadata
     * @param message Encrypted message bytes to be sent
     * @dev This function allows any registered user to send encrypted metadata to another
     *      registered user. The message should be encrypted with the recipient's public key
     *      before calling this function.
     *
     * The function:
     *      1. Validates that both sender and recipient are registered users
     *      2. Creates a structured metadata object
     *      3. Emits the PrivateMessage event with the metadata
     *
     * Requirements:
     * - Caller must be a registered user
     * - Recipient must be a registered user
     * - Message should be properly encrypted with recipient's public key
     *
     */
    function _sendEncryptedMetadata(
        address to,
        bytes calldata message
    ) internal virtual {
        // Create and emit metadata
        address messageFrom = msg.sender;
        Metadata memory metadata = _createMetadata(
            messageFrom,
            to,
            "MESSAGE",
            message
        );
        emit PrivateMessage(messageFrom, to, metadata);
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emits metadata for operation-specific events
     * @param from Address of the sender
     * @param to Address of the recipient
     * @param messageType Type of the operation (e.g., "PRIVATE_MINT", "PRIVATE_BURN")
     * @param message Encrypted message content
     * @dev This function is used internally by inheriting contracts to emit metadata
     *      for specific operations. It creates the metadata structure and emits the
     *      PrivateMessage event.
     */
    function _emitMetadata(
        address from,
        address to,
        string memory messageType,
        bytes memory message
    ) internal {
        if (message.length > 0) {
            Metadata memory metadata = _createMetadata(
                from,
                to,
                messageType,
                message
            );
            emit PrivateMessage(from, to, metadata);
        }
    }

    /**
     * @notice Creates a structured metadata object
     * @param messageFrom Address of the sender of the metadata
     * @param messageTo Address of the recipient of the metadata
     * @param messageType Type/category of the message (e.g., "PRIVATE_MINT", "TRANSFER", etc.)
     * @param encryptedMsg Encrypted message content
     * @return metadata Structured Metadata object containing all message details
     * @dev This internal function creates a standardized metadata structure that includes
     *      sender, recipient, message type, and encrypted content. The message type helps
     *      recipients categorize and process different types of metadata appropriately.
     */
    function _createMetadata(
        address messageFrom,
        address messageTo,
        string memory messageType,
        bytes memory encryptedMsg
    ) internal pure returns (Metadata memory metadata) {
        metadata.messageFrom = messageFrom;
        metadata.messageTo = messageTo;
        metadata.messageType = messageType;
        metadata.encryptedMsg = encryptedMsg;
        return metadata;
    }
}



================================================
FILE: contracts/metadata/IEncryptedMetadata.sol
================================================
// SPDX-License-Identifier: Ecosystem
pragma solidity 0.8.27;

// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// types
import {Metadata} from "../types/Types.sol";

/**
 * @title IEncryptedMetadata
 * @notice Interface for encrypted metadata functionality
 * @dev This interface defines the external functions that can be called on contracts
 *      that implement encrypted metadata capabilities.
 */
interface IEncryptedMetadata {
    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when encrypted metadata is sent between users
     * @param from Address of the sender of the metadata
     * @param to Address of the receiver of the metadata
     * @param metadata Structured metadata containing message details and encrypted content
     */
    event PrivateMessage(
        address indexed from,
        address indexed to,
        Metadata metadata
    );

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Sends encrypted metadata to a registered user
     * @param to Address of the recipient of the encrypted metadata
     * @param message Encrypted message bytes to be sent
     * @dev This function allows any registered user to send encrypted metadata to another
     *      registered user. The message should be encrypted with the recipient's public key
     *      before calling this function.
     */
    function sendEncryptedMetadata(address to, bytes calldata message) external;
}



================================================
FILE: contracts/prod/BurnVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract BurnVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 20500123508036250241732436039045855491142840147741568076165900093824331281316;
    uint256 constant deltax2 = 17951494579165795533532847235529611089521789751209994758862962564682445617412;
    uint256 constant deltay1 = 5834387578477044714458263369208539598498352288497332887384107712494722576583;
    uint256 constant deltay2 = 15268404118840851015046775717571916089738924216088942953684197626467386210997;

    
    uint256 constant IC0x = 11786268729161045937652164714990691490770027441460947932012316631529733292940;
    uint256 constant IC0y = 9581132102330540074693305331254898451475664668584360899026097918947512977366;
    
    uint256 constant IC1x = 914822366018062648285730205402683692599853766866159406178623354781735659599;
    uint256 constant IC1y = 8553697750564092712813746981763759579862680918228138684307182805192139236520;
    
    uint256 constant IC2x = 17908121343774581376092646765067170799970925894057937307165335210962871507135;
    uint256 constant IC2y = 6739483966006459958647545663755815825611388802168101513616676265213547687212;
    
    uint256 constant IC3x = 143359351657650308208480824138891765346610788279862658068353643164441844115;
    uint256 constant IC3y = 1688658345879791302522420761526578526163188876279486731177660400972657648742;
    
    uint256 constant IC4x = 18309718863517978042660293994537440591428742486455947599492279373595114219500;
    uint256 constant IC4y = 3543366565414834921232477531525858456841505305202548147687587105557694958104;
    
    uint256 constant IC5x = 2179968961403977829543241099157331775731416225717055667057125732267317798366;
    uint256 constant IC5y = 14579564811228528586131093319854876770716135551807922280189147940915226636750;
    
    uint256 constant IC6x = 12128037778350917133400346467296434075039661406517118820895803963198786951800;
    uint256 constant IC6y = 12810377956478161485381774828600271058686148075894654796038454545352947160776;
    
    uint256 constant IC7x = 9593873745453136272405518724864540111195676150385738265238288297101461351389;
    uint256 constant IC7y = 18140226050853380485925948980064648409518762214351351505488025177062130412015;
    
    uint256 constant IC8x = 5344462067192893979551241744484644250693230460027867247351105468329395690915;
    uint256 constant IC8y = 2435072349815413116277252545573449685604686772441816336584542983683379409914;
    
    uint256 constant IC9x = 15867459271796662494529143386082298582993967528167005628586571617103329782767;
    uint256 constant IC9y = 1031216327552632558464991513003642749331915406636029936411939647607628738052;
    
    uint256 constant IC10x = 11710830742293210758218398274130454937288722189717294688374583983853957500247;
    uint256 constant IC10y = 18095934287133238566717320534781010028273178446261522698705303702525394211898;
    
    uint256 constant IC11x = 5451223849987641096615559250356903902465481513182931751171182631482949381911;
    uint256 constant IC11y = 6791511973211811945927811502706661666842895298126970397039460184655612620453;
    
    uint256 constant IC12x = 12576390828389735220141209658777087276380270144557056528857559882798323629447;
    uint256 constant IC12y = 19191122649652045476856774223103624470066531140701020233373995430155185392289;
    
    uint256 constant IC13x = 3208115974817470421120218397409974778673673537533531169452261659740974257278;
    uint256 constant IC13y = 1563495302870822079389756646952495877672019554537528044396737285924026906103;
    
    uint256 constant IC14x = 15803266454704411593372706477399336420388826076293995292354385277988446601281;
    uint256 constant IC14y = 14061261779941396671642560007918916383355024387096318566313366433584709024499;
    
    uint256 constant IC15x = 1473892103720096233092115851822223251992401285317974909943916318348184767365;
    uint256 constant IC15y = 3670020837101119839757171869792531530222770849398108379916390350369899561438;
    
    uint256 constant IC16x = 8909686676336745813415338575513600352109241710831786249590248291624151036333;
    uint256 constant IC16y = 4561980313802046241453616743996179799784948333408123666456078054975402233930;
    
    uint256 constant IC17x = 9644420134970614917918276763660740255881705883613568754990717610748161142338;
    uint256 constant IC17y = 6057246608400625128574045490366205109267182635495031148770746354579442521952;
    
    uint256 constant IC18x = 3478588600416828411411103709929443364350875935722379535054531373495869197302;
    uint256 constant IC18y = 14312139497598775136457694532354226575027823182198251149840842365373433448408;
    
    uint256 constant IC19x = 16478469522390352876826812932849485876750021274758447084770343652372421581875;
    uint256 constant IC19y = 5525105724620928136283079314841429313946285054350434613540639344526895834484;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[19] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations โ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/MintVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract MintVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 6506135815943976343670204718908252778100436948044695952269504614489235747522;
    uint256 constant deltax2 = 12917761706367159448552669332158549008424338800753983174002760426851264899916;
    uint256 constant deltay1 = 21054759061354342502671069523347944444365476693281335142489232816218318279843;
    uint256 constant deltay2 = 921807516250667254679639816527091672038652453691410152532432179406742682074;

    
    uint256 constant IC0x = 10121904041541460154551260390411876526139574666949788432677764574044027742051;
    uint256 constant IC0y = 6395114105467352463516423639828272877440036954754220055848039516989817256674;
    
    uint256 constant IC1x = 5586762719201810155133862083740714325655748243483738877755810028542797644739;
    uint256 constant IC1y = 9387879719287370926595730382657598610335084850078203728936667449453246554359;
    
    uint256 constant IC2x = 19420434315212518030589186167981244595406343548992012458488730749825996100239;
    uint256 constant IC2y = 3482657374383353276279298693752239555763142972311841530862645391131143881873;
    
    uint256 constant IC3x = 21667521945257749121492909465236139091096077691835364325355606431375269082282;
    uint256 constant IC3y = 12156175257782822331801928906256367913221851960540994586932487722549923413345;
    
    uint256 constant IC4x = 16828357126590671631798447095302651492589140460428270542352941484237941156483;
    uint256 constant IC4y = 3785759973408012513975276660945174958105045591429994983968533282503371539336;
    
    uint256 constant IC5x = 21244321325522105477060254124915502034148248502931960755663601081500950076300;
    uint256 constant IC5y = 14687177467139662957844534389099557537735007475047254307829149459337997284150;
    
    uint256 constant IC6x = 21404447565616225355770439075122853382066792760583316781611395109968504614761;
    uint256 constant IC6y = 3777910210505077428584254669424713454396973987622630869249106067166590299357;
    
    uint256 constant IC7x = 5644690004940482546460856256670502914882531219591199090065888636589494736039;
    uint256 constant IC7y = 16345970805899097192278870928687506101715169625232631539981164972434652655022;
    
    uint256 constant IC8x = 16593367704572145491497340027058421406291597779030039134573703992464863830646;
    uint256 constant IC8y = 19275772679724763916884927502599327291258343548738975909520313332884772129528;
    
    uint256 constant IC9x = 18338635157990571739660769292280252719367811451620901782236478705200001456515;
    uint256 constant IC9y = 12580365946981294431067603413481570211192375767222833113101936660967490853342;
    
    uint256 constant IC10x = 19880773599746588943745194809450382516728304373879942615347513263173728275196;
    uint256 constant IC10y = 128548754750873577554444615682746852358621588347676854260473817368140033519;
    
    uint256 constant IC11x = 6476719107464483530164368276818653110527411272303410163053488615734788766586;
    uint256 constant IC11y = 13331539055996208679678758084320772815107338352425913859433335410845899223811;
    
    uint256 constant IC12x = 17393436839515851750885277096607160266036302533767007170590322671069079326483;
    uint256 constant IC12y = 17336491525577930609097646312281682071744277090982994234361498925040239739760;
    
    uint256 constant IC13x = 14059139663320156276001577403575266145309546640724899667521029234074221180403;
    uint256 constant IC13y = 5963232262834884334488206091864494084893490405377454589196552297795638041488;
    
    uint256 constant IC14x = 13813470258321934033051704279698252148783024920181797002453328082368105474789;
    uint256 constant IC14y = 19760333797981660449134124218356560284106192590380149679255903109561686546313;
    
    uint256 constant IC15x = 11858117840318587547791069185551586430435948995333725070770764697634898894992;
    uint256 constant IC15y = 16621799951101200543458233987158204772158254202860685491749532125765298740749;
    
    uint256 constant IC16x = 13584356250500421508084566767718022822120888453124821650989966819848963029582;
    uint256 constant IC16y = 21121442557480691564262522113115528175177021588076736568194595390503813944019;
    
    uint256 constant IC17x = 4326226245481542040767942040881999777137473163343274779447151141265545792486;
    uint256 constant IC17y = 21183580388477113613358837765893868421637670220571970210021457037640835173809;
    
    uint256 constant IC18x = 2704745980008452624320271214496436840853635777289985169457654318338905712053;
    uint256 constant IC18y = 5498942242451865915343845370075402718280213375705928811712272696867696623122;
    
    uint256 constant IC19x = 18021323881247358977456866382503667963535769536490271165761105041938333860259;
    uint256 constant IC19y = 15056011404667104875167366478630077579580289596849055349190254216447781136049;
    
    uint256 constant IC20x = 2428670635260390602473903592482933886252233168437493591205178349351514000281;
    uint256 constant IC20y = 862350060646299115005420081148519933461348146447694025974629367115211964519;
    
    uint256 constant IC21x = 20557922324599650576215164022162024912213509843003042307546636524489843547931;
    uint256 constant IC21y = 1061522392679391742130691544383963509531829000498209937975610885874122363387;
    
    uint256 constant IC22x = 9114256858842496488535186312068922854228150055952688114444862375910254881995;
    uint256 constant IC22y = 20868937436899006110617091404782344741103549613810098330797141428653796030423;
    
    uint256 constant IC23x = 392332888128429361037702708407695212788446855280618226506466973682041689462;
    uint256 constant IC23y = 10986782868722900357976121669302445297980271976862420955075995610762868745084;
    
    uint256 constant IC24x = 12335561474727855982123382035622477594232361573497391299243618736725476900631;
    uint256 constant IC24y = 20340286770637453607265533856091115758478742882346824576410498508028320071146;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[24] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations โ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/RegistrationVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract RegistrationVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 19753714125923452630385433581442722093941065264298048276246815338797167448169;
    uint256 constant deltax2 = 2824093012045694268556486522753590084359236940213189502690301706344424715581;
    uint256 constant deltay1 = 18067530836866733450125362089378459710977233400131368676354166923678178030850;
    uint256 constant deltay2 = 12986835757414062294165220819491853575831232959693796161862995405626568533639;

    
    uint256 constant IC0x = 5049073754175979375715331231494813434614104647476713784192278874636518287456;
    uint256 constant IC0y = 13973039660095243213304729343482928815131903560133937124822026621516335683252;
    
    uint256 constant IC1x = 6960760860997719127050640389023071189120419160885047633543132031266205842967;
    uint256 constant IC1y = 14311210142759362992805316832152765774097518712372467130307901891389375007789;
    
    uint256 constant IC2x = 14970325264892984291437720194401230916657388050759523602370378142660744831477;
    uint256 constant IC2y = 15860538555168123807647719982845297214031403618163443664157964964439662885432;
    
    uint256 constant IC3x = 9095633778879314058949553908878900274830732566924382454865365752356228820208;
    uint256 constant IC3y = 872555237120135122336016443589602918886936394020805627011933688108936774726;
    
    uint256 constant IC4x = 16383214040587918206822141493152567743771449527138865305823970747014581995205;
    uint256 constant IC4y = 15807972914519003321398888297328267389104135252699104466520087670194802499103;
    
    uint256 constant IC5x = 19865793340402973866436804410911022538640660662316164831277333170166538152800;
    uint256 constant IC5y = 1466380730966029920868782474285618825793197367831481952454164420798011324299;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[5] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations โ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/TransferVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract TransferVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 3763145489265154227084511171694601212878632438189047805035774181671200721579;
    uint256 constant deltax2 = 19123758782558680960137049284286660834755919438304772090386326942336280507607;
    uint256 constant deltay1 = 2055449651368268424611099662557640196156614451951214953872156041652270884888;
    uint256 constant deltay2 = 4894238513642303098263860622238471992887790214981922367145986542927713649242;

    
    uint256 constant IC0x = 10534947708174160215201992304779041355498470735561003306499717122566742770626;
    uint256 constant IC0y = 977905257499899758791217822505228003462337033122097368830210745360601555342;
    
    uint256 constant IC1x = 3280711512314934753992505317526746468153049821370324146752079659712174232300;
    uint256 constant IC1y = 9336028462433315123867796333994191785575550026414826950323988687234821492567;
    
    uint256 constant IC2x = 15162904757480315297547642942646568889101029164132171480256830884259150251283;
    uint256 constant IC2y = 5543236365374398176471504758808152977042933422387633848583378303299793270756;
    
    uint256 constant IC3x = 6084599581719503190421548874454410642759752303455385862653438619168850972257;
    uint256 constant IC3y = 18221408640134590893699663063879232072826509494821669770579541736533993832423;
    
    uint256 constant IC4x = 13515294784299896617263177420364080405138679960108803709127908717931838641125;
    uint256 constant IC4y = 18537954088397403593567974022084871913708328503334967617431436055023979447391;
    
    uint256 constant IC5x = 18052165982957660268255521614825223786335394780677647206458385784232406504157;
    uint256 constant IC5y = 15194585058280412021740640814141568454746627730826424655106679430538982053654;
    
    uint256 constant IC6x = 6795673837897345581582685299965371845759418273539377917021912839836254998739;
    uint256 constant IC6y = 21657993441803516491832636271681043591945604671357149970048825080204553686618;
    
    uint256 constant IC7x = 11289069591450532499401972724447572002376453520281915368481681110785600567292;
    uint256 constant IC7y = 11928539623033527208857415982521538988739084305734749009299860340216923817607;
    
    uint256 constant IC8x = 21069306450658538733134282147277445263698906490240400327689099847099016892805;
    uint256 constant IC8y = 17386225215792739261329655602621235879743955668381844924635942683420074576174;
    
    uint256 constant IC9x = 14345437456753227245495940686700720956058390526322202366808609527984033660993;
    uint256 constant IC9y = 20783457650276182735214466418096310752840639854110597710747660731724327511323;
    
    uint256 constant IC10x = 4486441340824192164364882510367580608217147444088109552210786362403055241932;
    uint256 constant IC10y = 16553383197162304205323300390384875515644589603157855319848881923653657055218;
    
    uint256 constant IC11x = 7299849271075286253602519481881832740498497504048928918662655218108429284825;
    uint256 constant IC11y = 21860902462897801250346538563498742432578812847135047747638191825760100188844;
    
    uint256 constant IC12x = 20812311364493619358550828916571084941809811622004047558332288367068444292636;
    uint256 constant IC12y = 12016931719373400562450857278580603432222260403491989130190760226223433669838;
    
    uint256 constant IC13x = 5497135883066110411842507436361453534364438777740194801977407015457789050083;
    uint256 constant IC13y = 960289848958742655061746467902157315103658957325800360115467733778920704760;
    
    uint256 constant IC14x = 5231929274251912956972062967045818685875910122905492872577246977634648737843;
    uint256 constant IC14y = 2405680064306334170931852015314781533305421897621973941278348820986549273557;
    
    uint256 constant IC15x = 14432423838507076163732475853088150200901869051870980078541847122928808702858;
    uint256 constant IC15y = 13162477912034036392091090217125050953003275307601447359448369192560307791075;
    
    uint256 constant IC16x = 6035380084134788387796489655621652133939237219692536713085830198890102531157;
    uint256 constant IC16y = 2399413675745655961934247765244583346698339793807331712093749883838255391396;
    
    uint256 constant IC17x = 1755840344064269003982904724784588829875883176859314530482477354204358128073;
    uint256 constant IC17y = 2254035658088032093438783815005800506175183609989063203400053587352866305963;
    
    uint256 constant IC18x = 10798890848385583150817432575812471927781281538956290209396088794995757251699;
    uint256 constant IC18y = 17954866604704083608550796134404236420626288308545111154506695506614087706302;
    
    uint256 constant IC19x = 16347505387353659907142234702135154337293088908179815677326286365566466652892;
    uint256 constant IC19y = 8145400935245335001708439352534792707071085106081878093341920760316939810339;
    
    uint256 constant IC20x = 1675146216777597460950545026188423914140684419320163593588767283439513220964;
    uint256 constant IC20y = 3350896492191726464487860464991880712916569207980460035951208489640794805493;
    
    uint256 constant IC21x = 14963360443843679002951981438607054782948196458205149005110445616986857962149;
    uint256 constant IC21y = 5453682123596332752358242170390357649813170313370080322693195792615766005582;
    
    uint256 constant IC22x = 15857139261281078612816698520673496528634524033018907015066869560007114561368;
    uint256 constant IC22y = 1980632957785357477112204530352463186795117003870653324765557649080191593069;
    
    uint256 constant IC23x = 16478788219117512612181000397725550334291930466463033672428118170129909755975;
    uint256 constant IC23y = 448496014898525130300582250347934155241571361910686004171961088395557906873;
    
    uint256 constant IC24x = 1666825517524796314004984207461413135984918930374439646195676102947777182322;
    uint256 constant IC24y = 4231769516076965497747593863600552237823540573882692739018851158660080939768;
    
    uint256 constant IC25x = 3076619425752586210204729303861073992338095413231945893603783564036991027253;
    uint256 constant IC25y = 18163258048301667325957382686787210971933697470347155712452125397431467657627;
    
    uint256 constant IC26x = 12240984649194028123658663640999248201069935674255565459899301410323450592735;
    uint256 constant IC26y = 7409006959659622318645744477945350299438380296542336739366936950900796739795;
    
    uint256 constant IC27x = 14527565647042473833164468956000362795519314198262866225352631554103417406048;
    uint256 constant IC27y = 19163038429636451765415902370901493252440686868311522712756801834049736087286;
    
    uint256 constant IC28x = 4563064787502578607504522503795653524780441771903390561095040321594991012805;
    uint256 constant IC28y = 17132961897233615551711030277418083026528303676258815957139396120116493761491;
    
    uint256 constant IC29x = 10825384216191058605866379876945565560465943245071973007006264312285398033060;
    uint256 constant IC29y = 21577743268709413526652653885555866375927505893806393223914213433533358336358;
    
    uint256 constant IC30x = 6397191691971602863357148514208654665119261190406272901198661597143240375;
    uint256 constant IC30y = 19034368636483100848266322777417046441872774162624857636955426992047727086319;
    
    uint256 constant IC31x = 13887187887323344570981409187274970320617448786085046258948210932080686653886;
    uint256 constant IC31y = 18715879836330833238341482186679228139561235361790447129420164142460558259244;
    
    uint256 constant IC32x = 11249333327764660601508194401900817731177098928541819675032435010243826533510;
    uint256 constant IC32y = 18594519484247875970157793842670472272992161543336964034550143549078316481776;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[32] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                
                g1_mulAccC(_pVk, IC31x, IC31y, calldataload(add(pubSignals, 960)))
                
                g1_mulAccC(_pVk, IC32x, IC32y, calldataload(add(pubSignals, 992)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations โ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            
            checkField(calldataload(add(_pubSignals, 992)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/WithdrawVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract WithdrawVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 17937261609492175473978423283366042492782788118934277743325590061927472686823;
    uint256 constant deltax2 = 9134393277137786117877602562175203472042554058536880581948679621094751253663;
    uint256 constant deltay1 = 21830579691680039608885512644157042138865859432216493093304779889887319651703;
    uint256 constant deltay2 = 13560247966092290370160513680671248860780213214350811711788627488150106599867;

    
    uint256 constant IC0x = 17592896514411238838534259943087906039445412467749501855660552694930011809103;
    uint256 constant IC0y = 12732983330708765219970549274392016128270173019293005848551474757324971194427;
    
    uint256 constant IC1x = 4884577932082347864149139524102040008488705064603684844915539314596644874132;
    uint256 constant IC1y = 5456447315604083878474265800827509892021228387863831389892962189069605516459;
    
    uint256 constant IC2x = 17313454373712045907554165434725963402117845429222578159130609582778779362163;
    uint256 constant IC2y = 4407461008783085705651216674025467181197484228135456843989535495240785812495;
    
    uint256 constant IC3x = 10893636774628876142899763192646905724708189468282917758613650147010478133301;
    uint256 constant IC3y = 148896310776292842756025446759984436974180847194558332931999839598427070960;
    
    uint256 constant IC4x = 10775675593870925743575084889624246391515781987722804772444693341240701433005;
    uint256 constant IC4y = 21091396295200083161363697039830865943762788335711072967082811732416412142212;
    
    uint256 constant IC5x = 3277805223442060778292405741942548007218490041051348547437304074109624107356;
    uint256 constant IC5y = 14423944753390168508001610935122911632893435927783118919600891838924075393335;
    
    uint256 constant IC6x = 16279740598746831017838829127065220413108847820004536437353222843036288927209;
    uint256 constant IC6y = 11934056246616513677892280054066225650223628502415902228226616908265848867449;
    
    uint256 constant IC7x = 5071131858486439523644545889310168311903353944707113398976996997278587799687;
    uint256 constant IC7y = 11022965843210062064457659632129711893317662131236104884153566306811626505122;
    
    uint256 constant IC8x = 19131780283367531273448020668619041357172962162156115675741827445246630873287;
    uint256 constant IC8y = 10224436589841763650559926912214172567856653421053590774767009207269607380898;
    
    uint256 constant IC9x = 9015890207964856811111785067351720194541561850029096381425406768947368358563;
    uint256 constant IC9y = 6047643904429654109574184105636835293535463759429215740849034643735922891159;
    
    uint256 constant IC10x = 14203417831592538293633573944212232646895161398477212007798306234115933198031;
    uint256 constant IC10y = 16402598342815946882326203254821041228554468765346033642071484587006914175418;
    
    uint256 constant IC11x = 20547058030012031602382050197843576579725635037139342207584317836070120910810;
    uint256 constant IC11y = 18032163858711245709516724511475426102219042616668426511217798974437856519723;
    
    uint256 constant IC12x = 148439843878200889608411203087042067351611646430696078100079098168514978714;
    uint256 constant IC12y = 9307113381205316554384865850704068163340346564569932871492676068849222362101;
    
    uint256 constant IC13x = 21753481289618352374517009260504147501427757590648179575845005895425333005720;
    uint256 constant IC13y = 15435923224398640375717587240417911857458317269020496236194087111795302601904;
    
    uint256 constant IC14x = 15556836099875422007583907774078621468033908465380872159150755233143098695951;
    uint256 constant IC14y = 1129744811704326861736580949783332840905388382080396668503461990830533174097;
    
    uint256 constant IC15x = 13442230315665714018082790733663853073869607935268797374915472095839891294991;
    uint256 constant IC15y = 6217288894318109502763318183559473125294772219565374069029777927475585687108;
    
    uint256 constant IC16x = 13992512973627636194543618755294557224102658899504040367095379192332931057711;
    uint256 constant IC16y = 5489859536562727184655955989301069690715491550780438666774255315815483859767;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[16] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations โ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/tokens/FeeERC20.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {SimpleERC20} from "./SimpleERC20.sol";

/**
 * @title FeeERC20
 * @dev ERC20 token with a fee mechanism for testing
 */
contract FeeERC20 is SimpleERC20 {
    uint256 public feeRate;
    address public feeCollector;

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimal,
        uint256 feeRates,
        address feeCollectors
    ) SimpleERC20(name, symbol, decimal) {
        feeRate = feeRates;
        feeCollector = feeCollectors;
    }

    /**
     * @dev Override transferFrom to apply a fee
     * @param sender The address to transfer from
     * @param recipient The address to transfer to
     * @param amount The amount to transfer
     * @return A boolean that indicates if the operation was successful
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = _msgSender();

        // Calculate fee
        uint256 fee = (amount * feeRate) / 100;
        uint256 amountAfterFee = amount - fee;

        // Deduct allowance
        _spendAllowance(sender, spender, amount);

        // Transfer amount after fee to recipient
        _transfer(sender, recipient, amountAfterFee);

        // Transfer fee to fee collector
        if (fee > 0) {
            _transfer(sender, feeCollector, fee);
        }

        return true;
    }
}



================================================
FILE: contracts/tokens/SimpleERC20.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract SimpleERC20 is ERC20 {
    // token decimals
    uint8 public decimals_;

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimal
    ) ERC20(name, symbol) {
        decimals_ = decimal;
    }

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }

    function decimals() public view virtual override returns (uint8) {
        return decimals_;
    }
}



================================================
FILE: contracts/tokens/TokenTracker.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {Ownable2Step, Ownable} from "@openzeppelin/contracts/access/Ownable2Step.sol";
import {TokenBlacklisted, InvalidOperation} from "../errors/Errors.sol";

/**
 * @title TokenTracker
 * @notice Contract for tracking ERC20 tokens in the encrypted ERC system
 * @dev This contract manages:
 *      1. Token registration and identification
 *      2. Token blacklisting for security
 *      3. Contract Mode (converter vs standalone)
 *
 * The contract can operate in two modes:
 * - Converter Mode: Wraps existing ERC20 tokens into encrypted tokens
 * - Standalone Mode: Operates as a standalone encrypted token
 */
contract TokenTracker is Ownable2Step {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice The next available token ID
    /// @dev Token IDs start from 1, with 0 reserved for the standalone version
    uint256 public nextTokenId = 1;

    /// @notice Indicates if the contract is operating in converter mode
    bool public isConverter;

    /// @notice Mapping from token address to token ID
    mapping(address tokenAddress => uint256 tokenId) public tokenIds;

    /// @notice Mapping from token ID to token address
    mapping(uint256 tokenId => address tokenAddress) public tokenAddresses;

    /// @notice Array of all registered token addresses
    address[] public tokens;

    /// @notice Mapping to track blacklisted tokens
    mapping(address tokenAddress => bool isBlacklisted)
        public blacklistedTokens;

    ///////////////////////////////////////////////////
    ///                   Modifiers                 ///
    ///////////////////////////////////////////////////

    /**
     * @notice Ensures the function is only called in converter mode
     * @dev Reverts with InvalidOperation if called in standalone mode
     */
    modifier onlyForConverter() {
        if (!isConverter) {
            revert InvalidOperation();
        }
        _;
    }

    /**
     * @notice Ensures the function is only called in standalone mode
     * @dev Reverts with InvalidOperation if called in converter mode
     */
    modifier onlyForStandalone() {
        if (isConverter) {
            revert InvalidOperation();
        }
        _;
    }

    /**
     * @notice Ensures the token is not blacklisted
     * @param tokenAddress Address of the token to check
     * @dev Reverts with TokenBlacklisted if the token is blacklisted
     */
    modifier revertIfBlacklisted(address tokenAddress) {
        if (blacklistedTokens[tokenAddress]) {
            revert TokenBlacklisted(tokenAddress);
        }
        _;
    }

    ///////////////////////////////////////////////////
    ///                   Constructor               ///
    ///////////////////////////////////////////////////

    /**
     * @notice Initializes the TokenTracker contract
     * @param isConverter_ Determines if the contract operates in converter mode
     * @dev Sets the initial mode of operation and initializes the owner
     */
    constructor(bool isConverter_) Ownable(msg.sender) {
        isConverter = isConverter_;
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Sets the blacklist status of a token
     * @param token Address of the token to blacklist/unblacklist
     * @param blacklisted True to blacklist, false to unblacklist
     * @dev Only the owner can call this function
     */
    function setTokenBlacklist(
        address token,
        bool blacklisted
    ) external onlyOwner {
        blacklistedTokens[token] = blacklisted;
    }

    /**
     * @notice Returns an array of all registered token addresses
     * @return Array of token addresses
     * @dev Used for enumeration and listing all supported tokens
     */
    function getTokens() external view returns (address[] memory) {
        return tokens;
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Adds a new token to the tracker
     * @param tokenAddress Address of the token to add
     * @dev This function:
     *      1. Assigns a new token ID
     *      2. Updates the token mappings
     *      3. Adds the token to the tokens array
     *      4. Increments the next token ID
     */
    function _addToken(address tokenAddress) internal {
        uint256 newTokenId = nextTokenId;
        tokenIds[tokenAddress] = newTokenId;
        tokenAddresses[newTokenId] = tokenAddress;
        tokens.push(tokenAddress);
        nextTokenId++;
    }
}



================================================
FILE: contracts/types/Types.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

struct Point {
    uint256 x;
    uint256 y;
}

struct CreateEncryptedERCParams {
    // registrar contract address for fetching users public key
    address registrar;
    // eERC is converter mode or not
    bool isConverter;
    // eERC Token
    string name;
    string symbol;
    uint8 decimals;
    // verifiers
    address mintVerifier;
    address withdrawVerifier;
    address transferVerifier;
    address burnVerifier;
}

struct AmountPCT {
    uint256[7] pct;
    uint256 index;
}

struct EncryptedBalance {
    EGCT eGCT;
    mapping(uint256 index => BalanceHistory history) balanceList;
    uint256 nonce;
    uint256 transactionIndex;
    uint256[7] balancePCT; // user balance pcts
    AmountPCT[] amountPCTs; // user amount pcts
}

struct BalanceHistory {
    uint256 index;
    bool isValid;
}

struct EGCT {
    Point c1;
    Point c2;
}

/// @dev The proof base is used to verify the proof
struct ProofPoints {
    uint256[2] a;
    uint256[2][2] b;
    uint256[2] c;
}

struct RegisterProof {
    ProofPoints proofPoints;
    uint256[5] publicSignals;
}

struct MintProof {
    ProofPoints proofPoints;
    uint256[24] publicSignals;
}

struct TransferProof {
    ProofPoints proofPoints;
    uint256[32] publicSignals;
}

struct BurnProof {
    ProofPoints proofPoints;
    uint256[19] publicSignals;
}

struct WithdrawProof {
    ProofPoints proofPoints;
    uint256[16] publicSignals;
}

struct TransferInputs {
    EGCT providedBalance;
    EGCT senderEncryptedAmount;
    EGCT receiverEncryptedAmount;
    uint256[7] amountPCT;
}

struct Metadata {
    address messageFrom;
    address messageTo;
    string messageType;
    bytes encryptedMsg;
}



================================================
FILE: contracts/verifiers/BurnCircuitGroth16Verifier.sol
================================================
// SPDX-License-Identifier: MIT

/* AUTOGENERATED FILE BY HARDHAT-ZKIT. DO NOT EDIT. */

pragma solidity >=0.7.0 <0.9.0;

contract BurnCircuitGroth16Verifier {
    // @dev scalar field size
    uint256 public constant SCALAR_FIELD_SIZE =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    /// @dev base field size
    uint256 public constant BASE_FIELD_SIZE =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    /// @dev verification key data
    uint256 public constant ALPHA_X =
        20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 public constant ALPHA_Y =
        9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 public constant BETA_X1 =
        4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 public constant BETA_X2 =
        6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 public constant BETA_Y1 =
        21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 public constant BETA_Y2 =
        10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 public constant GAMMA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant GAMMA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant GAMMA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant GAMMA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 public constant DELTA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant DELTA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant DELTA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant DELTA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;

    uint256 public constant IC0_X =
        6901175356638081608311197414548846861180656487838344346821425826024891512425;
    uint256 public constant IC0_Y =
        16944064565335445729234872967061190126362989003416853826016805426130180238191;
    uint256 public constant IC1_X =
        17908121343774581376092646765067170799970925894057937307165335210962871507135;
    uint256 public constant IC1_Y =
        6739483966006459958647545663755815825611388802168101513616676265213547687212;
    uint256 public constant IC2_X =
        766312427469543414624781412742178740436577019446000599209144238628925292414;
    uint256 public constant IC2_Y =
        11956596380120466965959213032841211036588141256244479446912141909087743946449;
    uint256 public constant IC3_X =
        9834218022277006635455703178457965188100848955744692108208207593466809819916;
    uint256 public constant IC3_Y =
        5985476150835890762503639978680541204908901815001963876083809679448099772187;
    uint256 public constant IC4_X =
        14827234556798753501841602996273223453620286706976793196274886644504394417263;
    uint256 public constant IC4_Y =
        17185284608112950506629319460803937653685676730131697135772583956246683209368;
    uint256 public constant IC5_X =
        17529671244301122497049371127369274616617935801308036584230660946886543200270;
    uint256 public constant IC5_Y =
        21375965875653643781871988041044406562099360028820246922430008152355558076267;
    uint256 public constant IC6_X =
        2071394549783234155236090578090590694025714713435714686283263242515370887037;
    uint256 public constant IC6_Y =
        1360924170815016231172148644602657489538698591468910875031083731851187567999;
    uint256 public constant IC7_X =
        10294779462906061052931321788054691400173934802237652306928745571023248394387;
    uint256 public constant IC7_Y =
        6555248292739776048079409559973894167013450042783785080733702895769749566613;
    uint256 public constant IC8_X =
        4433257889246655161353853222728772973385032114589816543634201923482683435584;
    uint256 public constant IC8_Y =
        14737241692493285661348398748630216205024305186831037514190361703045651615269;
    uint256 public constant IC9_X =
        14662929317288257322870633955431196105372083992377701985085624881517883523163;
    uint256 public constant IC9_Y =
        13045157851276202363238319024416490799176208505845980771766086158756862458455;
    uint256 public constant IC10_X =
        10464607531594481747431773960796216724225398526452385781876076453050117351904;
    uint256 public constant IC10_Y =
        17227459943128246860971844058080372581110192073599679941420162883374908732283;
    uint256 public constant IC11_X =
        745839102907798772556197076666683733791895469218705021459706695701505037999;
    uint256 public constant IC11_Y =
        11282995679713265974084133361652481201591627543141168082075682177048149337453;
    uint256 public constant IC12_X =
        17929575843708091862123276864146152761508698565499701379217956191629740643940;
    uint256 public constant IC12_Y =
        19694868618398715637769102075783868212304717698983166562284533403937378692315;
    uint256 public constant IC13_X =
        19788140654052540486857453303544057569825570368720987020309299320004547960581;
    uint256 public constant IC13_Y =
        6883822212531810402176678585679740471039138816982867861815020183660906571642;
    uint256 public constant IC14_X =
        6016243318855719046735289125777883097005663608233773332990082345142498280371;
    uint256 public constant IC14_Y =
        21204516959587943017810864594613242220785397660490599724380523851223540954454;
    uint256 public constant IC15_X =
        9891573095652303648634434897797773521123041746620991186215470158961116717665;
    uint256 public constant IC15_Y =
        15129361566109667756079905439551006265474721391302786501924664404711249139905;
    uint256 public constant IC16_X =
        9439270817025434198507441583978754692817321436471324362734438362897111301924;
    uint256 public constant IC16_Y =
        17736726489009951896104159456871058989709210357063650885766330312145063724146;
    uint256 public constant IC17_X =
        7287813417026604917333767312326818451716773551965506932628922979658721400484;
    uint256 public constant IC17_Y =
        21190069513632277449640126663995547292551888059992765226941465993312580710136;
    uint256 public constant IC18_X =
        18870427155174730509179857527710685647524233977259143240992234215761896727263;
    uint256 public constant IC18_Y =
        21595208618611453816106702920660402890633778123650117008434425697322727495324;
    uint256 public constant IC19_X =
        2474736367332117814843921180480737874685068379574560055026846626150944220277;
    uint256 public constant IC19_Y =
        11798959751686284671429858411798094190882362783079508053655067482307321072055;
    
    /// @dev memory pointer sizes
    uint16 public constant P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE = 128;
    uint16 public constant P_TOTAL_SIZE = 896;

    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[19] memory publicSignals_
    ) public view returns (bool verified_) {
        assembly {
            function checkField(signal_) -> res_ {
                res_ := lt(signal_, SCALAR_FIELD_SIZE)
            }

            function g1MulAdd(pR_, x_, y_, s_) -> res_ {
                let pointer_ := mload(64) // free pointer

                mstore(pointer_, x_)
                mstore(add(pointer_, 32), y_)
                mstore(add(pointer_, 64), s_)

                res_ := staticcall(6000, 7, pointer_, 96, pointer_, 64) // ecMul
                res_ := and(res_, gt(returndatasize(), 0)) // check that multiplication succeeded

                if iszero(res_) {
                    leave
                }

                mstore(add(pointer_, 64), mload(pR_))
                mstore(add(pointer_, 96), mload(add(pR_, 32)))

                res_ := staticcall(150, 6, pointer_, 128, pR_, 64) // ecAdd
                res_ := and(res_, gt(returndatasize(), 0)) // check that addition succeeded
            }

            function checkPairing(pA_, pB_, pC_, pubSignals_, pointer_) -> res_ {
                let pPairing_ := add(pointer_, P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE)

                mstore(pointer_, IC0_X)
                mstore(add(pointer_, 32), IC0_Y)

                /// @dev compute the linear combination of public signals
                if iszero(g1MulAdd(pointer_, IC1_X, IC1_Y, mload(add(pubSignals_, 0)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC2_X, IC2_Y, mload(add(pubSignals_, 32)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC3_X, IC3_Y, mload(add(pubSignals_, 64)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC4_X, IC4_Y, mload(add(pubSignals_, 96)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC5_X, IC5_Y, mload(add(pubSignals_, 128)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC6_X, IC6_Y, mload(add(pubSignals_, 160)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC7_X, IC7_Y, mload(add(pubSignals_, 192)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC8_X, IC8_Y, mload(add(pubSignals_, 224)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC9_X, IC9_Y, mload(add(pubSignals_, 256)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC10_X, IC10_Y, mload(add(pubSignals_, 288)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC11_X, IC11_Y, mload(add(pubSignals_, 320)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC12_X, IC12_Y, mload(add(pubSignals_, 352)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC13_X, IC13_Y, mload(add(pubSignals_, 384)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC14_X, IC14_Y, mload(add(pubSignals_, 416)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC15_X, IC15_Y, mload(add(pubSignals_, 448)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC16_X, IC16_Y, mload(add(pubSignals_, 480)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC17_X, IC17_Y, mload(add(pubSignals_, 512)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC18_X, IC18_Y, mload(add(pubSignals_, 544)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC19_X, IC19_Y, mload(add(pubSignals_, 576)))) {
                    leave
                }
                
                /// @dev -A
                mstore(pPairing_, mload(pA_))
                mstore(
                    add(pPairing_, 32),
                    mod(sub(BASE_FIELD_SIZE, mload(add(pA_, 32))), BASE_FIELD_SIZE)
                )

                /// @dev B
                mstore(add(pPairing_, 64), mload(mload(pB_)))
                mstore(add(pPairing_, 96), mload(add(mload(pB_), 32)))
                mstore(add(pPairing_, 128), mload(mload(add(pB_, 32))))
                mstore(add(pPairing_, 160), mload(add(mload(add(pB_, 32)), 32)))

                /// @dev alpha1
                mstore(add(pPairing_, 192), ALPHA_X)
                mstore(add(pPairing_, 224), ALPHA_Y)

                /// @dev beta2
                mstore(add(pPairing_, 256), BETA_X1)
                mstore(add(pPairing_, 288), BETA_X2)
                mstore(add(pPairing_, 320), BETA_Y1)
                mstore(add(pPairing_, 352), BETA_Y2)

                /// @dev public signals
                mstore(add(pPairing_, 384), mload(pointer_))
                mstore(add(pPairing_, 416), mload(add(pointer_, 32)))

                /// @dev gamma2
                mstore(add(pPairing_, 448), GAMMA_X1)
                mstore(add(pPairing_, 480), GAMMA_X2)
                mstore(add(pPairing_, 512), GAMMA_Y1)
                mstore(add(pPairing_, 544), GAMMA_Y2)

                /// @dev C
                mstore(add(pPairing_, 576), mload(pC_))
                mstore(add(pPairing_, 608), mload(add(pC_, 32)))

                /// @dev delta2
                mstore(add(pPairing_, 640), DELTA_X1)
                mstore(add(pPairing_, 672), DELTA_X2)
                mstore(add(pPairing_, 704), DELTA_Y1)
                mstore(add(pPairing_, 736), DELTA_Y2)

                res_ := staticcall(181000, 8, pPairing_, 768, pPairing_, 32) // ecPairing
                res_ := and(res_, mload(pPairing_)) // check that pairing succeeded
            }

            let pointer_ := mload(64) // free pointer
            mstore(64, add(pointer_, P_TOTAL_SIZE))

            /// @dev check that all public signals are in F
            verified_ := 1
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 0))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 32))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 64))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 96))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 128))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 160))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 192))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 224))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 256))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 288))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 320))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 352))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 384))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 416))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 448))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 480))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 512))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 544))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 576))))
            
            /// @dev check pairings
            if not(iszero(verified_)) {
                verified_ := checkPairing(pointA_, pointB_, pointC_, publicSignals_, pointer_)
            }
        }
    }
}



================================================
FILE: contracts/verifiers/MintCircuitGroth16Verifier.sol
================================================
// SPDX-License-Identifier: MIT

/* AUTOGENERATED FILE BY HARDHAT-ZKIT. DO NOT EDIT. */

pragma solidity >=0.7.0 <0.9.0;

contract MintCircuitGroth16Verifier {
    // @dev scalar field size
    uint256 public constant SCALAR_FIELD_SIZE =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    /// @dev base field size
    uint256 public constant BASE_FIELD_SIZE =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    /// @dev verification key data
    uint256 public constant ALPHA_X =
        20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 public constant ALPHA_Y =
        9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 public constant BETA_X1 =
        4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 public constant BETA_X2 =
        6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 public constant BETA_Y1 =
        21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 public constant BETA_Y2 =
        10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 public constant GAMMA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant GAMMA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant GAMMA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant GAMMA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 public constant DELTA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant DELTA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant DELTA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant DELTA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;

    uint256 public constant IC0_X =
        10121904041541460154551260390411876526139574666949788432677764574044027742051;
    uint256 public constant IC0_Y =
        6395114105467352463516423639828272877440036954754220055848039516989817256674;
    uint256 public constant IC1_X =
        5586762719201810155133862083740714325655748243483738877755810028542797644739;
    uint256 public constant IC1_Y =
        9387879719287370926595730382657598610335084850078203728936667449453246554359;
    uint256 public constant IC2_X =
        19420434315212518030589186167981244595406343548992012458488730749825996100239;
    uint256 public constant IC2_Y =
        3482657374383353276279298693752239555763142972311841530862645391131143881873;
    uint256 public constant IC3_X =
        21667521945257749121492909465236139091096077691835364325355606431375269082282;
    uint256 public constant IC3_Y =
        12156175257782822331801928906256367913221851960540994586932487722549923413345;
    uint256 public constant IC4_X =
        16828357126590671631798447095302651492589140460428270542352941484237941156483;
    uint256 public constant IC4_Y =
        3785759973408012513975276660945174958105045591429994983968533282503371539336;
    uint256 public constant IC5_X =
        21244321325522105477060254124915502034148248502931960755663601081500950076300;
    uint256 public constant IC5_Y =
        14687177467139662957844534389099557537735007475047254307829149459337997284150;
    uint256 public constant IC6_X =
        21404447565616225355770439075122853382066792760583316781611395109968504614761;
    uint256 public constant IC6_Y =
        3777910210505077428584254669424713454396973987622630869249106067166590299357;
    uint256 public constant IC7_X =
        5644690004940482546460856256670502914882531219591199090065888636589494736039;
    uint256 public constant IC7_Y =
        16345970805899097192278870928687506101715169625232631539981164972434652655022;
    uint256 public constant IC8_X =
        16593367704572145491497340027058421406291597779030039134573703992464863830646;
    uint256 public constant IC8_Y =
        19275772679724763916884927502599327291258343548738975909520313332884772129528;
    uint256 public constant IC9_X =
        18338635157990571739660769292280252719367811451620901782236478705200001456515;
    uint256 public constant IC9_Y =
        12580365946981294431067603413481570211192375767222833113101936660967490853342;
    uint256 public constant IC10_X =
        19880773599746588943745194809450382516728304373879942615347513263173728275196;
    uint256 public constant IC10_Y =
        128548754750873577554444615682746852358621588347676854260473817368140033519;
    uint256 public constant IC11_X =
        6476719107464483530164368276818653110527411272303410163053488615734788766586;
    uint256 public constant IC11_Y =
        13331539055996208679678758084320772815107338352425913859433335410845899223811;
    uint256 public constant IC12_X =
        17393436839515851750885277096607160266036302533767007170590322671069079326483;
    uint256 public constant IC12_Y =
        17336491525577930609097646312281682071744277090982994234361498925040239739760;
    uint256 public constant IC13_X =
        14059139663320156276001577403575266145309546640724899667521029234074221180403;
    uint256 public constant IC13_Y =
        5963232262834884334488206091864494084893490405377454589196552297795638041488;
    uint256 public constant IC14_X =
        13813470258321934033051704279698252148783024920181797002453328082368105474789;
    uint256 public constant IC14_Y =
        19760333797981660449134124218356560284106192590380149679255903109561686546313;
    uint256 public constant IC15_X =
        11858117840318587547791069185551586430435948995333725070770764697634898894992;
    uint256 public constant IC15_Y =
        16621799951101200543458233987158204772158254202860685491749532125765298740749;
    uint256 public constant IC16_X =
        13584356250500421508084566767718022822120888453124821650989966819848963029582;
    uint256 public constant IC16_Y =
        21121442557480691564262522113115528175177021588076736568194595390503813944019;
    uint256 public constant IC17_X =
        4326226245481542040767942040881999777137473163343274779447151141265545792486;
    uint256 public constant IC17_Y =
        21183580388477113613358837765893868421637670220571970210021457037640835173809;
    uint256 public constant IC18_X =
        2704745980008452624320271214496436840853635777289985169457654318338905712053;
    uint256 public constant IC18_Y =
        5498942242451865915343845370075402718280213375705928811712272696867696623122;
    uint256 public constant IC19_X =
        18021323881247358977456866382503667963535769536490271165761105041938333860259;
    uint256 public constant IC19_Y =
        15056011404667104875167366478630077579580289596849055349190254216447781136049;
    uint256 public constant IC20_X =
        2428670635260390602473903592482933886252233168437493591205178349351514000281;
    uint256 public constant IC20_Y =
        862350060646299115005420081148519933461348146447694025974629367115211964519;
    uint256 public constant IC21_X =
        20557922324599650576215164022162024912213509843003042307546636524489843547931;
    uint256 public constant IC21_Y =
        1061522392679391742130691544383963509531829000498209937975610885874122363387;
    uint256 public constant IC22_X =
        9114256858842496488535186312068922854228150055952688114444862375910254881995;
    uint256 public constant IC22_Y =
        20868937436899006110617091404782344741103549613810098330797141428653796030423;
    uint256 public constant IC23_X =
        392332888128429361037702708407695212788446855280618226506466973682041689462;
    uint256 public constant IC23_Y =
        10986782868722900357976121669302445297980271976862420955075995610762868745084;
    uint256 public constant IC24_X =
        12335561474727855982123382035622477594232361573497391299243618736725476900631;
    uint256 public constant IC24_Y =
        20340286770637453607265533856091115758478742882346824576410498508028320071146;
    
    /// @dev memory pointer sizes
    uint16 public constant P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE = 128;
    uint16 public constant P_TOTAL_SIZE = 896;

    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[24] memory publicSignals_
    ) public view returns (bool verified_) {
        assembly {
            function checkField(signal_) -> res_ {
                res_ := lt(signal_, SCALAR_FIELD_SIZE)
            }

            function g1MulAdd(pR_, x_, y_, s_) -> res_ {
                let pointer_ := mload(64) // free pointer

                mstore(pointer_, x_)
                mstore(add(pointer_, 32), y_)
                mstore(add(pointer_, 64), s_)

                res_ := staticcall(6000, 7, pointer_, 96, pointer_, 64) // ecMul
                res_ := and(res_, gt(returndatasize(), 0)) // check that multiplication succeeded

                if iszero(res_) {
                    leave
                }

                mstore(add(pointer_, 64), mload(pR_))
                mstore(add(pointer_, 96), mload(add(pR_, 32)))

                res_ := staticcall(150, 6, pointer_, 128, pR_, 64) // ecAdd
                res_ := and(res_, gt(returndatasize(), 0)) // check that addition succeeded
            }

            function checkPairing(pA_, pB_, pC_, pubSignals_, pointer_) -> res_ {
                let pPairing_ := add(pointer_, P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE)

                mstore(pointer_, IC0_X)
                mstore(add(pointer_, 32), IC0_Y)

                /// @dev compute the linear combination of public signals
                if iszero(g1MulAdd(pointer_, IC1_X, IC1_Y, mload(add(pubSignals_, 0)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC2_X, IC2_Y, mload(add(pubSignals_, 32)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC3_X, IC3_Y, mload(add(pubSignals_, 64)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC4_X, IC4_Y, mload(add(pubSignals_, 96)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC5_X, IC5_Y, mload(add(pubSignals_, 128)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC6_X, IC6_Y, mload(add(pubSignals_, 160)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC7_X, IC7_Y, mload(add(pubSignals_, 192)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC8_X, IC8_Y, mload(add(pubSignals_, 224)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC9_X, IC9_Y, mload(add(pubSignals_, 256)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC10_X, IC10_Y, mload(add(pubSignals_, 288)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC11_X, IC11_Y, mload(add(pubSignals_, 320)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC12_X, IC12_Y, mload(add(pubSignals_, 352)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC13_X, IC13_Y, mload(add(pubSignals_, 384)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC14_X, IC14_Y, mload(add(pubSignals_, 416)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC15_X, IC15_Y, mload(add(pubSignals_, 448)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC16_X, IC16_Y, mload(add(pubSignals_, 480)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC17_X, IC17_Y, mload(add(pubSignals_, 512)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC18_X, IC18_Y, mload(add(pubSignals_, 544)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC19_X, IC19_Y, mload(add(pubSignals_, 576)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC20_X, IC20_Y, mload(add(pubSignals_, 608)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC21_X, IC21_Y, mload(add(pubSignals_, 640)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC22_X, IC22_Y, mload(add(pubSignals_, 672)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC23_X, IC23_Y, mload(add(pubSignals_, 704)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC24_X, IC24_Y, mload(add(pubSignals_, 736)))) {
                    leave
                }
                
                /// @dev -A
                mstore(pPairing_, mload(pA_))
                mstore(
                    add(pPairing_, 32),
                    mod(sub(BASE_FIELD_SIZE, mload(add(pA_, 32))), BASE_FIELD_SIZE)
                )

                /// @dev B
                mstore(add(pPairing_, 64), mload(mload(pB_)))
                mstore(add(pPairing_, 96), mload(add(mload(pB_), 32)))
                mstore(add(pPairing_, 128), mload(mload(add(pB_, 32))))
                mstore(add(pPairing_, 160), mload(add(mload(add(pB_, 32)), 32)))

                /// @dev alpha1
                mstore(add(pPairing_, 192), ALPHA_X)
                mstore(add(pPairing_, 224), ALPHA_Y)

                /// @dev beta2
                mstore(add(pPairing_, 256), BETA_X1)
                mstore(add(pPairing_, 288), BETA_X2)
                mstore(add(pPairing_, 320), BETA_Y1)
                mstore(add(pPairing_, 352), BETA_Y2)

                /// @dev public signals
                mstore(add(pPairing_, 384), mload(pointer_))
                mstore(add(pPairing_, 416), mload(add(pointer_, 32)))

                /// @dev gamma2
                mstore(add(pPairing_, 448), GAMMA_X1)
                mstore(add(pPairing_, 480), GAMMA_X2)
                mstore(add(pPairing_, 512), GAMMA_Y1)
                mstore(add(pPairing_, 544), GAMMA_Y2)

                /// @dev C
                mstore(add(pPairing_, 576), mload(pC_))
                mstore(add(pPairing_, 608), mload(add(pC_, 32)))

                /// @dev delta2
                mstore(add(pPairing_, 640), DELTA_X1)
                mstore(add(pPairing_, 672), DELTA_X2)
                mstore(add(pPairing_, 704), DELTA_Y1)
                mstore(add(pPairing_, 736), DELTA_Y2)

                res_ := staticcall(181000, 8, pPairing_, 768, pPairing_, 32) // ecPairing
                res_ := and(res_, mload(pPairing_)) // check that pairing succeeded
            }

            let pointer_ := mload(64) // free pointer
            mstore(64, add(pointer_, P_TOTAL_SIZE))

            /// @dev check that all public signals are in F
            verified_ := 1
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 0))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 32))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 64))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 96))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 128))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 160))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 192))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 224))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 256))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 288))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 320))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 352))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 384))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 416))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 448))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 480))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 512))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 544))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 576))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 608))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 640))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 672))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 704))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 736))))
            
            /// @dev check pairings
            if not(iszero(verified_)) {
                verified_ := checkPairing(pointA_, pointB_, pointC_, publicSignals_, pointer_)
            }
        }
    }
}



================================================
FILE: contracts/verifiers/RegistrationCircuitGroth16Verifier.sol
================================================
// SPDX-License-Identifier: MIT

/* AUTOGENERATED FILE BY HARDHAT-ZKIT. DO NOT EDIT. */

pragma solidity >=0.7.0 <0.9.0;

contract RegistrationCircuitGroth16Verifier {
    // @dev scalar field size
    uint256 public constant SCALAR_FIELD_SIZE =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    /// @dev base field size
    uint256 public constant BASE_FIELD_SIZE =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    /// @dev verification key data
    uint256 public constant ALPHA_X =
        20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 public constant ALPHA_Y =
        9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 public constant BETA_X1 =
        4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 public constant BETA_X2 =
        6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 public constant BETA_Y1 =
        21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 public constant BETA_Y2 =
        10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 public constant GAMMA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant GAMMA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant GAMMA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant GAMMA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 public constant DELTA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant DELTA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant DELTA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant DELTA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;

    uint256 public constant IC0_X =
        4004410872179300339480249405398939298715031489893009961199535208964457923750;
    uint256 public constant IC0_Y =
        11142026210898871476346451274761099606196839371161747578101583645702654533240;
    uint256 public constant IC1_X =
        14970325264892984291437720194401230916657388050759523602370378142660744831477;
    uint256 public constant IC1_Y =
        15860538555168123807647719982845297214031403618163443664157964964439662885432;
    uint256 public constant IC2_X =
        2280562765509182195246897364500489648120102222444059313572774422753200337271;
    uint256 public constant IC2_Y =
        7147694953124310609924568435428058789638619830198023240430532891482445253803;
    uint256 public constant IC3_X =
        7737404298715916349870992960929602974683638711993694006376159661700137192127;
    uint256 public constant IC3_Y =
        7116770325362339113448473214465082117296435085200119804036017348236401720128;
    uint256 public constant IC4_X =
        3130277824222995531291107528843021785954629147236040284065307643519664903928;
    uint256 public constant IC4_Y =
        11742475342174768235971584303810158858484260897318069476115756668898865449280;
    uint256 public constant IC5_X =
        14791539702458079086636207858304521437578092734215012107895193807307152746110;
    uint256 public constant IC5_Y =
        12489284483607948781669905789845942689563255773386215312172350852214666005897;
    
    /// @dev memory pointer sizes
    uint16 public constant P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE = 128;
    uint16 public constant P_TOTAL_SIZE = 896;

    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[5] memory publicSignals_
    ) public view returns (bool verified_) {
        assembly {
            function checkField(signal_) -> res_ {
                res_ := lt(signal_, SCALAR_FIELD_SIZE)
            }

            function g1MulAdd(pR_, x_, y_, s_) -> res_ {
                let pointer_ := mload(64) // free pointer

                mstore(pointer_, x_)
                mstore(add(pointer_, 32), y_)
                mstore(add(pointer_, 64), s_)

                res_ := staticcall(6000, 7, pointer_, 96, pointer_, 64) // ecMul
                res_ := and(res_, gt(returndatasize(), 0)) // check that multiplication succeeded

                if iszero(res_) {
                    leave
                }

                mstore(add(pointer_, 64), mload(pR_))
                mstore(add(pointer_, 96), mload(add(pR_, 32)))

                res_ := staticcall(150, 6, pointer_, 128, pR_, 64) // ecAdd
                res_ := and(res_, gt(returndatasize(), 0)) // check that addition succeeded
            }

            function checkPairing(pA_, pB_, pC_, pubSignals_, pointer_) -> res_ {
                let pPairing_ := add(pointer_, P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE)

                mstore(pointer_, IC0_X)
                mstore(add(pointer_, 32), IC0_Y)

                /// @dev compute the linear combination of public signals
                if iszero(g1MulAdd(pointer_, IC1_X, IC1_Y, mload(add(pubSignals_, 0)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC2_X, IC2_Y, mload(add(pubSignals_, 32)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC3_X, IC3_Y, mload(add(pubSignals_, 64)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC4_X, IC4_Y, mload(add(pubSignals_, 96)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC5_X, IC5_Y, mload(add(pubSignals_, 128)))) {
                    leave
                }
                
                /// @dev -A
                mstore(pPairing_, mload(pA_))
                mstore(
                    add(pPairing_, 32),
                    mod(sub(BASE_FIELD_SIZE, mload(add(pA_, 32))), BASE_FIELD_SIZE)
                )

                /// @dev B
                mstore(add(pPairing_, 64), mload(mload(pB_)))
                mstore(add(pPairing_, 96), mload(add(mload(pB_), 32)))
                mstore(add(pPairing_, 128), mload(mload(add(pB_, 32))))
                mstore(add(pPairing_, 160), mload(add(mload(add(pB_, 32)), 32)))

                /// @dev alpha1
                mstore(add(pPairing_, 192), ALPHA_X)
                mstore(add(pPairing_, 224), ALPHA_Y)

                /// @dev beta2
                mstore(add(pPairing_, 256), BETA_X1)
                mstore(add(pPairing_, 288), BETA_X2)
                mstore(add(pPairing_, 320), BETA_Y1)
                mstore(add(pPairing_, 352), BETA_Y2)

                /// @dev public signals
                mstore(add(pPairing_, 384), mload(pointer_))
                mstore(add(pPairing_, 416), mload(add(pointer_, 32)))

                /// @dev gamma2
                mstore(add(pPairing_, 448), GAMMA_X1)
                mstore(add


Directory structure:
โโโ ava-labs-encryptederc/
    โโโ README.md
    โโโ biome.json
    โโโ hardhat.config.ts
    โโโ LICENSE.md
    โโโ package.json
    โโโ tsconfig.json
    โโโ .env.example
    โโโ .nvmrc
    โโโ .prettierignore
    โโโ .prettierrc
    โโโ .solcover.js
    โโโ .solhint.json
    โโโ .solhintignore
    โโโ circom/
    โ   โโโ burn.circom
    โ   โโโ components.circom
    โ   โโโ mint.circom
    โ   โโโ registration.circom
    โ   โโโ transfer.circom
    โ   โโโ withdraw.circom
    โ   โโโ circomlib/
    โ       โโโ aliascheck.circom
    โ       โโโ babyjub.circom
    โ       โโโ bitify.circom
    โ       โโโ comparators.circom
    โ       โโโ compconstant.circom
    โ       โโโ escalarmulany.circom
    โ       โโโ escalarmulfix.circom
    โ       โโโ montgomery.circom
    โ       โโโ mux3.circom
    โ       โโโ poseidon.circom
    โ       โโโ poseidon_old.circom
    โโโ contracts/
    โ   โโโ EncryptedERC.sol
    โ   โโโ EncryptedUserBalances.sol
    โ   โโโ Registrar.sol
    โ   โโโ auditor/
    โ   โ   โโโ AuditorManager.sol
    โ   โโโ errors/
    โ   โ   โโโ Errors.sol
    โ   โโโ interfaces/
    โ   โ   โโโ IEncryptedERC.sol
    โ   โ   โโโ IRegistrar.sol
    โ   โ   โโโ verifiers/
    โ   โ       โโโ IBurnVerifier.sol
    โ   โ       โโโ IMintVerifier.sol
    โ   โ       โโโ IRegistrationVerifier.sol
    โ   โ       โโโ ITransferVerifier.sol
    โ   โ       โโโ IWithdrawVerifier.sol
    โ   โโโ libraries/
    โ   โ   โโโ BabyJubJub.sol
    โ   โโโ metadata/
    โ   โ   โโโ EncryptedMetadata.sol
    โ   โ   โโโ IEncryptedMetadata.sol
    โ   โโโ prod/
    โ   โ   โโโ BurnVerifier.sol
    โ   โ   โโโ MintVerifier.sol
    โ   โ   โโโ RegistrationVerifier.sol
    โ   โ   โโโ TransferVerifier.sol
    โ   โ   โโโ WithdrawVerifier.sol
    โ   โโโ tokens/
    โ   โ   โโโ FeeERC20.sol
    โ   โ   โโโ SimpleERC20.sol
    โ   โ   โโโ TokenTracker.sol
    โ   โโโ types/
    โ   โ   โโโ Types.sol
    โ   โโโ verifiers/
    โ       โโโ BurnCircuitGroth16Verifier.sol
    โ       โโโ MintCircuitGroth16Verifier.sol
    โ       โโโ RegistrationCircuitGroth16Verifier.sol
    โ       โโโ TransferCircuitGroth16Verifier.sol
    โ       โโโ WithdrawCircuitGroth16Verifier.sol
    โโโ scripts/
    โ   โโโ constants.ts
    โ   โโโ deploy-converter.ts
    โ   โโโ deploy-standalone.ts
    โโโ src/
    โ   โโโ constants.ts
    โ   โโโ index.ts
    โ   โโโ metadata.ts
    โ   โโโ jub/
    โ   โ   โโโ index.ts
    โ   โ   โโโ jub.ts
    โ   โโโ poseidon/
    โ       โโโ index.ts
    โ       โโโ poseidon.ts
    โโโ test/
    โ   โโโ EncryptedERC-Converter.ts
    โ   โโโ EncryptedERC-Standalone.ts
    โ   โโโ EncryptedMetadata.ts
    โ   โโโ helpers.ts
    โ   โโโ user.ts
    โโโ zk/
    โ   โโโ go.mod
    โ   โโโ go.sum
    โ   โโโ Makefile
    โ   โโโ cmd/
    โ       โโโ main.go
    โโโ .github/
        โโโ workflows/
            โโโ ci.yml




(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div  align="center">

<img  src="images/banner.png">

</div>

[![Coverage](https://img.shields.io/badge/Coverage-97%25-brightgreen)](https://github.com/ava-labs/EncryptedERC/actions/workflows/ci.yml)
[![Security Audit](https://img.shields.io/badge/Security%20Audit-Passed-green)](https://github.com/ava-labs/EncryptedERC/tree/main/audit)
[![Documentation](https://img.shields.io/badge/docs-available-green)](https://docs.avacloud.io/encrypted-erc)

# Encrypted ERC-20 Protocol

The Encrypted ERC-20 (eERC) standard, developed by [AvaCloud](https://avacloud.io), enables secure and confidential token transfers on Avalanche blockchains. Leveraging zk-SNARKs and partially homomorphic encryption, the eERC protocol offers robust privacy without requiring protocol-level modifications or off-chain intermediaries.
AvaCloud API documentation can be found [here](https://docs.avacloud.io/encrypted-erc/getting-started/what-is-encrypted-erc)

## Key features

- **Confidential Transactions**: User balances and transaction amounts remain completely hidden, ensuring financial confidentiality.

- **Large Integers**: Efficiently handles large token amounts up to 251 bits (2^251), providing greater flexibility.

- **Client-Side Operations**: Users retain control, performing encryption, decryption, and zk-proof generation directly on their own devices.

- **Fully On-chain Nature**: Operates entirely on-chain without the need for relayers or off-chain actors.


- **Built-in Compliance**: Supports external and rotatable auditors, ensuring regulatory compliance.


- **Dual-Mode Operation**: Supports both creating new private tokens and converting existing ERC-20 tokens their private versions.

- **Zero-Knowledge Proofs**: Uses efficient zk-SNARKs to validate statements without revealing sensitive information.

- **Chain Agnostic**: Can be deployed on any EVM-compatible blockchain.

- **(NEW) Encrypted Metadata**: Allows users to send arbitrary-length encrypted metadata along with transactions.


## Architecture

The eERC protocol consists of several key components:

### Core Contracts

- **EncryptedERC** ([contracts/EncryptedERC.sol](contracts/EncryptedERC.sol)): The main contract that implements the privacy-preserving ERC-20 functionality. It handles:

  - Private token operations (mint, burn, transfer)
  - Privacy-preserving balance management
  - Integration with other core components

- **Registrar**: Manages user registration and public key association.

  - Handles user registration
  - Stores public keys
  - Validates user identities
  - Manages registration proofs

- **EncryptedUserBalances**: Handles encrypted balance storage and updates.

  - Stores encrypted balances
  - Manages balance updates in encrypted manner
  - Ensures balance privacy
  - Handles encrypted balance verification

- **TokenTracker**: Manages token registration and tracking.

  - Tracks registered tokens
  - Manages token metadata
  - Handles token blacklisting

- **AuditorManager**: Provides auditor-related functionality for compliance.
  - Manages auditor permissions
  - Stores auditor address with it's public key

### Cryptographic Components

- **BabyJubJub**: Library for elliptic curve operations on the BabyJubJub curve.

- **Zero-Knowledge Circuits**: Circom-based circuits for proof generation and verification.

  - **Registration Circuit**: Validates user registration
  - **Mint Circuit**: Verifies minting operations
  - **Transfer Circuit**: Validates private transfers
  - **Withdraw Circuit**: Verifies withdrawal operations

### Operation Modes

1. **Standalone Mode**:

   - Creates entirely new private ERC-20 (eERC) tokens
   - Relies on minting and burning to manage token supply
   - Keeps total supply private all the time, offering better privacy compared to converter mode

2. **Converter Mode**:
   - Wraps existing ERC20 tokens to eERC tokens
   - Relies on deposits and withdrawals to manage token supply
   - Maintains compatibility with original tokens

## File structure

- [contracts](#contracts) Smart contract source files

  - `EncryptedERC.sol` - Main contract implementation

  - `Registrar.sol` - User registration management

  - `EncryptedUserBalances.sol` - Encrypted balance handling

  - `tokens/TokenTracker.sol` - Token registration and tracking

  - `auditor/AuditorManager.sol` - Auditor functionality

  - `libraries/BabyJubJub.sol` - Cryptographic operations

  - `types/Types.sol` - Data structures and types

  - `interfaces/` - Contract interfaces

  - `verifiers/` - Zero-knowledge proof verifiers

- [scripts](#scripts) Utility and deployment scripts

- [src](#src) Encryption utilities for TypeScript

- [tests](#tests) Test scripts and helpers

- [circom](#circom) Zero-knowledge proof circuits

## Getting Started

### Prerequisites

You need following dependencies for setup:

- `NodeJS >= v22.x`

- `Circom >= 2.1.9`

### Installation

1. Clone the repo

```sh
git clone https://github.com/ava-labs/EncryptedERC.git
```

2. Install NPM packages

```sh
npm install
```

3. Compile the contracts

```sh
npx hardhat compile
```

4. Compile Circuits

```sh
npx hardhat zkit make --force # compiles circuits
npx hardhat zkit verifiers    # generates verifiers
```

## Deployment (Local)

### Standalone

The Standalone version lets users create entirely new private ERC-20 tokens with built-in privacy, supporting confidential minting and burning.

1. Start the local node

```sh
npx hardhat node
```

2. Deploy the contract

```sh
npx hardhat run scripts/deploy-standalone.ts --network localhost
```

Refer to the [scripts/deploy-standalone.ts](scripts/deploy-standalone.ts) script for deployment examples.

### Converter

The Converter version adds privacy features to existing ERC-20 tokens, enabling users to convert standard ERC-20 tokens to private ones and switch between public and private states through deposit and withdrawal functions.

1. Start the local node

```sh
npx hardhat node
```

2. Deploy the contract

```sh
npx hardhat run scripts/deploy-converter.ts --network localhost
```

Refer to the [scripts/deploy-converter.ts](scripts/deploy-converter.ts) script for deployment examples.

## Architecture Overview

```mermaid
---
config:
  theme: neo-dark
---
  flowchart LR
  subgraph subGraph0["eERC SDK"]
          KeyMgmt["Key Generation"]
          ProofGen["Proof Generation"]
          TxBuild["Transaction Building"]
          BalanceEnc["Balance Encryption/Decryption"]
          SDK["Client SDK"]
    end
  subgraph subGraph1["Core Layer"]
          EERC["EncryptedERC"]
          StoreKeys["Store Public Keys"]
          ManageBalances["Manage Encrypted Balances"]
          HandleAudits["Handle Auditors"]
          PrivateOps["Private Token Operations"]
          VerifyProof["Verify ZK Proof"]
    end
  subgraph subGraph1["Contract Layer"]
          Registrar["Registrar"]
          EncryptedUserBalances["EncryptedUserBalances"]
          AuditorManager["AuditorManager"]
          ZKVerifiers["ZK Verifiers"]
          RegVerifier["Registration Verifier"]
          TransVerifier["Transfer Verifier"]
          MintVerifier["Mint Verifier"]
          WithdrawVerifier["Withdraw Verifier"]
    end
      User["User"] -- All Client Operations --> SDK
      SDK --> KeyMgmt & ProofGen & TxBuild & BalanceEnc
      subGraph0 -- Submit Tx + ZK Proof --> EERC
      EERC --> StoreKeys & ManageBalances & HandleAudits & PrivateOps & VerifyProof
      StoreKeys --> Registrar
      ManageBalances --> EncryptedUserBalances
      HandleAudits --> AuditorManager
      VerifyProof --> ZKVerifiers
      ZKVerifiers --> RegVerifier & TransVerifier & MintVerifier & WithdrawVerifier
```

## Run Tests/Coverage

Contract tests:

```sh
npx hardhat test
```

Coverage report:

```sh
npx hardhat coverage
```

## ๐ Efficiency Overview

### โฝ Avg. On-Chain Gas Costs (Avalanche C-Chain Mainnet)

```sh
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Solidity and Network Configuration                                                                                                                                                โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Solidity: 0.8.27                                                                              ยท  Optim: true    ยท  Runs: 200    ยท  viaIR: false   ยท     Block: 30,000,000 gas     โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Network: AVALANCHE                                                                            ยท  L1: 0.14345 gwei               ยท                 ยท        16.36 usd/avax         โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Contracts / Methods                                                                           ยท  Min            ยท  Max          ยท  Avg            ยท    calls       ยท  usd (avg)   โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  EncryptedERC                                                                                  ยท                                                                                   โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      deposit(uint256,address,uint256[7])                                                       ยท         71,680  ยท      841,771  ยท        564,892  ยท            16  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      privateBurn(((uint256[2],uint256[2][2],uint256[2]),uint256[32]),uint256[7])               ยท        890,507  ยท    1,227,920  ยท      1,028,678  ยท             4  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      privateMint(address,((uint256[2],uint256[2][2],uint256[2]),uint256[24]))                  ยท        712,316  ยท      760,624  ยท        722,016  ยท            10  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      setAuditorPublicKey(address)                                                              ยท              -  ยท            -  ยท        103,851  ยท             4  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      setTokenBlacklist(address,bool)                                                           ยท              -  ยท            -  ยท         46,443  ยท             1  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      transfer(address,uint256,((uint256[2],uint256[2][2],uint256[2]),uint256[32]),uint256[7])  ยท        947,295  ยท      947,331  ยท        947,313  ยท             4  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      withdraw(uint256,((uint256[2],uint256[2][2],uint256[2]),uint256[16]),uint256[7])          ยท        775,186  ยท      828,341  ยท        796,263  ยท             6  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Registrar                                                                                     ยท                                                                                   โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|      register(((uint256[2],uint256[2][2],uint256[2]),uint256[5]))                              ยท        322,114  ยท      322,150  ยท        322,143  ยท            20  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Deployments                                                                                                     ยท                                 ยท  % of limit    ยท              โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  BabyJubJub                                                                                    ยท              -  ยท            -  ยท        447,616  ยท         1.5 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  EncryptedERC                                                                                  ยท      3,704,671  ยท    3,729,773  ยท      3,717,222  ยท        12.4 %  ยท        0.01  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  MintCircuitGroth16Verifier                                                                    ยท              -  ยท            -  ยท      1,690,470  ยท         5.6 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Registrar                                                                                     ยท              -  ยท            -  ยท        508,067  ยท         1.7 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  RegistrationCircuitGroth16Verifier                                                            ยท              -  ยท            -  ยท        810,848  ยท         2.7 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  TransferCircuitGroth16Verifier                                                                ยท              -  ยท            -  ยท      2,052,092  ยท         6.8 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  WithdrawCircuitGroth16Verifier                                                                ยท              -  ยท            -  ยท      1,319,158  ยท         4.4 %  ยท           โณ  โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท|ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  Key                                                                                                                                                                               โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
|  โณ  Cost was non-zero but below the precision setting for the currency display                                                                                                     โ
ยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยทยท
```

## Security Audits

1. **Circom Audit**

   - Date: March 2025
   - Scope: Circom circuits for various zero-knowledge proofs
   - Report: [avacloud-eerc-circom-audit.pdf](audit/avacloud-eerc-circom-audit.pdf)

2. **Gnark Audit**
   - Date: March 2025
   - Scope: Core protocol and Gnark circuits for zero-knowledge proofs
   - Report: [avacloud-eerc-audit.pdf](audit/avacloud-eerc-audit.pdf)

## Security Considerations

- **Auditor Integration**: The protocol includes built-in auditor functionality for compliance.

- **Blacklisting**: Supports optionalblacklisting for security purposes.

### Notes

For production deployments, set `isProd` to `true` in the deployment scripts to use the production verifiers. These verifiers use secure trusted setups from the [zkevm](https://github.com/iden3/snarkjs?tab=readme-ov-file#7-prepare-phase-2).

Corresponding `zkey` and `verification_key.json` files are present in the `circuits/build` directory. After compiling circuits present in the `circuits` folder, and downloading the proper `.ptau` files, these can be verified using the `snarkjs` tool with the following command:

```sh
snarkjs zkey verify <circuit_name>.r1cs powersOfTau28_hez_final_<Size>.ptau <circuit_name>.zkey
```

- For transfer/mint circuit => `powersOfTau28_hez_final_15.ptau`
- For withdraw circuit => `powersOfTau28_hez_final_14.ptau`
- For registration circuit => `powersOfTau28_hez_final_11.ptau`

## License

This project is licensed under the Ecosystem License - see the LICENSE file for details.



================================================
FILE: biome.json
================================================
{
	"$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
	"vcs": {
		"enabled": false,
		"clientKind": "git",
		"useIgnoreFile": false
	},
	"files": {
		"ignoreUnknown": false,
		"ignore": [
			"typechain-types",
			"coverage",
			"artifacts",
			".vscode",
			"generated-types"
		]
	},
	"formatter": {
		"enabled": true,
		"indentStyle": "tab"
	},
	"organizeImports": {
		"enabled": true
	},
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true
		}
	},
	"javascript": {
		"formatter": {
			"quoteStyle": "double"
		}
	}
}



================================================
FILE: hardhat.config.ts
================================================
import "@nomicfoundation/hardhat-chai-matchers";
import "@nomicfoundation/hardhat-ethers";
import "@solarity/chai-zkit";
import "@solarity/hardhat-zkit";
import "@typechain/hardhat";
import "hardhat-gas-reporter";
import type { HardhatUserConfig } from "hardhat/config";
import "solidity-coverage";

import dotenv from "dotenv";
dotenv.config();

const RPC_URL = process.env.RPC_URL || "https://api.avax.network/ext/bc/C/rpc";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.27",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
    },
  },
  networks: {
    hardhat: {
      forking: {
        url: RPC_URL,
        blockNumber: 59121339,
        enabled: !!process.env.FORKING,
      },
    },
  },
  gasReporter: {
    enabled: !!process.env.REPORT_GAS,
    currency: "USD",
    coinmarketcap: process.env.COINMARKETCAP_API_KEY,
    excludeContracts: ["contracts/mocks/"],
    outputFile: "gas-report.txt",
    L1: "avalanche",
    showMethodSig: true,
  },
  zkit: {
    compilerVersion: "2.1.9",
    circuitsDir: "circom",
    compilationSettings: {
      artifactsDir: "zkit/artifacts",
      onlyFiles: [],
      skipFiles: [],
      c: false,
      json: false,
      optimization: "O2",
    },
    setupSettings: {
      contributionSettings: {
        provingSystem: "groth16",
        contributions: 0,
      },
      onlyFiles: [],
      skipFiles: [],
      ptauDir: undefined,
      ptauDownload: true,
    },
    verifiersSettings: {
      verifiersDir: "contracts/verifiers",
      verifiersType: "sol",
    },
    typesDir: "generated-types/zkit",
    quiet: false,
  },
};

export default config;



================================================
FILE: LICENSE.md
================================================
Copyright (C) 2025, Ava Labs, Inc. All rights reserved.

Ecosystem License
Version: 1.1

Subject to the terms herein, Ava Labs, Inc. (**โAva Labsโ**) hereby grants you
a limited, royalty-free, worldwide, non-sublicensable, non-transferable,
non-exclusive license to use, copy, modify, create derivative works based on,
and redistribute the Software, in source code, binary, or any other form,
including any modifications or derivative works of the Software (collectively,
**โLicensed Softwareโ**), in each case subject to this Ecosystem License
(**โLicenseโ**).

This License applies to all copies, modifications, derivative works, and any
other form or usage of the Licensed Software. You will include and display
this License, without modification, with all uses of the Licensed Software,
regardless of form.

You will use the Licensed Software solely (i) in connection with the Avalanche
Public Blockchain platform, having a NetworkID of 1 (Mainnet) or 5 (Fuji), and
associated blockchains, comprised exclusively of the Avalanche X-Chain,
C-Chain, P-Chain and any subnets linked to the P-Chain (โAvalanche Authorized
Platformโ) or (ii) for non-production, testing or research purposes within the
Avalanche ecosystem, in each case, without any commercial application
(โNon-Commercial Useโ); provided that this License does not permit use of the
Licensed Software in connection with (a) any forks of the Avalanche Authorized
Platform or (b) in any manner not operationally connected to the Avalanche
Authorized Platform other than, for the avoidance of doubt, the limited
exception for Non-Commercial Use. Ava Labs may publicly announce changes or
additions to the Avalanche Authorized Platform, which may expand or modify
usage of the Licensed Software. Upon such announcement, the Avalanche
Authorized Platform will be deemed to be the then-current iteration of such
platform.

You hereby acknowledge and agree to the terms set forth at
www.avalabs.org/important-notice.

If you use the Licensed Software in violation of this License, this License
will automatically terminate and Ava Labs reserves all rights to seek any
remedy for such violation.

Except for uses explicitly permitted in this License, Ava Labs retains all
rights in the Licensed Software, including without limitation the ability to
modify it.

Except as required or explicitly permitted by this License, you will not use
any Ava Labs names, logos, or trademarks without Ava Labsโ prior written
consent.

You may use this License for software other than the โLicensed Softwareโ
specified above, as long as the only change to this License is the definition
of the term โLicensed Software.โ

The Licensed Software may reference third party components. You acknowledge
and agree that these third party components may be governed by a separate
license or terms and that you will comply with them.

**TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE LICENSED SOFTWARE IS PROVIDED
ON AN โAS ISโ BASIS, AND AVA LABS EXPRESSLY DISCLAIMS AND EXCLUDES ALL
REPRESENTATIONS, WARRANTIES AND OTHER TERMS AND CONDITIONS, WHETHER EXPRESS OR
IMPLIED, INCLUDING WITHOUT LIMITATION BY OPERATION OF LAW OR BY CUSTOM,
STATUTE OR OTHERWISE, AND INCLUDING, BUT NOT LIMITED TO, ANY IMPLIED WARRANTY,
TERM, OR CONDITION OF NON-INFRINGEMENT, MERCHANTABILITY, TITLE, OR FITNESS FOR
PARTICULAR PURPOSE. YOU USE THE LICENSED SOFTWARE AT YOUR OWN RISK. AVA LABS
EXPRESSLY DISCLAIMS ALL LIABILITY (INCLUDING FOR ALL DIRECT, CONSEQUENTIAL OR
OTHER DAMAGES OR LOSSES) RELATED TO ANY USE OF THE LICENSED SOFTWARE.**



================================================
FILE: package.json
================================================
{
	"name": "encryptederc",
	"version": "1.0.0",
	"devDependencies": {
		"@biomejs/biome": "^1.9.4",
		"@nomicfoundation/hardhat-chai-matchers": "^2.0.8",
		"@nomicfoundation/hardhat-ethers": "^3.0.8",
		"@openzeppelin/contracts": "^5.1.0",
		"@solarity/chai-zkit": "^0.3.1",
		"@solarity/hardhat-zkit": "^0.5.15",
		"@typechain/hardhat": "^9.1.0",
		"@types/jest": "^29.5.14",
		"@types/mocha": "^10.0.10",
		"@zk-kit/baby-jubjub": "^1.0.3",
		"dotenv": "^16.4.7",
		"hardhat": "^2.22.15",
		"hardhat-gas-reporter": "^2.2.2",
		"maci-crypto": "^2.0.0",
		"poseidon-lite": "^0.3.0",
		"prettier": "^3.5.3",
		"prettier-plugin-solidity": "^1.4.2",
		"solhint": "^5.0.5",
		"solidity-coverage": "^0.8.14"
	},
	"scripts": {
		"test": "mocha 'src/**/*.test.js'",
		"postinstall": "npx hardhat compile & npx hardhat zkit make --force && npx hardhat zkit verifiers",
		"lint:sol": "solhint '**/*.sol' --config ./.solhint.json --ignore-path ./.solhintignore --max-warnings 0 && npx prettier --check '**/*.sol' --config ./.prettierrc",
		"lint:ts": "npx biome lint .",
		"lint": "npm run lint:sol && npm run lint:ts"
	},
	"keywords": [],
	"author": "",
	"repository": {
		"url": "https://github.com/ava-labs/EncryptedERC",
		"type": "git"
	}
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": [
    "./src/**/*.ts",
    "./test/**/*.ts",
    "./scripts/**/*.ts",
    "./typechain-types"
  ],
  "exclude": [],
  "files": ["./hardhat.config.ts"]
}



================================================
FILE: .env.example
================================================
COINMARKETCAP_API_KEY=""
REPORT_GAS=""
FORKING=""


================================================
FILE: .nvmrc
================================================
v22.14.0



================================================
FILE: .prettierignore
================================================
contracts/verifiers/*
contracts/prod/*
circom/build/*


================================================
FILE: .prettierrc
================================================
{
	"plugins": ["prettier-plugin-solidity"],
	"overrides": [
		{
			"files": "*.sol",
			"options": {
				"parser": "solidity-parse",
				"printWidth": 80,
				"tabWidth": 4,
				"useTabs": false,
				"singleQuote": false,
				"bracketSpacing": false
			}
		}
	]
}



================================================
FILE: .solcover.js
================================================
module.exports = {
  skipFiles: [
    "SimpleERC20.sol",
    "FeeERC20.sol",
    "x",
    "verifiers"
  ],
};



================================================
FILE: .solhint.json
================================================
{
  "extends": "solhint:recommended",
  "rules": {
    "compiler-version": [
      "error",
      "0.8.27"
    ],
    "no-unused-vars": "error",
    "func-visibility": [
      "error",
      {
        "ignoreConstructors": true
      }
    ],
    "private-vars-leading-underscore": [
      "warn",
      {
        "strict": true
      }
    ],
    "reason-string": [
      "warn",
      {
        "maxLength": 75
      }
    ],
    "gas-custom-errors": "off",
    "ordering": "error",
    "immutable-vars-naming": [
      "warn",
      {
        "immutablesAsConstants": false
      }
    ],
    "func-named-parameters": [
      "error",
      5
    ],
    "one-contract-per-file": "off",
    "no-console": "off"
  }
}


================================================
FILE: .solhintignore
================================================
node_modules/
contracts/verifiers/*
contracts/prod/*
circom/build/*




================================================
FILE: circom/burn.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template BurnCircuit () {
    signal input ValueToBurn;
    
    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderBalance;
    signal input SenderBalanceC1[2];
    signal input SenderBalanceC2[2];

    signal input SenderVTBC1[2];
    signal input SenderVTBC2[2];

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;

    // Verify that the transfer amount is less than or equal to the sender's balance and is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;   

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToBurn;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== ValueToBurn;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component bitCheck3 = Num2Bits(252);
    bitCheck3.in <== SenderBalance + 1;

    component checkValue = LessThan(252);
    checkValue.in[0] <== ValueToBurn;
    checkValue.in[1] <== SenderBalance + 1;
    checkValue.out === 1;


    // Verify that the sender's public key is well-formed
    component checkSenderPK = CheckPublicKey();
    checkSenderPK.privKey <== SenderPrivateKey;
    checkSenderPK.pubKey[0] <== SenderPublicKey[0];
    checkSenderPK.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's encrypted balance is well-formed
    component checkSenderBalance = CheckValue();
    checkSenderBalance.value <== SenderBalance;
    checkSenderBalance.privKey <== SenderPrivateKey;
    checkSenderBalance.valueC1[0] <== SenderBalanceC1[0];
    checkSenderBalance.valueC1[1] <== SenderBalanceC1[1];
    checkSenderBalance.valueC2[0] <== SenderBalanceC2[0];
    checkSenderBalance.valueC2[1] <== SenderBalanceC2[1];

    // Verify that the sender's encrypted value to burn is the burn amount
    component checkSenderVTB = CheckValue();
    checkSenderVTB.value <== ValueToBurn;
    checkSenderVTB.privKey <== SenderPrivateKey;
    checkSenderVTB.valueC1[0] <== SenderVTBC1[0];
    checkSenderVTB.valueC1[1] <== SenderVTBC1[1];
    checkSenderVTB.valueC2[0] <== SenderVTBC2[0];
    checkSenderVTB.valueC2[1] <== SenderVTBC2[1];

    // Verify auditor's encrypted summary includes the burn amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToBurn;
}

component main { public [ SenderPublicKey, AuditorPublicKey, SenderBalanceC1, SenderBalanceC2, SenderVTBC1, SenderVTBC2, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce ] } = BurnCircuit();


================================================
FILE: circom/components.circom
================================================
pragma circom 2.1.9;

include "./circomlib/poseidon.circom";
include "./circomlib/babyjub.circom";
include "./circomlib/escalarmulany.circom";

// Performs a Poseidon decryption of a given length
// Taken from https://github.com/Shigoto-dev19/poseidon-encryption-circom2/blob/master-circom2/circom/poseidon.circom
template PoseidonDecrypt(l) {
    var decryptedLength = l;
    while (decryptedLength % 3 != 0) {
        decryptedLength += 1;
    }

    signal input ciphertext[decryptedLength + 1];
    signal input nonce;
    signal input key[2];
    signal output decrypted[decryptedLength];

    var two128 = 2 ** 128;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== nonce;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== two128;

    component lt = LessThan(252);
    lt.in[0] <== nonce;
    lt.in[1] <== two128;
    lt.out === 1;

    var n = (decryptedLength + 1) \ 3;

    component strategies[n + 1];
    strategies[0] = PoseidonEx(3, 4);
    strategies[0].initialState <== 0;
    strategies[0].inputs[0] <== key[0];
    strategies[0].inputs[1] <== key[1];
    strategies[0].inputs[2] <== nonce + (l * two128);

    for (var i = 0; i < n; i ++) {
        for (var j = 0; j < 3; j ++) {
            decrypted[i * 3 + j] <== ciphertext[i * 3 + j] - strategies[i].out[j + 1];
        }

        strategies[i + 1] = PoseidonEx(3, 4);
        strategies[i + 1].initialState <== strategies[i].out[0];
        for (var j = 0; j < 3; j ++) {
            strategies[i + 1].inputs[j] <== ciphertext[i * 3 + j];
        }
    }

    // Check the last ciphertext element
    ciphertext[decryptedLength] === strategies[n].out[1];

    // If length > 3, check if the last (3 - (l mod 3)) elements of the message
    // are 0
    if (l % 3 > 0) {
        if (l % 3 == 1) {
            decrypted[decryptedLength - 1] === 0;
        } else if (l % 3 == 2) {
            decrypted[decryptedLength - 1] === 0;
            decrypted[decryptedLength - 2] === 0;
        }
    }
}

// BabyJubJub Scalar Multiplication
// Converted from https://github.com/iden3/circomlib/blob/master/circuits/babyjub.circom BabyPbk()
template BabyScalarMul() {
    signal input  scalar;
    signal input point[2];
    signal output Ax;
    signal output Ay;

    component checkPoint = BabyCheck();
    checkPoint.x <== point[0];
    checkPoint.y <== point[1];

    component scalarBits = Num2Bits(253);
    scalarBits.in <== scalar;

    component mulAny = EscalarMulAny(253);
    mulAny.p[0] <== point[0];
    mulAny.p[1] <== point[1];

    var i;
    for (i=0; i<253; i++) {
        mulAny.e[i] <== scalarBits.out[i];
    }
    Ax  <== mulAny.out[0];
    Ay  <== mulAny.out[1];
}


// ElGamal encryption over BabyJubJub curve while preserving the additively homomorphic property.
// The scheme maps a scalar to a point on the curve and then adds it to the public key point. It outputs the two points of the resulting ciphertext (c1, c2).
template ElGamalEncrypt() {
    signal input random;
    signal input pk[2];
    signal input msg[2];
    signal output encryptedC1X;
    signal output encryptedC1Y;
    signal output encryptedC2X;
    signal output encryptedC2Y;

    component checkPoint = BabyCheck();
    checkPoint.x <== pk[0];
    checkPoint.y <== pk[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== msg[0];
    checkPoint2.y <== msg[1];

    component randomBits = Num2Bits(253);
    randomBits.in <== random;

    component randomToPoint = BabyPbk();
    randomToPoint.in <== random;

    component pkandr = EscalarMulAny(253);
    for (var i = 0; i < 253; i ++) {
        pkandr.e[i] <== randomBits.out[i];
    }
    pkandr.p[0] <== pk[0];
    pkandr.p[1] <== pk[1];
    
    component addRes = BabyAdd();
    addRes.x1 <== msg[0];
    addRes.y1 <== msg[1];
    addRes.x2 <== pkandr.out[0];
    addRes.y2 <== pkandr.out[1];

    encryptedC1X <== randomToPoint.Ax;
    encryptedC1Y <== randomToPoint.Ay;
    encryptedC2X <== addRes.xout;
    encryptedC2Y <== addRes.yout;

}

// ElGamal Decryption scheme over BabyJub curve while preserving the additively homomorphic property.
// The scheme takes the two points of the ciphertext (c1, c2) and the private key and outputs the message, mapped to a point.
template ElGamalDecrypt() {
    signal input c1[2];
    signal input c2[2];
    signal input privKey;
    signal output outx;
    signal output outy;

    component checkPoint = BabyCheck();
    checkPoint.x <== c1[0];
    checkPoint.y <== c1[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== c2[0];
    checkPoint2.y <== c2[1];

    // Convert the private key to bits
    component privKeyBits = Num2Bits(253);
    privKeyBits.in <== privKey;

    // c1 ** x
    component c1x = EscalarMulAny(253);
    for (var i = 0; i < 253; i ++) {
        c1x.e[i] <== privKeyBits.out[i];
    }
    c1x.p[0] <== c1[0];
    c1x.p[1] <== c1[1];

    // (c1 * x) * -1
    signal c1xInverseX;
    c1xInverseX <== 0 - c1x.out[0];

    // ((c1 * x) * - 1) * c2
    component decryptedPoint = BabyAdd();
    decryptedPoint.x1 <== c1xInverseX;
    decryptedPoint.y1 <== c1x.out[1];
    decryptedPoint.x2 <== c2[0];
    decryptedPoint.y2 <== c2[1];

    outx <== decryptedPoint.xout;
    outy <== decryptedPoint.yout;
}

template CheckPublicKey() {
    signal input privKey;
    signal input pubKey[2];

    // Verify the private key is not zero
    component checkIsZero = IsZero();
    checkIsZero.in <== privKey;
    checkIsZero.out === 0;

    component checkPoint = BabyCheck();
    checkPoint.x <== pubKey[0];
    checkPoint.y <== pubKey[1];
    
    // Verify the private key is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== privKey;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== privKey;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component checkPK = BabyPbk();
    checkPK.in <== privKey;

    checkPK.Ax === pubKey[0];
    checkPK.Ay === pubKey[1];
}

template CheckValue() {
    signal input value;
    signal input privKey;
    signal input valueC1[2];
    signal input valueC2[2];

    component checkPoint = BabyCheck();
    checkPoint.x <== valueC1[0];
    checkPoint.y <== valueC1[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== valueC2[0];
    checkPoint2.y <== valueC2[1];
    
    // Verify the value is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== value;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== value;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component checkValue = ElGamalDecrypt();
    checkValue.c1[0] <== valueC1[0];
    checkValue.c1[1] <== valueC1[1];
    checkValue.c2[0] <== valueC2[0];
    checkValue.c2[1] <== valueC2[1];
    checkValue.privKey <== privKey;
    
    component valueToPoint = BabyPbk();
    valueToPoint.in <== value;

    valueToPoint.Ax === checkValue.outx;
    valueToPoint.Ay === checkValue.outy;
}


template CheckReceiverValue() {
    signal input receiverValue;
    signal input receiverPublicKey[2];
    signal input receiverRandom;
    signal input receiverValueC1[2];
    signal input receiverValueC2[2];

    component checkPoint = BabyCheck();
    checkPoint.x <== receiverValueC1[0];
    checkPoint.y <== receiverValueC1[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== receiverValueC2[0];
    checkPoint2.y <== receiverValueC2[1];

    // Verify the receiver value is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== receiverValue;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== receiverValue;
    lt.in[1] <== baseOrder;
    lt.out === 1;
    
    component receiverValueToPoint = BabyPbk();
    receiverValueToPoint.in <== receiverValue;

    component receiverValueEncrypt = ElGamalEncrypt();
    receiverValueEncrypt.random <== receiverRandom;
    receiverValueEncrypt.pk[0] <== receiverPublicKey[0];
    receiverValueEncrypt.pk[1] <== receiverPublicKey[1];
    receiverValueEncrypt.msg[0] <== receiverValueToPoint.Ax;
    receiverValueEncrypt.msg[1] <== receiverValueToPoint.Ay;

    receiverValueEncrypt.encryptedC1X === receiverValueC1[0];
    receiverValueEncrypt.encryptedC1Y === receiverValueC1[1];
    receiverValueEncrypt.encryptedC2X === receiverValueC2[0];
    receiverValueEncrypt.encryptedC2Y === receiverValueC2[1];
}

template CheckPCT() {
    signal input publicKey[2];
    signal input pct[4];
    signal input authKey[2];
    signal input nonce;
    signal input random;
    signal input value;

    component checkPoint = BabyCheck();
    checkPoint.x <== publicKey[0];
    checkPoint.y <== publicKey[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== authKey[0];
    checkPoint2.y <== authKey[1];

    // Verify the random is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== random;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== random;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component checkAuthKey = BabyPbk();
    checkAuthKey.in <== random;

    checkAuthKey.Ax === authKey[0];
    checkAuthKey.Ay === authKey[1];

    component checkEncKey = BabyScalarMul();
    checkEncKey.scalar <== random;
    checkEncKey.point[0] <== publicKey[0];
    checkEncKey.point[1] <== publicKey[1];

    component decryptedPCT = PoseidonDecrypt(1);
    decryptedPCT.ciphertext <== pct;
    decryptedPCT.nonce <== nonce;
    decryptedPCT.key[0] <== checkEncKey.Ax;
    decryptedPCT.key[1] <== checkEncKey.Ay;


    decryptedPCT.decrypted[0] === value;
}

template CheckNullifierHash() {
    signal input nullifierHash;
    signal input chainID;
    signal input auditorCiphertext[4];

    component hash = Poseidon(5);
    hash.inputs[0] <== chainID;
    hash.inputs[1] <== auditorCiphertext[0];
    hash.inputs[2] <== auditorCiphertext[1];
    hash.inputs[3] <== auditorCiphertext[2];
    hash.inputs[4] <== auditorCiphertext[3];

    hash.out === nullifierHash;
}

template CheckRegistrationHash() {
    signal input registrationHash;
    signal input chainID;
    signal input senderPrivateKey;
    signal input senderAddress;

    component hash = Poseidon(3);
    hash.inputs[0] <== chainID;
    hash.inputs[1] <== senderPrivateKey;
    hash.inputs[2] <== senderAddress;

    hash.out === registrationHash;
}


================================================
FILE: circom/mint.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template MintCircuit () {
    signal input ValueToMint;

    signal input ChainID;
    signal input NullifierHash;

    signal input ReceiverPublicKey[2];
    signal input ReceiverVTTC1[2];
    signal input ReceiverVTTC2[2];
    signal input ReceiverVTTRandom;
    
    signal input ReceiverPCT[4];
    signal input ReceiverPCTAuthKey[2];
    signal input ReceiverPCTNonce;
    signal input ReceiverPCTRandom;

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;

    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;
    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToMint;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== ValueToMint;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    // Verify receiver's encrypted value is the mint amount
    component checkReceiverValue = CheckReceiverValue();
    checkReceiverValue.receiverValue <== ValueToMint;
    checkReceiverValue.receiverPublicKey[0] <== ReceiverPublicKey[0];
    checkReceiverValue.receiverPublicKey[1] <== ReceiverPublicKey[1];
    checkReceiverValue.receiverRandom <== ReceiverVTTRandom;
    checkReceiverValue.receiverValueC1[0] <== ReceiverVTTC1[0];
    checkReceiverValue.receiverValueC1[1] <== ReceiverVTTC1[1];
    checkReceiverValue.receiverValueC2[0] <== ReceiverVTTC2[0];
    checkReceiverValue.receiverValueC2[1] <== ReceiverVTTC2[1];

	// Verify nullifier hash is not used
    component checkNullifierHash = CheckNullifierHash();
    checkNullifierHash.nullifierHash <== NullifierHash;
    checkNullifierHash.chainID <== ChainID;
    checkNullifierHash.auditorCiphertext[0] <== AuditorPCT[0];
    checkNullifierHash.auditorCiphertext[1] <== AuditorPCT[1];
    checkNullifierHash.auditorCiphertext[2] <== AuditorPCT[2];
    checkNullifierHash.auditorCiphertext[3] <== AuditorPCT[3];

    // Verify receiver's encrypted summary includes the mint amount and is encrypted with the receiver's public key
    component checkReceiverPCT = CheckPCT();
    checkReceiverPCT.publicKey[0] <== ReceiverPublicKey[0];
    checkReceiverPCT.publicKey[1] <== ReceiverPublicKey[1];
    checkReceiverPCT.pct <== ReceiverPCT;
    checkReceiverPCT.authKey[0] <== ReceiverPCTAuthKey[0];
    checkReceiverPCT.authKey[1] <== ReceiverPCTAuthKey[1];
    checkReceiverPCT.nonce <== ReceiverPCTNonce;
    checkReceiverPCT.random <== ReceiverPCTRandom;
    checkReceiverPCT.value <== ValueToMint;

    // Verify auditor's encrypted summary includes the mint amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToMint;
    
}

component main { public [ ReceiverPublicKey, AuditorPublicKey, ReceiverVTTC1, ReceiverVTTC2, ReceiverPCT, ReceiverPCTAuthKey, ReceiverPCTNonce, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce, ChainID, NullifierHash ] } = MintCircuit();


================================================
FILE: circom/registration.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template RegistrationCircuit() {
    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderAddress;
    signal input ChainID;
    signal input RegistrationHash;

    // Verify that the sender's public key is well-formed
    component checkSenderPublicKey = CheckPublicKey();
    checkSenderPublicKey.privKey <== SenderPrivateKey;
    checkSenderPublicKey.pubKey[0] <== SenderPublicKey[0];
    checkSenderPublicKey.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's registration hash is well-formed
    component checkRegistrationHash = CheckRegistrationHash();
    checkRegistrationHash.registrationHash <== RegistrationHash;
    checkRegistrationHash.chainID <== ChainID;
    checkRegistrationHash.senderPrivateKey <== SenderPrivateKey;
    checkRegistrationHash.senderAddress <== SenderAddress;
}

component main { public [ SenderPublicKey, SenderAddress, ChainID, RegistrationHash ] } = RegistrationCircuit();


================================================
FILE: circom/transfer.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template TransferCircuit () {
    signal input ValueToTransfer;
    
    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderBalance;
    signal input SenderBalanceC1[2];
    signal input SenderBalanceC2[2];

    signal input SenderVTTC1[2];
    signal input SenderVTTC2[2];
    
    signal input ReceiverPublicKey[2];
    signal input ReceiverVTTC1[2];
    signal input ReceiverVTTC2[2];
    signal input ReceiverVTTRandom;
    
    signal input ReceiverPCT[4];
    signal input ReceiverPCTAuthKey[2];
    signal input ReceiverPCTNonce;
    signal input ReceiverPCTRandom;

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;

    // Verify that the transfer amount is less than or equal to the sender's balance and is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;   

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToTransfer;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== ValueToTransfer;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component bitCheck3 = Num2Bits(252);
    bitCheck3.in <== SenderBalance + 1;

    component checkValue = LessThan(252);
    checkValue.in[0] <== ValueToTransfer;
    checkValue.in[1] <== SenderBalance + 1;
    checkValue.out === 1;


    // Verify that the sender's public key is well-formed
    component checkSenderPK = CheckPublicKey();
    checkSenderPK.privKey <== SenderPrivateKey;
    checkSenderPK.pubKey[0] <== SenderPublicKey[0];
    checkSenderPK.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's encrypted balance is well-formed
    component checkSenderBalance = CheckValue();
    checkSenderBalance.value <== SenderBalance;
    checkSenderBalance.privKey <== SenderPrivateKey;
    checkSenderBalance.valueC1[0] <== SenderBalanceC1[0];
    checkSenderBalance.valueC1[1] <== SenderBalanceC1[1];
    checkSenderBalance.valueC2[0] <== SenderBalanceC2[0];
    checkSenderBalance.valueC2[1] <== SenderBalanceC2[1];

    // Verify that the sender's encrypted value to transfer is the transfer amount
    component checkSenderVTTC1 = CheckValue();
    checkSenderVTTC1.value <== ValueToTransfer;
    checkSenderVTTC1.privKey <== SenderPrivateKey;
    checkSenderVTTC1.valueC1[0] <== SenderVTTC1[0];
    checkSenderVTTC1.valueC1[1] <== SenderVTTC1[1];
    checkSenderVTTC1.valueC2[0] <== SenderVTTC2[0];
    checkSenderVTTC1.valueC2[1] <== SenderVTTC2[1];

	// Verify that the receiver's encrypted value is the transfer amount by encryption
    component checkReceiverValue = CheckReceiverValue();
    checkReceiverValue.receiverValue <== ValueToTransfer;
    checkReceiverValue.receiverPublicKey[0] <== ReceiverPublicKey[0];
    checkReceiverValue.receiverPublicKey[1] <== ReceiverPublicKey[1];
    checkReceiverValue.receiverRandom <== ReceiverVTTRandom;
    checkReceiverValue.receiverValueC1[0] <== ReceiverVTTC1[0];
    checkReceiverValue.receiverValueC1[1] <== ReceiverVTTC1[1];
    checkReceiverValue.receiverValueC2[0] <== ReceiverVTTC2[0]; 
    checkReceiverValue.receiverValueC2[1] <== ReceiverVTTC2[1];

    // Verify receiver's encrypted summary includes the transfer amount and is encrypted with the receiver's public key
    component checkReceiverPCT = CheckPCT();
    checkReceiverPCT.publicKey[0] <== ReceiverPublicKey[0];
    checkReceiverPCT.publicKey[1] <== ReceiverPublicKey[1];
    checkReceiverPCT.pct <== ReceiverPCT;
    checkReceiverPCT.authKey[0] <== ReceiverPCTAuthKey[0];
    checkReceiverPCT.authKey[1] <== ReceiverPCTAuthKey[1];
    checkReceiverPCT.nonce <== ReceiverPCTNonce;
    checkReceiverPCT.random <== ReceiverPCTRandom;
    checkReceiverPCT.value <== ValueToTransfer;

    // Verify auditor's encrypted summary includes the transfer amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToTransfer;
}

component main { public [ SenderPublicKey, ReceiverPublicKey, AuditorPublicKey, SenderBalanceC1, SenderBalanceC2, SenderVTTC1, SenderVTTC2, ReceiverVTTC1, ReceiverVTTC2, ReceiverPCT, ReceiverPCTAuthKey, ReceiverPCTNonce, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce ] } = TransferCircuit();


================================================
FILE: circom/withdraw.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template WithdrawCircuit() {
    signal input ValueToWithdraw;

    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderBalance;
    signal input SenderBalanceC1[2];
    signal input SenderBalanceC2[2];

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;


    // Verify the withdrawal amount is less than or equal to the sender's balance and is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;
    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToWithdraw;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component checkWithdrawalAmount = LessThan(252);
    checkWithdrawalAmount.in[0] <== ValueToWithdraw;
    checkWithdrawalAmount.in[1] <== baseOrder;
    checkWithdrawalAmount.out === 1;

    component bitCheck3 = Num2Bits(252);
    bitCheck3.in <== SenderBalance + 1;

    component checkValue = LessThan(252);
    checkValue.in[0] <== ValueToWithdraw;
    checkValue.in[1] <== SenderBalance + 1;
    checkValue.out === 1;

    // Verify that the sender's public key is well-formed
    component checkSenderPK = CheckPublicKey();
    checkSenderPK.privKey <== SenderPrivateKey;
    checkSenderPK.pubKey[0] <== SenderPublicKey[0];
    checkSenderPK.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's encrypted balance is well-formed
    component checkSenderBalance = CheckValue();
    checkSenderBalance.value <== SenderBalance;
    checkSenderBalance.privKey <== SenderPrivateKey;
    checkSenderBalance.valueC1[0] <== SenderBalanceC1[0];
    checkSenderBalance.valueC1[1] <== SenderBalanceC1[1];
    checkSenderBalance.valueC2[0] <== SenderBalanceC2[0];
    checkSenderBalance.valueC2[1] <== SenderBalanceC2[1];

    // Verify auditor's encrypted summary includes the withdrawal amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToWithdraw;
}

component main { public [ SenderPublicKey, SenderBalanceC1, SenderBalanceC2, AuditorPublicKey, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce, ValueToWithdraw ] } = WithdrawCircuit();


================================================
FILE: circom/circomlib/aliascheck.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "compconstant.circom";


template AliasCheck() {

    signal input in[254];

    component  compConstant = CompConstant(-1);

    for (var i=0; i<254; i++) in[i] ==> compConstant.in[i];

    compConstant.out === 0;
}



================================================
FILE: circom/circomlib/babyjub.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "bitify.circom";
include "escalarmulfix.circom";

template BabyAdd() {
    signal input x1;
    signal input y1;
    signal input x2;
    signal input y2;
    signal output xout;
    signal output yout;

    signal beta;
    signal gamma;
    signal delta;
    signal tau;

    var a = 168700;
    var d = 168696;

    beta <== x1*y2;
    gamma <== y1*x2;
    delta <== (-a*x1+y1)*(x2 + y2);
    tau <== beta * gamma;

    xout <-- (beta + gamma) / (1+ d*tau);
    (1+ d*tau) * xout === (beta + gamma);

    yout <-- (delta + a*beta - gamma) / (1-d*tau);
    (1-d*tau)*yout === (delta + a*beta - gamma);
}

template BabyDbl() {
    signal input x;
    signal input y;
    signal output xout;
    signal output yout;

    component adder = BabyAdd();
    adder.x1 <== x;
    adder.y1 <== y;
    adder.x2 <== x;
    adder.y2 <== y;

    adder.xout ==> xout;
    adder.yout ==> yout;
}


template BabyCheck() {
    signal input x;
    signal input y;

    signal x2;
    signal y2;

    var a = 168700;
    var d = 168696;

    x2 <== x*x;
    y2 <== y*y;

    a*x2 + y2 === 1 + d*x2*y2;
}

// Extracts the public key from private key
template BabyPbk() {
    signal input  in;
    signal output Ax;
    signal output Ay;

    var BASE8[2] = [
        5299619240641551281634865583518297030282874472190772894086521144482721001553,
        16950150798460657717958625567821834550301663161624707787222815936182638968203
    ];

    component pvkBits = Num2Bits(253);
    pvkBits.in <== in;

    component mulFix = EscalarMulFix(253, BASE8);

    var i;
    for (i=0; i<253; i++) {
        mulFix.e[i] <== pvkBits.out[i];
    }
    Ax  <== mulFix.out[0];
    Ay  <== mulFix.out[1];
}



================================================
FILE: circom/circomlib/bitify.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "comparators.circom";
include "aliascheck.circom";


template Num2Bits(n) {
    signal input in;
    signal output out[n];
    var lc1=0;

    var e2=1;
    for (var i = 0; i<n; i++) {
        out[i] <-- (in >> i) & 1;
        out[i] * (out[i] -1 ) === 0;
        lc1 += out[i] * e2;
        e2 = e2+e2;
    }

    lc1 === in;
}

template Num2Bits_strict() {
    signal input in;
    signal output out[254];

    component aliasCheck = AliasCheck();
    component n2b = Num2Bits(254);
    in ==> n2b.in;

    for (var i=0; i<254; i++) {
        n2b.out[i] ==> out[i];
        n2b.out[i] ==> aliasCheck.in[i];
    }
}

template Bits2Num(n) {
    signal input in[n];
    signal output out;
    var lc1=0;

    var e2 = 1;
    for (var i = 0; i<n; i++) {
        lc1 += in[i] * e2;
        e2 = e2 + e2;
    }

    lc1 ==> out;
}

template Bits2Num_strict() {
    signal input in[254];
    signal output out;

    component aliasCheck = AliasCheck();
    component b2n = Bits2Num(254);

    for (var i=0; i<254; i++) {
        in[i] ==> b2n.in[i];
        in[i] ==> aliasCheck.in[i];
    }

    b2n.out ==> out;
}

template Num2BitsNeg(n) {
    signal input in;
    signal output out[n];
    var lc1=0;

    component isZero;

    isZero = IsZero();

    var neg = n == 0 ? 0 : 2**n - in;

    for (var i = 0; i<n; i++) {
        out[i] <-- (neg >> i) & 1;
        out[i] * (out[i] -1 ) === 0;
        lc1 += out[i] * 2**i;
    }

    in ==> isZero.in;



    lc1 + isZero.out * 2**n === 2**n - in;
}



================================================
FILE: circom/circomlib/comparators.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

template IsZero() {
    signal input in;
    signal output out;

    signal inv;

    inv <-- in!=0 ? 1/in : 0;

    out <== -in*inv +1;
    in*out === 0;
}

template LessThan(n) {
    assert(n <= 252);
    signal input in[2];
    signal output out;

    component n2b = Num2Bits(n+1);

    n2b.in <== in[0]+ (1<<n) - in[1];

    out <== 1-n2b.out[n];
}


================================================
FILE: circom/circomlib/compconstant.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "bitify.circom";

// Returns 1 if in (in binary) > ct
template CompConstant(ct) {
    signal input in[254];
    signal output out;

    signal parts[127];
    signal sout;

    var clsb;
    var cmsb;
    var slsb;
    var smsb;

    var sum=0;

    var b = (1 << 128) -1;
    var a = 1;
    var e = 1;
    var i;

    for (i=0;i<127; i++) {
        clsb = (ct >> (i*2)) & 1;
        cmsb = (ct >> (i*2+1)) & 1;
        slsb = in[i*2];
        smsb = in[i*2+1];

        if ((cmsb==0)&&(clsb==0)) {
            parts[i] <== -b*smsb*slsb + b*smsb + b*slsb;
        } else if ((cmsb==0)&&(clsb==1)) {
            parts[i] <== a*smsb*slsb - a*slsb + b*smsb - a*smsb + a;
        } else if ((cmsb==1)&&(clsb==0)) {
            parts[i] <== b*smsb*slsb - a*smsb + a;
        } else {
            parts[i] <== -a*smsb*slsb + a;
        }

        sum = sum + parts[i];

        b = b -e;
        a = a +e;
        e = e*2;
    }

    sout <== sum;

    component num2bits = Num2Bits(135);

    num2bits.in <== sout;

    out <== num2bits.out[127];
}



================================================
FILE: circom/circomlib/escalarmulany.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "montgomery.circom";
include "babyjub.circom";
include "comparators.circom";

template Multiplexor2() {
    signal input sel;
    signal input in[2][2];
    signal output out[2];

    out[0] <== (in[1][0] - in[0][0])*sel + in[0][0];
    out[1] <== (in[1][1] - in[0][1])*sel + in[0][1];
}

template BitElementMulAny() {
    signal input sel;
    signal input dblIn[2];
    signal input addIn[2];
    signal output dblOut[2];
    signal output addOut[2];

    component doubler = MontgomeryDouble();
    component adder = MontgomeryAdd();
    component selector = Multiplexor2();


    sel ==> selector.sel;

    dblIn[0] ==> doubler.in[0];
    dblIn[1] ==> doubler.in[1];
    doubler.out[0] ==> adder.in1[0];
    doubler.out[1] ==> adder.in1[1];
    addIn[0] ==> adder.in2[0];
    addIn[1] ==> adder.in2[1];
    addIn[0] ==> selector.in[0][0];
    addIn[1] ==> selector.in[0][1];
    adder.out[0] ==> selector.in[1][0];
    adder.out[1] ==> selector.in[1][1];

    doubler.out[0] ==> dblOut[0];
    doubler.out[1] ==> dblOut[1];
    selector.out[0] ==> addOut[0];
    selector.out[1] ==> addOut[1];
}

// p is montgomery point
// n must be <= 248
// returns out in twisted edwards
// Double is in montgomery to be linked;

template SegmentMulAny(n) {
    signal input e[n];
    signal input p[2];
    signal output out[2];
    signal output dbl[2];

    component bits[n-1];

    component e2m = Edwards2Montgomery();

    p[0] ==> e2m.in[0];
    p[1] ==> e2m.in[1];

    var i;

    bits[0] = BitElementMulAny();
    e2m.out[0] ==> bits[0].dblIn[0];
    e2m.out[1] ==> bits[0].dblIn[1];
    e2m.out[0] ==> bits[0].addIn[0];
    e2m.out[1] ==> bits[0].addIn[1];
    e[1] ==> bits[0].sel;

    for (i=1; i<n-1; i++) {
        bits[i] = BitElementMulAny();

        bits[i-1].dblOut[0] ==> bits[i].dblIn[0];
        bits[i-1].dblOut[1] ==> bits[i].dblIn[1];
        bits[i-1].addOut[0] ==> bits[i].addIn[0];
        bits[i-1].addOut[1] ==> bits[i].addIn[1];
        e[i+1] ==> bits[i].sel;
    }

    bits[n-2].dblOut[0] ==> dbl[0];
    bits[n-2].dblOut[1] ==> dbl[1];

    component m2e = Montgomery2Edwards();

    bits[n-2].addOut[0] ==> m2e.in[0];
    bits[n-2].addOut[1] ==> m2e.in[1];

    component eadder = BabyAdd();

    m2e.out[0] ==> eadder.x1;
    m2e.out[1] ==> eadder.y1;
    -p[0] ==> eadder.x2;
    p[1] ==> eadder.y2;

    component lastSel = Multiplexor2();

    e[0] ==> lastSel.sel;
    eadder.xout ==> lastSel.in[0][0];
    eadder.yout ==> lastSel.in[0][1];
    m2e.out[0] ==> lastSel.in[1][0];
    m2e.out[1] ==> lastSel.in[1][1];

    lastSel.out[0] ==> out[0];
    lastSel.out[1] ==> out[1];
}

// This function assumes that p is in the subgroup and it is different to 0

template EscalarMulAny(n) {
    signal input e[n];              // Input in binary format
    signal input p[2];              // Point (Twisted format)
    signal output out[2];           // Point (Twisted format)

    var nsegments = (n-1)\148 +1;
    var nlastsegment = n - (nsegments-1)*148;

    component segments[nsegments];
    component doublers[nsegments-1];
    component m2e[nsegments-1];
    component adders[nsegments-1];
    component zeropoint = IsZero();
    zeropoint.in <== p[0];

    var s;
    var i;
    var nseg;

    for (s=0; s<nsegments; s++) {

        nseg = (s < nsegments-1) ? 148 : nlastsegment;

        segments[s] = SegmentMulAny(nseg);

        for (i=0; i<nseg; i++) {
            e[s*148+i] ==> segments[s].e[i];
        }

        if (s==0) {
            // force G8 point if input point is zero
            segments[s].p[0] <== p[0] + (5299619240641551281634865583518297030282874472190772894086521144482721001553 - p[0])*zeropoint.out;
            segments[s].p[1] <== p[1] + (16950150798460657717958625567821834550301663161624707787222815936182638968203 - p[1])*zeropoint.out;
        } else {
            doublers[s-1] = MontgomeryDouble();
            m2e[s-1] = Montgomery2Edwards();
            adders[s-1] = BabyAdd();

            segments[s-1].dbl[0] ==> doublers[s-1].in[0];
            segments[s-1].dbl[1] ==> doublers[s-1].in[1];

            doublers[s-1].out[0] ==> m2e[s-1].in[0];
            doublers[s-1].out[1] ==> m2e[s-1].in[1];

            m2e[s-1].out[0] ==> segments[s].p[0];
            m2e[s-1].out[1] ==> segments[s].p[1];

            if (s==1) {
                segments[s-1].out[0] ==> adders[s-1].x1;
                segments[s-1].out[1] ==> adders[s-1].y1;
            } else {
                adders[s-2].xout ==> adders[s-1].x1;
                adders[s-2].yout ==> adders[s-1].y1;
            }
            segments[s].out[0] ==> adders[s-1].x2;
            segments[s].out[1] ==> adders[s-1].y2;
        }
    }

    if (nsegments == 1) {
        segments[0].out[0]*(1-zeropoint.out) ==> out[0];
        segments[0].out[1]+(1-segments[0].out[1])*zeropoint.out ==> out[1];
    } else {
        adders[nsegments-2].xout*(1-zeropoint.out) ==> out[0];
        adders[nsegments-2].yout+(1-adders[nsegments-2].yout)*zeropoint.out ==> out[1];
    }
}



================================================
FILE: circom/circomlib/escalarmulfix.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "mux3.circom";
include "montgomery.circom";
include "babyjub.circom";

/*
    Window of 3 elements, it calculates
        out = base + base*in[0] + 2*base*in[1] + 4*base*in[2]
        out4 = 4*base

    The result should be compensated.
 */

/*

    The scalar is s = a0 + a1*2^3 + a2*2^6 + ...... + a81*2^243
    First We calculate Q = B + 2^3*B + 2^6*B + ......... + 2^246*B

    Then we calculate S1 = 2*2^246*B + (1 + a0)*B + (2^3 + a1)*B + .....+ (2^243 + a81)*B

    And Finaly we compute the result: RES = SQ - Q

    As you can see the input of the adders cannot be equal nor zero, except for the last
    substraction that it's done in montgomery.

    A good way to see it is that the accumulator input of the adder >= 2^247*B and the other input
    is the output of the windows that it's going to be <= 2^246*B
 */
template WindowMulFix() {
    signal input in[3];
    signal input base[2];
    signal output out[2];
    signal output out8[2];   // Returns 8*Base (To be linked)

    component mux = MultiMux3(2);

    mux.s[0] <== in[0];
    mux.s[1] <== in[1];
    mux.s[2] <== in[2];

    component dbl2 = MontgomeryDouble();
    component adr3 = MontgomeryAdd();
    component adr4 = MontgomeryAdd();
    component adr5 = MontgomeryAdd();
    component adr6 = MontgomeryAdd();
    component adr7 = MontgomeryAdd();
    component adr8 = MontgomeryAdd();

// in[0]  -> 1*BASE

    mux.c[0][0] <== base[0];
    mux.c[1][0] <== base[1];

// in[1] -> 2*BASE
    dbl2.in[0] <== base[0];
    dbl2.in[1] <== base[1];
    mux.c[0][1] <== dbl2.out[0];
    mux.c[1][1] <== dbl2.out[1];

// in[2] -> 3*BASE
    adr3.in1[0] <== base[0];
    adr3.in1[1] <== base[1];
    adr3.in2[0] <== dbl2.out[0];
    adr3.in2[1] <== dbl2.out[1];
    mux.c[0][2] <== adr3.out[0];
    mux.c[1][2] <== adr3.out[1];

// in[3] -> 4*BASE
    adr4.in1[0] <== base[0];
    adr4.in1[1] <== base[1];
    adr4.in2[0] <== adr3.out[0];
    adr4.in2[1] <== adr3.out[1];
    mux.c[0][3] <== adr4.out[0];
    mux.c[1][3] <== adr4.out[1];

// in[4] -> 5*BASE
    adr5.in1[0] <== base[0];
    adr5.in1[1] <== base[1];
    adr5.in2[0] <== adr4.out[0];
    adr5.in2[1] <== adr4.out[1];
    mux.c[0][4] <== adr5.out[0];
    mux.c[1][4] <== adr5.out[1];

// in[5] -> 6*BASE
    adr6.in1[0] <== base[0];
    adr6.in1[1] <== base[1];
    adr6.in2[0] <== adr5.out[0];
    adr6.in2[1] <== adr5.out[1];
    mux.c[0][5] <== adr6.out[0];
    mux.c[1][5] <== adr6.out[1];

// in[6] -> 7*BASE
    adr7.in1[0] <== base[0];
    adr7.in1[1] <== base[1];
    adr7.in2[0] <== adr6.out[0];
    adr7.in2[1] <== adr6.out[1];
    mux.c[0][6] <== adr7.out[0];
    mux.c[1][6] <== adr7.out[1];

// in[7] -> 8*BASE
    adr8.in1[0] <== base[0];
    adr8.in1[1] <== base[1];
    adr8.in2[0] <== adr7.out[0];
    adr8.in2[1] <== adr7.out[1];
    mux.c[0][7] <== adr8.out[0];
    mux.c[1][7] <== adr8.out[1];

    out8[0] <== adr8.out[0];
    out8[1] <== adr8.out[1];

    out[0] <== mux.out[0];
    out[1] <== mux.out[1];
}


/*
    This component does a multiplication of a escalar times a fix base
    Signals:
        e: The scalar in bits
        base: the base point in edwards format
        out:  The result
        dbl: Point in Edwards to be linked to the next segment.
 */

template SegmentMulFix(nWindows) {
    signal input e[nWindows*3];
    signal input base[2];
    signal output out[2];
    signal output dbl[2];

    var i;
    var j;

    // Convert the base to montgomery

    component e2m = Edwards2Montgomery();
    e2m.in[0] <== base[0];
    e2m.in[1] <== base[1];

    component windows[nWindows];
    component adders[nWindows];
    component cadders[nWindows];

    // In the last step we add an extra doubler so that numbers do not match.
    component dblLast = MontgomeryDouble();

    for (i=0; i<nWindows; i++) {
        windows[i] = WindowMulFix();
        cadders[i] = MontgomeryAdd();
        if (i==0) {
            windows[i].base[0] <== e2m.out[0];
            windows[i].base[1] <== e2m.out[1];
            cadders[i].in1[0] <== e2m.out[0];
            cadders[i].in1[1] <== e2m.out[1];
        } else {
            windows[i].base[0] <== windows[i-1].out8[0];
            windows[i].base[1] <== windows[i-1].out8[1];
            cadders[i].in1[0] <== cadders[i-1].out[0];
            cadders[i].in1[1] <== cadders[i-1].out[1];
        }
        for (j=0; j<3; j++) {
            windows[i].in[j] <== e[3*i+j];
        }
        if (i<nWindows-1) {
            cadders[i].in2[0] <== windows[i].out8[0];
            cadders[i].in2[1] <== windows[i].out8[1];
        } else {
            dblLast.in[0] <== windows[i].out8[0];
            dblLast.in[1] <== windows[i].out8[1];
            cadders[i].in2[0] <== dblLast.out[0];
            cadders[i].in2[1] <== dblLast.out[1];
        }
    }

    for (i=0; i<nWindows; i++) {
        adders[i] = MontgomeryAdd();
        if (i==0) {
            adders[i].in1[0] <== dblLast.out[0];
            adders[i].in1[1] <== dblLast.out[1];
        } else {
            adders[i].in1[0] <== adders[i-1].out[0];
            adders[i].in1[1] <== adders[i-1].out[1];
        }
        adders[i].in2[0] <== windows[i].out[0];
        adders[i].in2[1] <== windows[i].out[1];
    }

    component m2e = Montgomery2Edwards();
    component cm2e = Montgomery2Edwards();

    m2e.in[0] <== adders[nWindows-1].out[0];
    m2e.in[1] <== adders[nWindows-1].out[1];
    cm2e.in[0] <== cadders[nWindows-1].out[0];
    cm2e.in[1] <== cadders[nWindows-1].out[1];

    component cAdd = BabyAdd();
    cAdd.x1 <== m2e.out[0];
    cAdd.y1 <== m2e.out[1];
    cAdd.x2 <== -cm2e.out[0];
    cAdd.y2 <== cm2e.out[1];

    cAdd.xout ==> out[0];
    cAdd.yout ==> out[1];

    windows[nWindows-1].out8[0] ==> dbl[0];
    windows[nWindows-1].out8[1] ==> dbl[1];
}


/*
This component multiplies a escalar times a fixed point BASE (twisted edwards format)
    Signals
        e: The escalar in binary format
        out: The output point in twisted edwards
 */
template EscalarMulFix(n, BASE) {
    signal input e[n];              // Input in binary format
    signal output out[2];           // Point (Twisted format)

    var nsegments = (n-1)\246 +1;       // 249 probably would work. But I'm not sure and for security I keep 246
    var nlastsegment = n - (nsegments-1)*249;

    component segments[nsegments];

    component m2e[nsegments-1];
    component adders[nsegments-1];

    var s;
    var i;
    var nseg;
    var nWindows;

    for (s=0; s<nsegments; s++) {

        nseg = (s < nsegments-1) ? 249 : nlastsegment;
        nWindows = ((nseg - 1)\3)+1;

        segments[s] = SegmentMulFix(nWindows);

        for (i=0; i<nseg; i++) {
            segments[s].e[i] <== e[s*249+i];
        }

        for (i = nseg; i<nWindows*3; i++) {
            segments[s].e[i] <== 0;
        }

        if (s==0) {
            segments[s].base[0] <== BASE[0];
            segments[s].base[1] <== BASE[1];
        } else {
            m2e[s-1] = Montgomery2Edwards();
            adders[s-1] = BabyAdd();

            segments[s-1].dbl[0] ==> m2e[s-1].in[0];
            segments[s-1].dbl[1] ==> m2e[s-1].in[1];

            m2e[s-1].out[0] ==> segments[s].base[0];
            m2e[s-1].out[1] ==> segments[s].base[1];

            if (s==1) {
                segments[s-1].out[0] ==> adders[s-1].x1;
                segments[s-1].out[1] ==> adders[s-1].y1;
            } else {
                adders[s-2].xout ==> adders[s-1].x1;
                adders[s-2].yout ==> adders[s-1].y1;
            }
            segments[s].out[0] ==> adders[s-1].x2;
            segments[s].out[1] ==> adders[s-1].y2;
        }
    }

    if (nsegments == 1) {
        segments[0].out[0] ==> out[0];
        segments[0].out[1] ==> out[1];
    } else {
        adders[nsegments-2].xout ==> out[0];
        adders[nsegments-2].yout ==> out[1];
    }
}



================================================
FILE: circom/circomlib/montgomery.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/

/*
    Source: https://en.wikipedia.org/wiki/Montgomery_curve

                1 + y       1 + y
    [u, v] = [ -------  , ---------- ]
                1 - y      (1 - y)x

 */
 pragma circom 2.1.9;

template Edwards2Montgomery() {
    signal input in[2];
    signal output out[2];

    out[0] <-- (1 + in[1]) / (1 - in[1]);
    out[1] <-- out[0] / in[0];


    out[0] * (1-in[1]) === (1 + in[1]);
    out[1] * in[0] === out[0];
}

/*

                u    u - 1
    [x, y] = [ ---, ------- ]
                v    u + 1

 */
template Montgomery2Edwards() {
    signal input in[2];
    signal output out[2];

    out[0] <-- in[0] / in[1];
    out[1] <-- (in[0] - 1) / (in[0] + 1);

    out[0] * in[1] === in[0];
    out[1] * (in[0] + 1) === in[0] - 1;
}


/*
             x2 - x1
    lamda = ---------
             y2 - y1

                                                    x3 + A + x1 + x2
    x3 = B * lamda^2 - A - x1 -x2    =>  lamda^2 = ------------------
                                                         B

    y3 = (2*x1 + x2 + A)*lamda - B*lamda^3 - y1  =>


    =>  y3 = lamda * ( 2*x1 + x2 + A  - x3 - A - x1 - x2)  - y1 =>

    =>  y3 = lamda * ( x1 - x3 ) - y1

----------

             y2 - y1
    lamda = ---------
             x2 - x1

    x3 = B * lamda^2 - A - x1 -x2

    y3 = lamda * ( x1 - x3 ) - y1

 */

template MontgomeryAdd() {
    signal input in1[2];
    signal input in2[2];
    signal output out[2];

    var a = 168700;
    var d = 168696;

    var A = (2 * (a + d)) / (a - d);
    var B = 4 / (a - d);

    signal lamda;

    lamda <-- (in2[1] - in1[1]) / (in2[0] - in1[0]);
    lamda * (in2[0] - in1[0]) === (in2[1] - in1[1]);

    out[0] <== B*lamda*lamda - A - in1[0] -in2[0];
    out[1] <== lamda * (in1[0] - out[0]) - in1[1];
}

/*

    x1_2 = x1*x1

             3*x1_2 + 2*A*x1 + 1
    lamda = ---------------------
                   2*B*y1

    x3 = B * lamda^2 - A - x1 -x1

    y3 = lamda * ( x1 - x3 ) - y1

 */
template MontgomeryDouble() {
    signal input in[2];
    signal output out[2];

    var a = 168700;
    var d = 168696;

    var A = (2 * (a + d)) / (a - d);
    var B = 4 / (a - d);

    signal lamda;
    signal x1_2;

    x1_2 <== in[0] * in[0];

    lamda <-- (3*x1_2 + 2*A*in[0] + 1 ) / (2*B*in[1]);
    lamda * (2*B*in[1]) === (3*x1_2 + 2*A*in[0] + 1 );

    out[0] <== B*lamda*lamda - A - 2*in[0];
    out[1] <== lamda * (in[0] - out[0]) - in[1];
}



================================================
FILE: circom/circomlib/mux3.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

template MultiMux3(n) {
    signal input c[n][8];  // Constants
    signal input s[3];   // Selector
    signal output out[n];

    signal a210[n];
    signal a21[n];
    signal a20[n];
    signal a2[n];

    signal a10[n];
    signal a1[n];
    signal a0[n];
    signal a[n];

    // 4 constrains for the intermediary variables
    signal  s10;
    s10 <== s[1] * s[0];

    for (var i=0; i<n; i++) {

         a210[i] <==  ( c[i][ 7]-c[i][ 6]-c[i][ 5]+c[i][ 4] - c[i][ 3]+c[i][ 2]+c[i][ 1]-c[i][ 0] ) * s10;
          a21[i] <==  ( c[i][ 6]-c[i][ 4]-c[i][ 2]+c[i][ 0] ) * s[1];
          a20[i] <==  ( c[i][ 5]-c[i][ 4]-c[i][ 1]+c[i][ 0] ) * s[0];
           a2[i] <==  ( c[i][ 4]-c[i][ 0] );

          a10[i] <==  ( c[i][ 3]-c[i][ 2]-c[i][ 1]+c[i][ 0] ) * s10;
           a1[i] <==  ( c[i][ 2]-c[i][ 0] ) * s[1];
           a0[i] <==  ( c[i][ 1]-c[i][ 0] ) * s[0];
            a[i] <==  ( c[i][ 0] );

          out[i] <== ( a210[i] + a21[i] + a20[i] + a2[i] ) * s[2] +
                     (  a10[i] +  a1[i] +  a0[i] +  a[i] );

    }
}



================================================
FILE: circom/circomlib/poseidon.circom
================================================
pragma circom 2.1.9;

include "./poseidon_constants.circom";

template Sigma() {
    signal input in;
    signal output out;

    signal in2;
    signal in4;

    in2 <== in*in;
    in4 <== in2*in2;

    out <== in4*in;
}

template Ark(t, C, r) {
    signal input in[t];
    signal output out[t];

    for (var i=0; i<t; i++) {
        out[i] <== in[i] + C[i + r];
    }
}

template Mix(t, M) {
    signal input in[t];
    signal output out[t];

    var lc;
    for (var i=0; i<t; i++) {
        lc = 0;
        for (var j=0; j<t; j++) {
            lc += M[j][i]*in[j];
        }
        out[i] <== lc;
    }
}

template MixLast(t, M, s) {
    signal input in[t];
    signal output out;

    var lc = 0;
    for (var j=0; j<t; j++) {
        lc += M[j][s]*in[j];
    }
    out <== lc;
}

template MixS(t, S, r) {
    signal input in[t];
    signal output out[t];


    var lc = 0;
    for (var i=0; i<t; i++) {
        lc += S[(t*2-1)*r+i]*in[i];
    }
    out[0] <== lc;
    for (var i=1; i<t; i++) {
        out[i] <== in[i] +  in[0] * S[(t*2-1)*r + t + i -1];
    }
}

template PoseidonEx(nInputs, nOuts) {
    signal input inputs[nInputs];
    signal input initialState;
    signal output out[nOuts];

    // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
    // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    // And rounded up to nearest integer that divides by t
    var N_ROUNDS_P[16] = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
    var t = nInputs + 1;
    var nRoundsF = 8;
    var nRoundsP = N_ROUNDS_P[t - 2];
    var C[t*nRoundsF + nRoundsP] = POSEIDON_C(t);
    var S[  N_ROUNDS_P[t-2]  *  (t*2-1)  ]  = POSEIDON_S(t);
    var M[t][t] = POSEIDON_M(t);
    var P[t][t] = POSEIDON_P(t);

    component ark[nRoundsF];
    component sigmaF[nRoundsF][t];
    component sigmaP[nRoundsP];
    component mix[nRoundsF-1];
    component mixS[nRoundsP];
    component mixLast[nOuts];


    ark[0] = Ark(t, C, 0);
    for (var j=0; j<t; j++) {
        if (j>0) {
            ark[0].in[j] <== inputs[j-1];
        } else {
            ark[0].in[j] <== initialState;
        }
    }

    for (var r = 0; r < nRoundsF\2-1; r++) {
        for (var j=0; j<t; j++) {
            sigmaF[r][j] = Sigma();
            if(r==0) {
                sigmaF[r][j].in <== ark[0].out[j];
            } else {
                sigmaF[r][j].in <== mix[r-1].out[j];
            }
        }

        ark[r+1] = Ark(t, C, (r+1)*t);
        for (var j=0; j<t; j++) {
            ark[r+1].in[j] <== sigmaF[r][j].out;
        }

        mix[r] = Mix(t,M);
        for (var j=0; j<t; j++) {
            mix[r].in[j] <== ark[r+1].out[j];
        }

    }

    for (var j=0; j<t; j++) {
        sigmaF[nRoundsF\2-1][j] = Sigma();
        sigmaF[nRoundsF\2-1][j].in <== mix[nRoundsF\2-2].out[j];
    }

    ark[nRoundsF\2] = Ark(t, C, (nRoundsF\2)*t );
    for (var j=0; j<t; j++) {
        ark[nRoundsF\2].in[j] <== sigmaF[nRoundsF\2-1][j].out;
    }

    mix[nRoundsF\2-1] = Mix(t,P);
    for (var j=0; j<t; j++) {
        mix[nRoundsF\2-1].in[j] <== ark[nRoundsF\2].out[j];
    }


    for (var r = 0; r < nRoundsP; r++) {
        sigmaP[r] = Sigma();
        if (r==0) {
            sigmaP[r].in <== mix[nRoundsF\2-1].out[0];
        } else {
            sigmaP[r].in <== mixS[r-1].out[0];
        }

        mixS[r] = MixS(t, S, r);
        for (var j=0; j<t; j++) {
            if (j==0) {
                mixS[r].in[j] <== sigmaP[r].out + C[(nRoundsF\2+1)*t + r];
            } else {
                if (r==0) {
                    mixS[r].in[j] <== mix[nRoundsF\2-1].out[j];
                } else {
                    mixS[r].in[j] <== mixS[r-1].out[j];
                }
            }
        }
    }

    for (var r = 0; r < nRoundsF\2-1; r++) {
        for (var j=0; j<t; j++) {
            sigmaF[nRoundsF\2 + r][j] = Sigma();
            if (r==0) {
                sigmaF[nRoundsF\2 + r][j].in <== mixS[nRoundsP-1].out[j];
            } else {
                sigmaF[nRoundsF\2 + r][j].in <== mix[nRoundsF\2+r-1].out[j];
            }
        }

        ark[ nRoundsF\2 + r + 1] = Ark(t, C,  (nRoundsF\2+1)*t + nRoundsP + r*t );
        for (var j=0; j<t; j++) {
            ark[nRoundsF\2 + r + 1].in[j] <== sigmaF[nRoundsF\2 + r][j].out;
        }

        mix[nRoundsF\2 + r] = Mix(t,M);
        for (var j=0; j<t; j++) {
            mix[nRoundsF\2 + r].in[j] <== ark[nRoundsF\2 + r + 1].out[j];
        }

    }

    for (var j=0; j<t; j++) {
        sigmaF[nRoundsF-1][j] = Sigma();
        sigmaF[nRoundsF-1][j].in <== mix[nRoundsF-2].out[j];
    }

    for (var i=0; i<nOuts; i++) {
        mixLast[i] = MixLast(t,M,i);
        for (var j=0; j<t; j++) {
            mixLast[i].in[j] <== sigmaF[nRoundsF-1][j].out;
        }
        out[i] <== mixLast[i].out;
    }

}

template Poseidon(nInputs) {
    signal input inputs[nInputs];
    signal output out;

    component pEx = PoseidonEx(nInputs, 1);
    pEx.initialState <== 0;
    for (var i=0; i<nInputs; i++) {
        pEx.inputs[i] <== inputs[i];
    }
    out <== pEx.out[0];
}



================================================
FILE: circom/circomlib/poseidon_old.circom
================================================
pragma circom 2.1.9;

include "./poseidon_constants.circom";

template Sigma() {
    signal input in;
    signal output out;

    signal in2;
    signal in4;

    in2 <== in*in;
    in4 <== in2*in2;

    out <== in4*in;
}

template Ark(t, C, r) {
    signal input in[t];
    signal output out[t];

    for (var i=0; i<t; i++) {
        out[i] <== in[i] + C[i + r];
    }
}

template Mix(t, M) {
    signal input in[t];
    signal output out[t];

    var lc;
    for (var i=0; i<t; i++) {
        lc = 0;
        for (var j=0; j<t; j++) {
            lc += M[i][j]*in[j];
        }
        out[i] <== lc;
    }
}

template Poseidon(nInputs) {
    signal input inputs[nInputs];
    signal output out;

    // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
    // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    // And rounded up to nearest integer that divides by t
    var N_ROUNDS_P[16] = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
    var t = nInputs + 1;
    var nRoundsF = 8;
    var nRoundsP = N_ROUNDS_P[t - 2];
    var C[t*(nRoundsF + nRoundsP)] = POSEIDON_C(t);
    var M[t][t] = POSEIDON_M(t);

    component ark[nRoundsF + nRoundsP];
    component sigmaF[nRoundsF][t];
    component sigmaP[nRoundsP];
    component mix[nRoundsF + nRoundsP];

    var k;

    for (var i=0; i<nRoundsF + nRoundsP; i++) {
        ark[i] = Ark(t, C, t*i);
        for (var j=0; j<t; j++) {
            if (i==0) {
                if (j>0) {
                    ark[i].in[j] <== inputs[j-1];
                } else {
                    ark[i].in[j] <== 0;
                }
            } else {
                ark[i].in[j] <== mix[i-1].out[j];
            }
        }

        if (i < nRoundsF/2 || i >= nRoundsP + nRoundsF/2) {
            k = i < nRoundsF/2 ? i : i - nRoundsP;
            mix[i] = Mix(t, M);
            for (var j=0; j<t; j++) {
                sigmaF[k][j] = Sigma();
                sigmaF[k][j].in <== ark[i].out[j];
                mix[i].in[j] <== sigmaF[k][j].out;
            }
        } else {
            k = i - nRoundsF/2;
            mix[i] = Mix(t, M);
            sigmaP[k] = Sigma();
            sigmaP[k].in <== ark[i].out[0];
            mix[i].in[0] <== sigmaP[k].out;
            for (var j=1; j<t; j++) {
                mix[i].in[j] <== ark[i].out[j];
            }
        }
    }

    out <== mix[nRoundsF + nRoundsP -1].out[0];
}



================================================
FILE: contracts/EncryptedERC.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem
pragma solidity 0.8.27;

// contracts
import {TokenTracker} from "./tokens/TokenTracker.sol";
import {EncryptedUserBalances} from "./EncryptedUserBalances.sol";
import {AuditorManager} from "./auditor/AuditorManager.sol";
import {EncryptedMetadata} from "./metadata/EncryptedMetadata.sol";

// libraries
import {BabyJubJub} from "./libraries/BabyJubJub.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

// types
import {CreateEncryptedERCParams, Point, EGCT, EncryptedBalance, AmountPCT, MintProof, TransferProof, WithdrawProof, BurnProof, TransferInputs} from "./types/Types.sol";

// errors
import {UserNotRegistered, InvalidProof, TransferFailed, UnknownToken, InvalidChainId, InvalidNullifier, ZeroAddress} from "./errors/Errors.sol";

// interfaces
import {IRegistrar} from "./interfaces/IRegistrar.sol";
import {IMintVerifier} from "./interfaces/verifiers/IMintVerifier.sol";
import {IWithdrawVerifier} from "./interfaces/verifiers/IWithdrawVerifier.sol";
import {ITransferVerifier} from "./interfaces/verifiers/ITransferVerifier.sol";
import {IBurnVerifier} from "./interfaces/verifiers/IBurnVerifier.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

//             /$$$$$$$$ /$$$$$$$   /$$$$$$
//            | $$_____/| $$__  $$ /$$__  $$
//    /$$$$$$ | $$      | $$  \ $$| $$  \__/
//   /$$__  $$| $$$$$   | $$$$$$$/| $$  | $$
//  | $$_____/| $$      | $$  \ $$| $$  | $$
//  |  $$$$$$$| $$$$$$$$| $$  | $$|  $$$$$$/
//   \_______/|________/|__/  |__/ \______/
//
/**
 * @title EncryptedERC
 * @notice A privacy-preserving ERC20 token implementation that uses zero-knowledge proofs for managing balances in encrypted manner.
 * @dev This contract implements Encrypted ERC operations using zero-knowledge proofs.
 *
 * Key features:
 * - Encrypted ERC has 2 modes:
 *   - Standalone Mode: Act like a standalone ERC20 token (mint, burn, transfer)
 *   - Converter Mode: Wraps existing ERC20 tokens and encrypted ERC20 tokens (deposit, withdraw, transfer)
 * - Auditor Manager: Manages auditor's public key
 * - Token Tracker: Manages ERC20 token registration for deposit and withdrawal
 * - Encrypted User Balances: Manages encrypted balances for users in encrypted manner
 *
 * The contract uses three main components:
 * 1. TokenTracker: Manages token registration and tracking
 * 2. EncryptedUserBalances: Handles encrypted balance storage and updates
 * 3. AuditorManager: Manages auditor-related functionality
 */
contract EncryptedERC is
    TokenTracker,
    EncryptedUserBalances,
    AuditorManager,
    EncryptedMetadata
{
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice Address of the registrar contract that manages user registration
    IRegistrar public registrar;

    /// @notice Verifier contracts for each operation
    IMintVerifier public mintVerifier;
    IWithdrawVerifier public withdrawVerifier;
    ITransferVerifier public transferVerifier;
    IBurnVerifier public burnVerifier;

    /// @notice Token metadata
    string public name;
    string public symbol;
    uint8 public immutable decimals;

    /// @notice Mapping to track used mint nullifiers to prevent double-minting
    mapping(uint256 mintNullifier => bool isUsed) public alreadyMinted;

    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when a private mint operation occurs
     * @param user Address of the user receiving the minted tokens
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when tokens are privately minted to a user
     */
    event PrivateMint(
        address indexed user,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    /**
     * @notice Emitted when a private burn operation occurs
     * @param user Address of the user burning the tokens
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when tokens are privately burned by a user
     */
    event PrivateBurn(
        address indexed user,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    /**
     * @notice Emitted when a private transfer operation occurs
     * @param from Address of the sender
     * @param to Address of the receiver
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when tokens are privately transferred between users
     */
    event PrivateTransfer(
        address indexed from,
        address indexed to,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    /**
     * @notice Emitted when a deposit operation occurs
     * @param user Address of the user making the deposit
     * @param amount Amount of tokens deposited
     * @param dust Amount of dust (remainder) from the deposit
     * @param tokenId ID of the token being deposited
     * @dev This event is emitted when a user deposits tokens into the contract
     */
    event Deposit(
        address indexed user,
        uint256 amount,
        uint256 dust,
        uint256 tokenId
    );

    /**
     * @notice Emitted when a withdrawal operation occurs
     * @param user Address of the user making the withdrawal
     * @param amount Amount of tokens withdrawn
     * @param tokenId ID of the token being withdrawn
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when a user withdraws tokens from the contract
     */
    event Withdraw(
        address indexed user,
        uint256 amount,
        uint256 tokenId,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    ///////////////////////////////////////////////////
    ///                   Modifiers                 ///
    ///////////////////////////////////////////////////
    modifier onlyIfUserRegistered(address user) {
        bool isRegistered = registrar.isUserRegistered(user);
        if (!isRegistered) {
            revert UserNotRegistered();
        }
        _;
    }

    ///////////////////////////////////////////////////
    ///                   Constructor               ///
    ///////////////////////////////////////////////////

    /**
     * @notice Initializes the EncryptedERC contract with the given parameters
     * @param params The initialization parameters containing contract addresses and token metadata
     * @dev This constructor sets up the contract with necessary verifiers, registrar, and token metadata.
     *      It also determines whether the contract will function as a converter or standalone token.
     */
    constructor(
        CreateEncryptedERCParams memory params
    ) TokenTracker(params.isConverter) {
        // Validate contract addresses
        if (
            params.registrar == address(0) ||
            params.mintVerifier == address(0) ||
            params.withdrawVerifier == address(0) ||
            params.transferVerifier == address(0) ||
            params.burnVerifier == address(0)
        ) {
            revert ZeroAddress();
        }

        // Initialize contracts
        registrar = IRegistrar(params.registrar);
        mintVerifier = IMintVerifier(params.mintVerifier);
        withdrawVerifier = IWithdrawVerifier(params.withdrawVerifier);
        transferVerifier = ITransferVerifier(params.transferVerifier);
        burnVerifier = IBurnVerifier(params.burnVerifier);

        // if contract is not a converter, then set the name and symbol
        if (!params.isConverter) {
            name = params.name;
            symbol = params.symbol;
        }

        decimals = params.decimals;
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Sets the auditor's public key for a registered user
     * @param user Address of the user to set as auditor
     * @dev This function:
     *      1. Verifies the user is registered
     *      2. Retrieves the user's public key
     *      3. Updates the auditor's information
     *
     * Requirements:
     * - Caller must be the contract owner
     * - User must be registered
     */
    function setAuditorPublicKey(
        address user
    ) external onlyOwner onlyIfUserRegistered(user) {
        uint256[2] memory publicKey_ = registrar.getUserPublicKey(user);
        _updateAuditor(user, publicKey_);
    }

    /**
     * @notice Performs a private mint operation for a registered user
     * @param user The address of the user to mint tokens to
     * @param proof The zero-knowledge proof proving the validity of the mint operation
     * @dev This function:
     *      1. Validates the chain ID and user registration
     *      2. Verifies the user's public key matches the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Checks the mint nullifier hasn't been used
     *      5. Verifies the zero-knowledge proof
     *      6. Updates the user's encrypted balance
     *
     * Requirements:
     * - Caller must be the contract owner
     * - Auditor must be set
     * - Contract must be in standalone mode
     * - User must be registered
     * - Proof must be valid
     */
    function privateMint(
        address user,
        MintProof calldata proof
    )
        external
        onlyOwner
        onlyIfAuditorSet
        onlyForStandalone
        onlyIfUserRegistered(user)
    {
        // executes the private mint operation
        _executePrivateMint(user, proof, bytes(""));
    }

    /**
     * @notice Performs a private mint operation for a registered user with additional metadata
     * @param user The address of the user to mint tokens to
     * @param proof The zero-knowledge proof proving the validity of the mint operation
     * @param message Additional metadata message to be emitted with the mint event
     * @dev This function:
     *      1. Validates the chain ID and user registration
     *      2. Verifies the user's public key matches the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Checks the mint nullifier hasn't been used
     *      5. Verifies the zero-knowledge proof
     *      6. Updates the user's encrypted balance
     *      7. Emits the mint event with the provided message
     *
     * Requirements:
     * - Caller must be the contract owner
     * - Auditor must be set
     * - Contract must be in standalone mode
     * - User must be registered
     * - Proof must be valid
     */
    function privateMint(
        address user,
        MintProof calldata proof,
        bytes calldata message
    )
        external
        onlyOwner
        onlyIfAuditorSet
        onlyForStandalone
        onlyIfUserRegistered(user)
    {
        // executes the private mint operation with message
        _executePrivateMint(user, proof, message);
    }

    /**
     * @notice Performs a private burn operation
     * @param proof The transfer proof proving the validity of the burn operation
     * @param balancePCT The balance PCT for the sender after the burn
     * @dev This function:
     *      1. Validates the sender is registered
     *      2. Verifies the sender's public key matches the proof
     *      3. Verifies the burn address's public key matches the proof
     *      4. Verifies the auditor's public key matches the proof
     *      5. Verifies the zero-knowledge proof
     *      6. Transfers the encrypted amount to the burn address
     *
     * Requirements:
     * - Auditor must be set
     * - Contract must be in standalone mode
     * - Sender must be registered
     * - Proof must be valid
     */
    function privateBurn(
        BurnProof calldata proof,
        uint256[7] calldata balancePCT
    )
        external
        onlyIfAuditorSet
        onlyForStandalone
        onlyIfUserRegistered(msg.sender)
    {
        _executePrivateBurn(proof, balancePCT, bytes(""));
    }

    /**
     * @notice Performs a private burn operation with additional metadata
     * @param user The address of the user to burn tokens from
     * @param proof The zero-knowledge proof proving the validity of the burn operation
     * @param balancePCT The balance PCT for the user after the burn
     * @param message Additional metadata message to be emitted with the burn event
     */
    function privateBurn(
        address user,
        BurnProof calldata proof,
        uint256[7] calldata balancePCT,
        bytes calldata message
    ) external onlyIfAuditorSet onlyForStandalone onlyIfUserRegistered(user) {
        _executePrivateBurn(proof, balancePCT, message);
    }

    /**
     * @notice Performs a private transfer between two users
     * @param to Address of the receiver
     * @param tokenId ID of the token to transfer
     * @param proof The transfer proof proving the validity of the transfer
     * @param balancePCT The balance PCT for the sender after the transfer
     * @dev This function:
     *      1. Validates both sender and receiver are registered
     *      2. Verifies both public keys match the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Verifies the zero-knowledge proof
     *      5. Updates both users' encrypted balances
     *
     * Requirements:
     * - Auditor must be set
     * - Both sender and receiver must be registered
     * - Proof must be valid
     */
    function transfer(
        address to,
        uint256 tokenId,
        TransferProof memory proof,
        uint256[7] calldata balancePCT
    )
        external
        onlyIfAuditorSet
        onlyIfUserRegistered(msg.sender)
        onlyIfUserRegistered(to)
    {
        _executePrivateTransfer(to, tokenId, proof, balancePCT, bytes(""));
    }

    /**
     * @notice Performs a private transfer between two users with additional metadata
     * @param to Address of the receiver
     * @param tokenId ID of the token to transfer
     * @param proof The transfer proof proving the validity of the transfer
     * @param balancePCT The balance PCT for the sender after the transfer
     * @param message Additional metadata message to be emitted with the transfer event
     */
    function transfer(
        address to,
        uint256 tokenId,
        TransferProof memory proof,
        uint256[7] calldata balancePCT,
        bytes calldata message
    )
        external
        onlyIfAuditorSet
        onlyIfUserRegistered(msg.sender)
        onlyIfUserRegistered(to)
    {
        _executePrivateTransfer(to, tokenId, proof, balancePCT, message);
    }

    /**
     * @notice Deposits an existing ERC20 token into the contract
     * @param amount Amount of tokens to deposit
     * @param tokenAddress Address of the token to deposit
     * @param amountPCT Amount PCT for the deposit
     * @dev This function:
     *      1. Validates the user is registered
     *      2. Transfers the tokens from the user to the contract
     *      3. Converts the tokens to encrypted tokens
     *      4. Adds the encrypted amount to the user's balance
     *      5. Returns any dust (remainder) to the user
     *
     * Requirements:
     * - Auditor must be set
     * - Contract must be in converter mode
     * - Token must not be blacklisted
     * - User must be registered
     */
    function deposit(
        uint256 amount,
        address tokenAddress,
        uint256[7] memory amountPCT
    )
        external
        onlyIfAuditorSet
        onlyForConverter
        revertIfBlacklisted(tokenAddress)
        onlyIfUserRegistered(msg.sender)
    {
        _executeDeposit(amount, tokenAddress, amountPCT, bytes(""));
    }

    /**
     * @notice Deposits an existing ERC20 token into the contract with additional metadata
     * @param amount Amount of tokens to deposit
     * @param tokenAddress Address of the token to deposit
     * @param amountPCT Amount PCT for the deposit
     * @param message Additional metadata message to be emitted with the deposit event
     */
    function deposit(
        uint256 amount,
        address tokenAddress,
        uint256[7] memory amountPCT,
        bytes calldata message
    )
        external
        onlyIfAuditorSet
        onlyForConverter
        revertIfBlacklisted(tokenAddress)
        onlyIfUserRegistered(msg.sender)
    {
        _executeDeposit(amount, tokenAddress, amountPCT, message);
    }

    /**
     * @notice Withdraws encrypted tokens as regular ERC20 tokens
     * @param tokenId ID of the token to withdraw
     * @param proof The withdraw proof proving the validity of the withdrawal
     * @param balancePCT The balance PCT for the user after the withdrawal
     * @dev This function:
     *      1. Validates the user is registered
     *      2. Verifies the user's public key matches the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Verifies the zero-knowledge proof
     *      5. Subtracts the encrypted amount from the user's balance
     *      6. Converts the tokens to regular ERC20 tokens
     *
     * Requirements:
     * - Auditor must be set
     * - Contract must be in converter mode
     * - User must be registered
     * - Proof must be valid
     */
    function withdraw(
        uint256 tokenId,
        WithdrawProof memory proof,
        uint256[7] memory balancePCT
    )
        external
        onlyIfAuditorSet
        onlyForConverter
        onlyIfUserRegistered(msg.sender)
    {
        _executeWithdraw(tokenId, proof, balancePCT, bytes(""));
    }

    /**
     * @notice Withdraws encrypted tokens as regular ERC20 tokens with additional metadata
     * @param tokenId ID of the token to withdraw
     * @param proof The withdraw proof proving the validity of the withdrawal
     * @param balancePCT The balance PCT for the user after the withdrawal
     * @param message Additional metadata message to be emitted with the withdrawal event
     */
    function withdraw(
        uint256 tokenId,
        WithdrawProof memory proof,
        uint256[7] memory balancePCT,
        bytes calldata message
    )
        external
        onlyIfAuditorSet
        onlyForConverter
        onlyIfUserRegistered(msg.sender)
    {
        _executeWithdraw(tokenId, proof, balancePCT, message);
    }

    function sendEncryptedMetadata(
        address to,
        bytes calldata message
    ) external onlyIfUserRegistered(msg.sender) onlyIfUserRegistered(to) {
        _sendEncryptedMetadata(to, message);
    }

    /**
     * @notice Gets the encrypted balance for a token address
     * @param user Address of the user
     * @param tokenAddress Address of the token
     * @return eGCT The ElGamal ciphertext representing the encrypted balance
     * @return nonce The current nonce used for balance validation
     * @return amountPCTs Array of amount PCTs for transaction history
     * @return balancePCT The current balance PCT
     * @return transactionIndex The current transaction index
     * @dev This is a convenience function that looks up the token ID and calls balanceOf
     */
    function getBalanceFromTokenAddress(
        address user,
        address tokenAddress
    )
        public
        view
        returns (
            EGCT memory eGCT,
            uint256 nonce,
            AmountPCT[] memory amountPCTs,
            uint256[7] memory balancePCT,
            uint256 transactionIndex
        )
    {
        uint256 tokenId = tokenIds[tokenAddress];
        return balanceOf(user, tokenId);
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Performs the internal logic for a private withdrawal
     * @param from Address of the user withdrawing tokens
     * @param amount Amount of tokens to withdraw
     * @param tokenId ID of the token to withdraw
     * @param publicInputs Public inputs from the proof
     * @param balancePCT The balance PCT for the user after the withdrawal
     * @dev This function:
     *      1. Validates the token exists
     *      2. Verifies the provided balance is valid
     *      3. Subtracts the encrypted amount from the user's balance
     *      4. Converts the tokens to regular ERC20 tokens
     */
    function _withdraw(
        address from,
        uint256 amount,
        uint256 tokenId,
        uint256[16] memory publicInputs,
        uint256[7] memory balancePCT
    ) internal {
        address tokenAddress = tokenAddresses[tokenId];
        if (tokenAddress == address(0)) {
            revert UnknownToken();
        }

        {
            // Extract the provided balance from the proof
            EGCT memory providedBalance = EGCT({
                c1: Point({x: publicInputs[3], y: publicInputs[4]}),
                c2: Point({x: publicInputs[5], y: publicInputs[6]})
            });

            // Encrypt the withdrawn amount
            EGCT memory encryptedWithdrawnAmount = BabyJubJub.encrypt(
                Point({x: publicInputs[1], y: publicInputs[2]}),
                amount
            );

            _privateBurn(
                from,
                tokenId,
                providedBalance,
                encryptedWithdrawnAmount,
                balancePCT
            );
        }

        // Convert and transfer the tokens
        _convertTo(from, amount, tokenAddress);
    }

    /**
     * @notice Converts regular ERC20 tokens to encrypted tokens
     * @param to Address of the receiver
     * @param amount Amount of tokens to convert
     * @param tokenAddress Address of the token to convert
     * @param amountPCT Amount PCT for the conversion
     * @return dust The dust (remainder) from the conversion
     * @return tokenId The ID of the token
     * @dev This function:
     *      1. Handles decimal scaling between tokens
     *      2. Registers the token if it's new
     *      3. Encrypts the amount with the receiver's public key
     *      4. Adds the encrypted amount to the receiver's balance
     */
    function _convertFrom(
        address to,
        uint256 amount,
        address tokenAddress,
        uint256[7] memory amountPCT
    ) internal returns (uint256 dust, uint256 tokenId) {
        // Get token decimals and handle scaling
        uint8 tokenDecimals = IERC20Metadata(tokenAddress).decimals();

        uint256 value = amount;
        dust = 0;

        // Scale down if token has more decimals
        if (tokenDecimals > decimals) {
            uint256 scalingFactor = 10 ** (tokenDecimals - decimals);
            value = amount / scalingFactor;
            dust = amount % scalingFactor;
        }
        // Scale up if token has fewer decimals
        else if (tokenDecimals < decimals) {
            uint256 scalingFactor = 10 ** (decimals - tokenDecimals);
            value = amount * scalingFactor;
            dust = 0;
        }

        // Register the token if it's new
        if (tokenIds[tokenAddress] == 0) {
            _addToken(tokenAddress);
        }
        tokenId = tokenIds[tokenAddress];

        // Return early if the scaled value is zero
        if (value == 0) {
            return (dust, tokenId);
        }

        // Encrypt and add to balance
        {
            // Get the receiver's public key
            uint256[2] memory publicKey = registrar.getUserPublicKey(to);

            // Encrypt the value with the receiver's public key
            EGCT memory eGCT = BabyJubJub.encrypt(
                Point({x: publicKey[0], y: publicKey[1]}),
                value
            );

            // Add to the receiver's balance
            EncryptedBalance storage balance = balances[to][tokenId];

            if (balance.eGCT.c1.x == 0 && balance.eGCT.c1.y == 0) {
                balance.eGCT = eGCT;
            } else {
                balance.eGCT.c1 = BabyJubJub._add(balance.eGCT.c1, eGCT.c1);
                balance.eGCT.c2 = BabyJubJub._add(balance.eGCT.c2, eGCT.c2);
            }

            // Update transaction history
            balance.amountPCTs.push(
                AmountPCT({pct: amountPCT, index: balance.transactionIndex})
            );
            balance.transactionIndex++;

            // Commit the new balance
            _commitUserBalance(to, tokenId);
        }

        return (dust, tokenId);
    }

    /**
     * @notice Converts encrypted tokens to regular ERC20 tokens
     * @param to Address of the receiver
     * @param amount Amount of tokens to convert
     * @param tokenAddress Address of the token to convert to
     * @dev This function:
     *      1. Handles decimal scaling between tokens
     *      2. Transfers the tokens to the receiver
     */
    function _convertTo(
        address to,
        uint256 amount,
        address tokenAddress
    ) internal {
        // Get token decimals and handle scaling
        uint256 tokenDecimals = IERC20Metadata(tokenAddress).decimals();

        uint256 value = amount;
        uint256 scalingFactor = 0;

        // Scale up if token has more decimals
        if (tokenDecimals > decimals) {
            scalingFactor = 10 ** (tokenDecimals - decimals);
            value = amount * scalingFactor;
        }
        // Scale down if token has fewer decimals
        else if (tokenDecimals < decimals) {
            scalingFactor = 10 ** (decimals - tokenDecimals);
            value = amount / scalingFactor;
        }

        // Transfer the tokens to the receiver
        IERC20 token = IERC20(tokenAddress);
        SafeERC20.safeTransfer(token, to, value);
    }

    /**
     * @notice Performs the internal logic for a private transfer
     * @param from address The address of the sender
     * @param to address The address of the receiver
     * @param tokenId uint256 The ID of the token to transfer
     * @param providedBalance EGCT The provided balance from the proof
     * @param senderEncryptedAmount EGCT The encrypted amount to subtract from the sender's balance
     * @param receiverEncryptedAmount EGCT The encrypted amount to add to the receiver's balance
     * @param balancePCT uint256[7] The balance PCT for the sender after the transfer
     * @param amountPCT uint256[7] The amount PCT for the transfer
     * @dev This function:
     *      1. Verifies the sender's balance is valid
     *      2. Subtracts the encrypted amount from the sender's balance
     *      3. Adds the encrypted amount to the receiver's balance
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId,
        EGCT memory providedBalance,
        EGCT memory senderEncryptedAmount,
        EGCT memory receiverEncryptedAmount,
        uint256[7] memory balancePCT,
        uint256[7] memory amountPCT
    ) internal {
        {
            // 1. for sender operation is very similar to the private burn
            _privateBurn(
                from,
                tokenId,
                providedBalance,
                senderEncryptedAmount,
                balancePCT
            );
        }

        {
            // 2. for receiver operation is very similar to the private mint
            _addToUserBalance(to, tokenId, receiverEncryptedAmount, amountPCT);
        }
    }

    /**
     * @notice Executes a private transfer operation
     * @param to Address of the receiver
     * @param tokenId ID of the token to transfer
     * @param proof The zero-knowledge proof proving the validity of the transfer operation
     * @param balancePCT The balance PCT for the sender after the transfer
     */
    function _executePrivateTransfer(
        address to,
        uint256 tokenId,
        TransferProof memory proof,
        uint256[7] memory balancePCT,
        bytes memory message
    ) internal {
        uint256[32] memory publicInputs = proof.publicSignals;

        // validate user's public key
        _validatePublicKey(msg.sender, [publicInputs[0], publicInputs[1]]);
        _validatePublicKey(to, [publicInputs[10], publicInputs[11]]);

        _validateAuditorPublicKey([publicInputs[23], publicInputs[24]]);

        // Verify the zero-knowledge proof
        bool isVerified = transferVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        // Extract the inputs for the transfer operation
        TransferInputs memory transferInputs = _extractTransferInputs(
            publicInputs
        );

        // Perform the transfer
        _transfer({
            from: msg.sender,
            to: to,
            tokenId: tokenId,
            providedBalance: transferInputs.providedBalance,
            senderEncryptedAmount: transferInputs.senderEncryptedAmount,
            receiverEncryptedAmount: transferInputs.receiverEncryptedAmount,
            balancePCT: balancePCT,
            amountPCT: transferInputs.amountPCT
        });

        // Extract auditor PCT and emit event
        {
            uint256[7] memory auditorPCT;
            for (uint256 i = 0; i < 7; i++) {
                auditorPCT[i] = publicInputs[25 + i];
            }

            emit PrivateTransfer(msg.sender, to, auditorPCT, auditor);
        }

        // emit metadata if message is provided
        _emitMetadata(msg.sender, to, "PRIVATE_TRANSFER", message);
    }

    /**
     * @notice Performs the internal logic for a private burn
     * @param from Address of the user to burn tokens from
     * @param tokenId ID of the token to burn
     * @param providedBalance The provided balance from the proof
     * @param encryptedAmount The encrypted amount to subtract
     * @param balancePCT The balance PCT for the user after the burn
     * @dev This function:
     *      1. Verifies the user's balance is valid
     *      2. Subtracts the encrypted amount from the user's balance
     */
    function _privateBurn(
        address from,
        uint256 tokenId,
        EGCT memory providedBalance,
        EGCT memory encryptedAmount,
        uint256[7] memory balancePCT
    ) internal {
        // verify user encrypted balance
        uint256 transactionIndex = _verifyUserBalance(
            from,
            tokenId,
            providedBalance
        );

        // subtract from user's balance
        _subtractFromUserBalance(
            from,
            tokenId,
            encryptedAmount,
            balancePCT,
            transactionIndex
        );
    }

    /**
     * @notice Performs the internal logic for a private mint
     * @param user Address of the user to mint tokens to
     * @param proof The zero-knowledge proof proving the validity of the mint operation
     * @param message Additional metadata message to be emitted with the mint event
     */
    function _executePrivateMint(
        address user,
        MintProof calldata proof,
        bytes memory message
    ) internal {
        uint256[24] memory publicInputs = proof.publicSignals;

        // Validate chain ID
        if (block.chainid != publicInputs[0]) {
            revert InvalidChainId();
        }

        // validate public keys
        _validatePublicKey(user, [publicInputs[2], publicInputs[3]]);
        _validateAuditorPublicKey([publicInputs[15], publicInputs[16]]);

        // Validate and check mint nullifier
        uint256 mintNullifier = publicInputs[1];
        if (mintNullifier >= BabyJubJub.Q) {
            revert InvalidNullifier();
        }
        if (alreadyMinted[mintNullifier]) {
            revert InvalidProof();
        }

        // Verify the zero-knowledge proof
        bool isVerified = mintVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        {
            // Extract the encrypted amount from the proof
            EGCT memory encryptedAmount = EGCT({
                c1: Point({x: publicInputs[4], y: publicInputs[5]}),
                c2: Point({x: publicInputs[6], y: publicInputs[7]})
            });

            // Extract amount PCT
            uint256[7] memory amountPCT;
            for (uint256 i = 0; i < 7; i++) {
                amountPCT[i] = publicInputs[8 + i];
            }

            // since private mint is only for the standalone ERC, tokenId is always 0
            _addToUserBalance(user, 0, encryptedAmount, amountPCT);
        }

        // mark the mint nullifier as used
        alreadyMinted[mintNullifier] = true;

        uint256[7] memory auditorPCT;
        for (uint256 i = 0; i < auditorPCT.length; i++) {
            auditorPCT[i] = publicInputs[17 + i];
        }

        emit PrivateMint(user, auditorPCT, auditor);

        // emit metadata if message is provided
        _emitMetadata(msg.sender, user, "PRIVATE_MINT", message);
    }

    /**
     * @notice Executes a private burn operation
     * @param proof The zero-knowledge proof proving the validity of the burn operation
     * @param balancePCT The balance PCT for the user after the burn
     * @param message Additional metadata message to be emitted with the burn event
     */
    function _executePrivateBurn(
        BurnProof calldata proof,
        uint256[7] calldata balancePCT,
        bytes memory message
    ) internal {
        uint256[19] calldata publicInputs = proof.publicSignals;
        address from = msg.sender;

        // validate public key
        _validatePublicKey(from, [publicInputs[0], publicInputs[1]]);

        // validate auditor public key
        _validateAuditorPublicKey([publicInputs[10], publicInputs[11]]);

        // Verify the zero-knowledge proof
        bool isVerified = burnVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        // provided encrypted balance
        EGCT memory providedBalance = EGCT({
            c1: Point({x: publicInputs[2], y: publicInputs[3]}),
            c2: Point({x: publicInputs[4], y: publicInputs[5]})
        });

        // extract encrypted burn amount
        EGCT memory encryptedBurnAmount = EGCT({
            c1: Point({x: publicInputs[6], y: publicInputs[7]}),
            c2: Point({x: publicInputs[8], y: publicInputs[9]})
        });

        // perform the burn (since burn is only for Standalone, always passing tokenId as 0)
        _privateBurn(from, 0, providedBalance, encryptedBurnAmount, balancePCT);

        // extract auditor PCT
        uint256[7] memory auditorPCT;
        for (uint256 i = 0; i < auditorPCT.length; i++) {
            auditorPCT[i] = publicInputs[12 + i];
        }

        emit PrivateBurn(from, auditorPCT, auditor);

        // emit metadata if message is provided
        _emitMetadata(msg.sender, from, "PRIVATE_BURN", message);
    }

    /**
     * @notice Executes a private deposit operation
     * @param amount The amount of tokens to deposit
     * @param tokenAddress The address of the token to deposit
     * @param amountPCT The amount PCT for the deposit
     * @param message Additional metadata message to be emitted with the deposit event
     */
    function _executeDeposit(
        uint256 amount,
        address tokenAddress,
        uint256[7] memory amountPCT,
        bytes memory message
    ) internal {
        IERC20 token = IERC20(tokenAddress);
        uint256 dust;
        uint256 tokenId;
        address to = msg.sender;

        // Get the contract's balance before the transfer
        uint256 balanceBefore = token.balanceOf(address(this));

        // Transfer tokens from user to contract
        SafeERC20.safeTransferFrom(token, to, address(this), amount);

        // Get the contract's balance after the transfer
        uint256 balanceAfter = token.balanceOf(address(this));

        // Verify that the actual transferred amount matches the expected amount
        uint256 actualTransferred = balanceAfter - balanceBefore;
        if (actualTransferred != amount) {
            revert TransferFailed();
        }

        // Convert tokens to encrypted tokens
        (dust, tokenId) = _convertFrom(to, amount, tokenAddress, amountPCT);

        // Return dust to user
        if (dust > 0) {
            SafeERC20.safeTransfer(token, to, dust);
        }

        // Emit deposit event
        emit Deposit(to, amount, dust, tokenId);

        // emit metadata if message is provided
        _emitMetadata(msg.sender, to, "DEPOSIT", message);
    }

    function _executeWithdraw(
        uint256 tokenId,
        WithdrawProof memory proof,
        uint256[7] memory balancePCT,
        bytes memory message
    ) internal {
        address from = msg.sender;
        uint256[16] memory publicInputs = proof.publicSignals;
        uint256 amount = publicInputs[0];

        // validate public keys
        _validatePublicKey(from, [publicInputs[1], publicInputs[2]]);
        _validateAuditorPublicKey([publicInputs[7], publicInputs[8]]);

        // Verify the zero-knowledge proof
        bool isVerified = withdrawVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        // Perform the withdrawal
        _withdraw(from, amount, tokenId, publicInputs, balancePCT);

        // Extract auditor PCT and emit event
        {
            uint256[7] memory auditorPCT;
            for (uint256 i = 0; i < 7; i++) {
                auditorPCT[i] = publicInputs[9 + i];
            }

            emit Withdraw(from, amount, tokenId, auditorPCT, auditor);
        }

        // emit metadata if message is provided
        _emitMetadata(msg.sender, from, "WITHDRAW", message);
    }

    /**
     * @notice Validates a user's public key
     * @param user The address of the user
     * @param providedPublicKey The public key to validate
     * @dev Function fetches the user's public key from the registrar contract
     * @dev If the public key is not valid, it reverts with InvalidProof error
     */
    function _validatePublicKey(
        address user,
        uint256[2] memory providedPublicKey
    ) internal view {
        uint256[2] memory userPublicKey = registrar.getUserPublicKey(user);

        if (
            userPublicKey[0] != providedPublicKey[0] ||
            userPublicKey[1] != providedPublicKey[1]
        ) {
            revert InvalidProof();
        }
    }

    /**
     * @notice Validates the auditor's public key
     * @param providedPublicKey The public key to validate
     * @dev If the public key is not match with the auditor's public key, it reverts with InvalidProof error
     */
    function _validateAuditorPublicKey(
        uint256[2] memory providedPublicKey
    ) internal view {
        if (
            auditorPublicKey.x != providedPublicKey[0] ||
            auditorPublicKey.y != providedPublicKey[1]
        ) {
            revert InvalidProof();
        }
    }

    /**
     * @notice Extracts the inputs for a transfer operation
     * @param input The input array containing the transfer data
     * @return transferInputs TransferInputs struct containing:
     *         - providedBalance (EGCT): The provided balance from the proof
     *         - senderEncryptedAmount (EGCT): The encrypted amount to subtract from sender
     *         - receiverEncryptedAmount (EGCT): The encrypted amount to add to receiver
     *         - amountPCT (uint256[7]): The amount PCT for the transfer
     */
    function _extractTransferInputs(
        uint256[32] memory input
    ) internal pure returns (TransferInputs memory transferInputs) {
        transferInputs.providedBalance = EGCT({
            c1: Point({x: input[2], y: input[3]}),
            c2: Point({x: input[4], y: input[5]})
        });

        transferInputs.senderEncryptedAmount = EGCT({
            c1: Point({x: input[6], y: input[7]}),
            c2: Point({x: input[8], y: input[9]})
        });

        transferInputs.receiverEncryptedAmount = EGCT({
            c1: Point({x: input[12], y: input[13]}),
            c2: Point({x: input[14], y: input[15]})
        });

        for (uint256 i = 0; i < 7; i++) {
            transferInputs.amountPCT[i] = input[16 + i];
        }
    }
}



================================================
FILE: contracts/EncryptedUserBalances.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {EncryptedBalance, EGCT, BalanceHistory, AmountPCT} from "./types/Types.sol";
import {InvalidProof} from "./errors/Errors.sol";
import {BabyJubJub} from "./libraries/BabyJubJub.sol";

/**
 * @title EncryptedUserBalances
 * @notice Contract for managing encrypted user balances in the privacy-preserving ERC system
 * @dev This contract handles:
 *      1. Storage and retrieval of encrypted balances
 *      2. Balance history tracking for transaction validation
 *      3. Cryptographic operations on encrypted balances
 *
 * The contract uses ElGamal encryption (EGCT) to store balances privately,
 * allowing users to prove they have sufficient funds without revealing the actual amount.
 */
contract EncryptedUserBalances {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice Mapping of user addresses to their encrypted balances for each token
    /// @dev Structure: user => tokenId => EncryptedBalance
    mapping(address user => mapping(uint256 tokenId => EncryptedBalance balance))
        public balances;

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Returns the encrypted balance for a user's standalone token
     * @param user The address of the user
     * @return eGCT The ElGamal ciphertext representing the encrypted balance
     * @return nonce The current nonce used for balance validation
     * @return amountPCTs Array of amount PCT
     * @return balancePCT The current balance PCT
     * @return transactionIndex The current transaction index
     * @dev Since in standalone mode, the tokenId is always 0
     */
    function balanceOfStandalone(
        address user
    )
        external
        view
        returns (
            EGCT memory eGCT,
            uint256 nonce,
            AmountPCT[] memory amountPCTs,
            uint256[7] memory balancePCT,
            uint256 transactionIndex
        )
    {
        return balanceOf(user, 0);
    }

    /**
     * @notice Returns the encrypted balance for a user's specified token
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @return eGCT The ElGamal ciphertext representing the encrypted balance
     * @return nonce The current nonce used for balance validation
     * @return amountPCTs Array of amount PCT
     * @return balancePCT The current balance PCT
     * @return transactionIndex The current transaction index
     */
    function balanceOf(
        address user,
        uint256 tokenId
    )
        public
        view
        returns (
            EGCT memory eGCT,
            uint256 nonce,
            AmountPCT[] memory amountPCTs,
            uint256[7] memory balancePCT,
            uint256 transactionIndex
        )
    {
        EncryptedBalance storage balance = balances[user][tokenId];
        return (
            balance.eGCT,
            balance.nonce,
            balance.amountPCTs,
            balance.balancePCT,
            balance.transactionIndex
        );
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Adds an encrypted amount to a user's balance
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param eGCT The ElGamal ciphertext representing the amount to add
     * @param amountPCT The amount PCT for transaction history
     * @dev This function:
     *      1. Initializes the balance if it's the first transaction
     *      2. Adds the encrypted amount to the existing balance
     *      3. Updates the user history (by adding new amount PCT)
     */
    function _addToUserBalance(
        address user,
        uint256 tokenId,
        EGCT memory eGCT,
        uint256[7] memory amountPCT
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        // if user balance is not initialized, initialize it
        if (balance.eGCT.c1.x == 0 && balance.eGCT.c1.y == 0) {
            balance.eGCT = eGCT;
        } else {
            // if user balance is already initialized, add the encrypted amount to the balance
            balance.eGCT.c1 = BabyJubJub._add(balance.eGCT.c1, eGCT.c1);
            balance.eGCT.c2 = BabyJubJub._add(balance.eGCT.c2, eGCT.c2);
        }

        // in all the case
        _addToUserHistory(user, tokenId, amountPCT);
    }

    /**
     * @notice Subtracts an encrypted amount from a user's balance
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param eGCT The ElGamal ciphertext representing the amount to subtract
     * @param balancePCT The new balance PCT after subtraction
     * @param transactionIndex The transaction index to delete from history
     * @dev This function:
     *      1. Subtracts the encrypted amount from the balance
     *      2. Updates the user history (by removing the specified transaction)
     *      3. Updates the balance PCT for user
     */
    function _subtractFromUserBalance(
        address user,
        uint256 tokenId,
        EGCT memory eGCT,
        uint256[7] memory balancePCT,
        uint256 transactionIndex
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        balance.eGCT.c1 = BabyJubJub._sub(balance.eGCT.c1, eGCT.c1);
        balance.eGCT.c2 = BabyJubJub._sub(balance.eGCT.c2, eGCT.c2);

        // delete the amount pct from the balance
        _deleteUserHistory(user, tokenId, transactionIndex);

        // update balance pct
        balance.balancePCT = balancePCT;
    }

    /**
     * @notice Adds a transaction to the user's balance history
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param amountPCT The amount PCT for the transaction
     * @dev This function:
     *      1. Calculates a unique hash for the current balance state
     *      2. Marks this hash as valid in the balance history
     *      3. Adds the amount PCT to the transaction history
     *      4. Increments the transaction index
     *
     * The balance hash is unique for each transaction because it includes the nonce,
     * which is incremented after each transaction. This ensures that each transaction
     * can be uniquely identified and validated.
     */
    function _addToUserHistory(
        address user,
        uint256 tokenId,
        uint256[7] memory amountPCT
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        uint256 nonce = balance.nonce;
        uint256 balanceHash = _hashEGCT(balance.eGCT);
        balanceHash = uint256(keccak256(abi.encode(balanceHash, nonce)));

        // mark the balance hash as valid
        balance.balanceList[balanceHash] = BalanceHistory({
            index: balance.transactionIndex,
            isValid: true
        });

        // add the amount pct to the balance
        balance.amountPCTs.push(
            AmountPCT({pct: amountPCT, index: balance.transactionIndex})
        );

        balance.transactionIndex++;
    }

    /**
     * @notice Commits the current balance state to the user's history
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @dev This function:
     *      1. Calculates a unique hash for the current balance state
     *      2. Marks this hash as valid in the balance history
     *      3. Increments the transaction index
     *
     * This is used to create a checkpoint of the balance state after operations
     * that don't change the balance amount but need to be recorded in history.
     */
    function _commitUserBalance(address user, uint256 tokenId) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        uint256 nonce = balance.nonce;
        uint256 balanceHash = _hashEGCT(balance.eGCT);
        balanceHash = uint256(keccak256(abi.encode(balanceHash, nonce)));

        balance.balanceList[balanceHash] = BalanceHistory({
            index: balance.transactionIndex,
            isValid: true
        });

        balance.transactionIndex++;
    }

    /**
     * @notice Deletes transaction history up to a specific transaction index
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param transactionIndex The transaction index to delete up to
     * @dev This function:
     *      1. Removes amount PCTs from the history up to the specified index
     *      2. Increments the nonce (invalidate all previous balance hashes)
     *      3. Commits the new balance state to history
     *
     * Instead of deleting individual history entries, this function uses the nonce
     * to invalidate all previous balance hashes at once, which is more gas efficient.
     */
    function _deleteUserHistory(
        address user,
        uint256 tokenId,
        uint256 transactionIndex
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        for (uint256 i = balance.amountPCTs.length; i > 0; i--) {
            uint256 index = i - 1;

            if (balance.amountPCTs[index].index <= transactionIndex) {
                balance.amountPCTs[index] = balance.amountPCTs[
                    balance.amountPCTs.length - 1
                ];
                balance.amountPCTs.pop();
            }
        }

        balance.nonce++;

        _commitUserBalance(user, tokenId);
    }

    /**
     * @notice Checks if a balance hash is valid for a user
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param balanceHash The hash to validate
     * @return isValid True if the hash is valid, false otherwise
     * @return index The transaction index associated with the hash
     * This is used to validate that a user is using a recent and valid balance
     * in their transactions.
     */
    function _isBalanceValid(
        address user,
        uint256 tokenId,
        uint256 balanceHash
    ) internal view returns (bool, uint256) {
        uint256 nonce = balances[user][tokenId].nonce;
        uint256 hashWithNonce = uint256(
            keccak256(abi.encode(balanceHash, nonce))
        );
        return (
            balances[user][tokenId].balanceList[hashWithNonce].isValid,
            balances[user][tokenId].balanceList[hashWithNonce].index
        );
    }

    /**
     * @notice Verifies a user's balance
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param eGCT The ElGamal ciphertext representing the balance
     * @return transactionIndex The transaction index associated with the balance
     * @dev If balance is not valid, it reverts with InvalidProof error
     */
    function _verifyUserBalance(
        address user,
        uint256 tokenId,
        EGCT memory eGCT
    ) internal view returns (uint256) {
        // hash the encrypted balance
        uint256 balanceHash = _hashEGCT(eGCT);

        (bool isValid, uint256 transactionIndex) = _isBalanceValid(
            user,
            tokenId,
            balanceHash
        );
        if (!isValid) {
            revert InvalidProof();
        }

        return transactionIndex;
    }

    /**
     * @notice Calculates a hash of an ElGamal ciphertext
     * @param eGCT The ElGamal ciphertext to hash
     * @return The hash of the ciphertext
     * @dev This function creates a unique identifier for an encrypted balance
     *      by hashing all components of the ElGamal ciphertext.
     */
    function _hashEGCT(EGCT memory eGCT) internal pure returns (uint256) {
        return
            uint256(
                keccak256(
                    abi.encode(eGCT.c1.x, eGCT.c1.y, eGCT.c2.x, eGCT.c2.y)
                )
            );
    }
}



================================================
FILE: contracts/Registrar.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {Point, RegisterProof} from "./types/Types.sol";
import {IRegistrationVerifier} from "./interfaces/verifiers/IRegistrationVerifier.sol";
import {UserAlreadyRegistered, InvalidChainId, InvalidSender, InvalidRegistrationHash, InvalidProof} from "./errors/Errors.sol";

// libraries
import {BabyJubJub} from "./libraries/BabyJubJub.sol";

/**
 * @title Registrar
 * @notice Contract for managing user registration in the privacy-preserving ERC system
 * @dev This contract handles:
 *      1. User registration with public keys
 *      2. Verification of registration proofs
 *
 * The Registrar is a critical component that:
 * - Associates Ethereum addresses with public keys for encrypted operations
 */
contract Registrar {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice The verifier contract used to validate registration proofs
    IRegistrationVerifier public registrationVerifier;

    /// @notice Mapping of user addresses to their public keys
    mapping(address userAddress => Point userPublicKey) public userPublicKeys;

    /// @notice Mapping of registration hashes to registration status
    /// @dev Used to prevent duplicate registrations
    mapping(uint256 registrationHash => bool isRegistered) public isRegistered;

    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /// @notice Emitted when a user is registered
    /// @param user Address of the user
    /// @param publicKey Public key of the user
    event Register(address indexed user, Point publicKey);

    ///////////////////////////////////////////////////
    ///                   Constructor               ///
    ///////////////////////////////////////////////////

    /**
     * @notice Initializes the Registrar contract
     * @param registrationVerifier_ Address of the registration verifier contract
     */
    constructor(address registrationVerifier_) {
        registrationVerifier = IRegistrationVerifier(registrationVerifier_);
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Registers a user with their public key
     * @param proof The zero-knowledge proof proving the validity of the registration
     * @dev This function:
     *      1. Verifies the sender matches the account in the proof
     *      2. Checks the chain ID matches
     *      3. Validates the registration hash
     *      4. Verifies the zero-knowledge proof
     *      5. Registers the user with their public key
     *
     * Requirements:
     * - Sender must match the account in the proof
     * - Chain ID must match
     * - Registration hash must be valid
     * - User must not be already registered
     * - Proof must be valid
     */
    function register(RegisterProof calldata proof) external {
        // extract public inputs
        uint256[5] memory input = proof.publicSignals;

        address account = address(uint160(input[2]));

        // check if the sender matches the account in the proof
        if (msg.sender != account) {
            revert InvalidSender();
        }

        // check if the chain ID matches
        if (block.chainid != input[3]) {
            revert InvalidChainId();
        }

        // check if the registration hash is valid
        uint256 registrationHash = input[4];
        if (registrationHash >= BabyJubJub.Q) {
            revert InvalidRegistrationHash();
        }

        // check if the user is already registered
        if (isRegistered[registrationHash] && isUserRegistered(account)) {
            revert UserAlreadyRegistered();
        }

        // Verify the proof
        _verifyProof(proof);

        _register(account, Point({x: input[0], y: input[1]}), registrationHash);
    }

    /**
     * @notice Checks if a user is registered
     * @param user The address of the user to check
     * @return bool True if the user is registered, false otherwise
     * @dev A user is considered registered if their public key is not the zero point (0,0)
     */
    function isUserRegistered(address user) public view returns (bool) {
        return userPublicKeys[user].x != 0 && userPublicKeys[user].y != 0;
    }

    /**
     * @notice Gets the public key of a user
     * @param user The address of the user
     * @return publicKey The public key of the user as a uint256 array
     * @dev Returns the x and y coordinates of the user's public key
     */
    function getUserPublicKey(
        address user
    ) public view returns (uint256[2] memory publicKey) {
        return [userPublicKeys[user].x, userPublicKeys[user].y];
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Registers a user with their public key
     * @param user The address of the user
     * @param publicKey The public key of the user
     * @param registrationHash The registration hash
     * @dev This function:
     *      1. Sets the user's public key
     *      2. Marks the registration hash as used
     *      3. Emits a Register event
     */
    function _register(
        address user,
        Point memory publicKey,
        uint256 registrationHash
    ) internal {
        userPublicKeys[user] = publicKey;
        isRegistered[registrationHash] = true;
        emit Register(user, publicKey);
    }

    /**
     * @notice Verifies a registration proof
     * @param proof_ The proof to verify
     * @dev This function:
     *      1. Extracts the proof points and public inputs
     *      2. Calls the verifier contract to verify the proof
     *      3. Reverts if the proof is invalid
     */
    function _verifyProof(RegisterProof calldata proof_) internal view {
        uint256[2] memory pointA_ = proof_.proofPoints.a;
        uint256[2][2] memory pointB_ = proof_.proofPoints.b;
        uint256[2] memory pointC_ = proof_.proofPoints.c;
        uint256[5] memory input = proof_.publicSignals;

        // Verify the proof
        bool verified_ = registrationVerifier.verifyProof(
            pointA_,
            pointB_,
            pointC_,
            input
        );

        if (!verified_) {
            revert InvalidProof();
        }
    }
}



================================================
FILE: contracts/auditor/AuditorManager.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem
pragma solidity 0.8.27;

import {Point} from "../types/Types.sol";
import {ZeroAddress} from "../errors/Errors.sol";

/**
 * @title AuditorManager
 * @notice Abstract contract that manages auditor-related functionality for encrypted ERC operations
 * @dev This contract is responsible for:
 *      1. Storing and managing the auditor's address and public key
 *      2. Providing access control for auditor-related operations
 *      3. Emitting events when auditor information changes
 *
 * The auditor is a crucial component in the encrypted ERC system that:
 * - Ensures compliance with regulatory requirements
 * - Provides oversight for private operations
 */
abstract contract AuditorManager {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice The address of the current auditor
    /// @dev This address is used to identify the auditor and for access control
    address public auditor = address(0);

    /// @notice The public key of the current auditor
    /// @dev This is used in zero-knowledge proofs to validate auditor signatures
    ///      The point (0,1) is considered invalid as it's the identity point in the elliptic curve
    Point public auditorPublicKey = Point({x: 0, y: 0});

    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when the auditor's information is updated
     * @param oldAuditor The previous auditor's address
     * @param newAuditor The new auditor's address
     */
    event AuditorChanged(
        address indexed oldAuditor,
        address indexed newAuditor
    );

    ///////////////////////////////////////////////////
    ///                   Modifiers                 ///
    ///////////////////////////////////////////////////

    /**
     * @notice Ensures that an auditor is properly
     * @dev This modifier checks two conditions:
     *      1. The auditor's public key is valid (not the identity point)
     *      2. The auditor's address is not the zero address
     *
     * Requirements:
     * - Auditor public key must be set (not the identity point)
     * - Auditor address must be set (not zero address)
     */
    modifier onlyIfAuditorSet() {
        require(
            auditorPublicKey.x != 0 && auditorPublicKey.y != 1,
            "Auditor public key not set"
        );
        require(auditor != address(0), "Auditor not set");
        _;
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Checks if the auditor's public key is properly set
     * @return bool True if the auditor's public key is set and valid
     * @dev This function is used to verify if the contract is ready for
     *      operations that require auditor validation
     */
    function isAuditorKeySet() external view returns (bool) {
        return auditorPublicKey.x != 0 && auditorPublicKey.y != 1;
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Updates the auditor's information
     * @param newAuditor The address of the new auditor
     * @param publicKey The public key of the new auditor
     * @dev This function:
     *      1. Validates the new auditor's address
     *      2. Updates the auditor's information
     *      3. Emits an event to track the change
     *
     * Requirements:
     * - newAuditor must not be the zero address
     * - publicKey must be a valid point on the elliptic curve
     */
    function _updateAuditor(
        address newAuditor,
        uint256[2] memory publicKey
    ) internal {
        address oldAuditor = auditor;
        // check if the auditor is the zero address
        if (newAuditor == address(0)) {
            revert ZeroAddress();
        }

        auditor = newAuditor;
        auditorPublicKey = Point({x: publicKey[0], y: publicKey[1]});

        emit AuditorChanged(oldAuditor, newAuditor);
    }
}



================================================
FILE: contracts/errors/Errors.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

error UserAlreadyRegistered();
error UserNotRegistered();
error UnauthorizedAccess();
error AuditorKeyNotSet();
error InvalidProof();
error InvalidOperation();
error TransferFailed();
error UnknownToken();
error InvalidChainId();
error InvalidNullifier();
error InvalidSender();
error InvalidRegistrationHash();
error ZeroAddress();
error TokenBlacklisted(address token);



================================================
FILE: contracts/interfaces/IEncryptedERC.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IEncryptedERC {
    /**
     * @notice Sets the balance percentage for a user and token.
     * @param user User address
     * @param tokenId Token ID
     * @param pct Balance percentage array
     * @dev Only the registrar can set the balance percentage
     */
    function setUserBalancePCT(
        address user,
        uint256 tokenId,
        uint256[7] memory pct
    ) external;
}



================================================
FILE: contracts/interfaces/IRegistrar.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IRegistrar {
    /**
     * @dev Returns the public key of a user.
     * @param user Address of the user.
     * @return publicKey The public key of the user as an array of two uint256 values.
     */
    function getUserPublicKey(
        address user
    ) external view returns (uint256[2] memory publicKey);

    /**
     * @dev Returns true if the user is registered.
     * @param user Address of the user.
     * @return isRegistered True if the user is registered, false otherwise.
     */
    function isUserRegistered(address user) external view returns (bool);
}



================================================
FILE: contracts/interfaces/verifiers/IBurnVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IBurnVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[19] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/IMintVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IMintVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[24] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/IRegistrationVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IRegistrationVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[5] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/ITransferVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface ITransferVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[32] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/IWithdrawVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IWithdrawVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[16] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/libraries/BabyJubJub.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

// Structs
import {Point, EGCT} from "../types/Types.sol";

/**
 * @dev BabyJubJub curve operations
 */
library BabyJubJub {
    // Curve parameters
    // E: A^2 + y^2 = 1 + Dx^2y^2 (mod Q)
    uint256 internal constant A = 168700;
    uint256 internal constant D = 168696;
    uint256 public constant Q =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    uint256 internal constant H =
        10944121435919637611123202872628637544274182200208017171849102093287904247808;
    uint256 internal constant R =
        2736030358979909402780800718157159386076813972158567259200215660948447373041;

    /**
     * @dev Subtract a BabyJubJub point from another BabyJubJub point
     * @param _point1 the point which will be subtracted from
     * @param _point2 point to subtract
     * @return result
     */
    function _sub(
        Point memory _point1,
        Point memory _point2
    ) public view returns (Point memory) {
        return _add(_point1, negate(_point2));
    }

    /**
     * @dev Add 2 points on BabyJubJub curve
     * Formulae for adding 2 points on a twisted Edwards curve:
     * x3 = (x1y2 + y1x2) / (1 + dx1x2y1y2)
     * y3 = (y1y2 - ax1x2) / (1 - dx1x2y1y2)
     * @param _point1 first point
     * @param _point2 second point
     * @return resulting point
     */
    function _add(
        Point memory _point1,
        Point memory _point2
    ) public view returns (Point memory) {
        uint256 x1x2 = mulmod(_point1.x, _point2.x, Q);
        uint256 y1y2 = mulmod(_point1.y, _point2.y, Q);

        uint256 dx1x2y1y2 = mulmod(D, mulmod(x1x2, y1y2, Q), Q);

        uint256 x3Num = addmod(
            mulmod(_point1.x, _point2.y, Q),
            mulmod(_point1.y, _point2.x, Q),
            Q
        );
        uint256 y3Num = submod(y1y2, mulmod(A, x1x2, Q));

        return
            Point({
                x: mulmod(x3Num, invmod(addmod(1, dx1x2y1y2, Q)), Q),
                y: mulmod(y3Num, invmod(submod(1, dx1x2y1y2)), Q)
            });
    }

    /**
     * @dev Multiply a BabyJubJub point by a scalar
     * Use the double and add algorithm
     * @param _point point be multiplied by a scalar
     * @param _scalar scalar value
     * @return resulting point
     */
    function scalarMultiply(
        Point memory _point,
        uint256 _scalar
    ) public view returns (Point memory) {
        // Initial scalar remainder
        uint256 remaining = _scalar % R;

        // Copy initial point so that we don't mutate it
        Point memory initial = _point;

        // Initialize result
        Point memory result = Point({x: 0, y: 1});

        // Loop while remainder is greater than 0
        while (remaining != 0) {
            // If the right-most binary digit is 1 (number is odd) add initial point to result
            if ((remaining & 1) != 0) {
                result = _add(result, initial);
            }

            // Double initial point
            initial = double(initial);

            // Shift bits to the right
            remaining = remaining >> 1;
        }

        return result;
    }

    /**
     *
     * @param _publicKey Public Key that will be used in encryption
     * @param _msg Message in scalar form to be encrypted
     */
    function elGamalEncryption(
        Point memory _publicKey,
        uint256 _msg
    ) public view returns (EGCT memory) {
        uint256 random = 1;
        Point memory b8 = base8();

        Point memory c1 = scalarMultiply(b8, random);
        Point memory pkr = scalarMultiply(_publicKey, random);
        Point memory pMsg = scalarMultiply(b8, _msg);

        Point memory c2 = _add(pkr, pMsg);

        return EGCT({c1: c1, c2: c2});
    }

    // elgamal encryption with a given message
    function encrypt(
        Point memory _publicKey,
        uint256 _msg
    ) public view returns (EGCT memory) {
        return elGamalEncryption(_publicKey, _msg);
    }

    /**
     * @dev Default generator
     */
    function base8() public pure returns (Point memory) {
        return
            Point({
                x: 5299619240641551281634865583518297030282874472190772894086521144482721001553,
                y: 16950150798460657717958625567821834550301663161624707787222815936182638968203
            });
    }

    /**
     * @dev Double a point on BabyJubJub curve
     * @param _p point to double
     * @return doubled point
     */
    function double(Point memory _p) internal view returns (Point memory) {
        return _add(_p, _p);
    }

    /**
     * @dev Compute modular inverse of a number
     * @param _a the value to be inverted in mod Q
     */
    function invmod(uint256 _a) internal view returns (uint256) {
        // We can use Euler's theorem instead of the extended Euclidean algorithm
        // Since m = Q and Q is prime we have: a^-1 = a^(m - 2) (mod m)
        return
            expmod(
                _a,
                0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffffff
            );
    }

    /**
     * @dev Exponentiation modulo Q
     * @param _base the base of the exponentiation
     * @param _exponent the exponent
     * @return result
     */
    function expmod(
        uint256 _base,
        uint256 _exponent
    ) internal view returns (uint256) {
        uint256 result;

        // solhint-disable-next-line no-inline-assembly
        assembly {
            let
                localQ
            := 0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001
            let memPtr := mload(0x40)
            mstore(memPtr, 0x20) // Length of base _b
            mstore(add(memPtr, 0x20), 0x20) // Length of exponent _e
            mstore(add(memPtr, 0x40), 0x20) // Length of modulus Q
            mstore(add(memPtr, 0x60), _base) // Base _b
            mstore(add(memPtr, 0x80), _exponent) // Exponent _e
            mstore(add(memPtr, 0xa0), localQ) // Modulus Q

            // The bigModExp precompile is at 0x05
            let success := staticcall(gas(), 0x05, memPtr, 0xc0, memPtr, 0x20)
            switch success
            case 0 {
                revert(0x0, 0x0)
            }
            default {
                result := mload(memPtr)
            }
        }

        return result;
    }

    /**
     * @dev Negate a BabyJubJub point
     * @param _point point to negate
     * @return p = -(_p)
     */
    function negate(Point memory _point) internal pure returns (Point memory) {
        return Point({x: Q - _point.x, y: _point.y});
    }

    /**
     * @dev Modular subtract (mod n).
     * @param _a The first number
     * @param _b The number to be subtracted
     * @return result
     */
    function submod(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return addmod(_a, Q - _b, Q);
    }
}



================================================
FILE: contracts/metadata/EncryptedMetadata.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem
pragma solidity 0.8.27;

// types
import {Metadata} from "../types/Types.sol";

/**
 * @title EncryptedMetadata
 * @notice A contract that handles encrypted metadata functionality for privacy-preserving operations
 * @dev This contract provides the core functionality for creating and emitting encrypted metadata
 *      associated with various operations. It can be inherited by other contracts that need
 *      metadata capabilities.
 *
 * Key features:
 * - Encrypted metadata creation and emission
 * - Structured metadata with sender, receiver, type, and encrypted message
 * - Privacy-preserving message transmission
 * - Reusable across different contract types
 */
contract EncryptedMetadata {
    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when encrypted metadata is sent between users
     * @param from Address of the sender of the metadata
     * @param to Address of the receiver of the metadata
     * @param metadata Structured metadata containing message details and encrypted content
     * @dev This event is emitted when encrypted metadata is transmitted between registered users.
     *      The metadata includes the sender, receiver, message type, and encrypted message content.
     *      Only the intended receiver can decrypt the message using their private key.
     */
    event PrivateMessage(
        address indexed from,
        address indexed to,
        Metadata metadata
    );

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Sends encrypted metadata to a registered user
     * @param to Address of the recipient of the encrypted metadata
     * @param message Encrypted message bytes to be sent
     * @dev This function allows any registered user to send encrypted metadata to another
     *      registered user. The message should be encrypted with the recipient's public key
     *      before calling this function.
     *
     * The function:
     *      1. Validates that both sender and recipient are registered users
     *      2. Creates a structured metadata object
     *      3. Emits the PrivateMessage event with the metadata
     *
     * Requirements:
     * - Caller must be a registered user
     * - Recipient must be a registered user
     * - Message should be properly encrypted with recipient's public key
     *
     */
    function _sendEncryptedMetadata(
        address to,
        bytes calldata message
    ) internal virtual {
        // Create and emit metadata
        address messageFrom = msg.sender;
        Metadata memory metadata = _createMetadata(
            messageFrom,
            to,
            "MESSAGE",
            message
        );
        emit PrivateMessage(messageFrom, to, metadata);
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emits metadata for operation-specific events
     * @param from Address of the sender
     * @param to Address of the recipient
     * @param messageType Type of the operation (e.g., "PRIVATE_MINT", "PRIVATE_BURN")
     * @param message Encrypted message content
     * @dev This function is used internally by inheriting contracts to emit metadata
     *      for specific operations. It creates the metadata structure and emits the
     *      PrivateMessage event.
     */
    function _emitMetadata(
        address from,
        address to,
        string memory messageType,
        bytes memory message
    ) internal {
        if (message.length > 0) {
            Metadata memory metadata = _createMetadata(
                from,
                to,
                messageType,
                message
            );
            emit PrivateMessage(from, to, metadata);
        }
    }

    /**
     * @notice Creates a structured metadata object
     * @param messageFrom Address of the sender of the metadata
     * @param messageTo Address of the recipient of the metadata
     * @param messageType Type/category of the message (e.g., "PRIVATE_MINT", "TRANSFER", etc.)
     * @param encryptedMsg Encrypted message content
     * @return metadata Structured Metadata object containing all message details
     * @dev This internal function creates a standardized metadata structure that includes
     *      sender, recipient, message type, and encrypted content. The message type helps
     *      recipients categorize and process different types of metadata appropriately.
     */
    function _createMetadata(
        address messageFrom,
        address messageTo,
        string memory messageType,
        bytes memory encryptedMsg
    ) internal pure returns (Metadata memory metadata) {
        metadata.messageFrom = messageFrom;
        metadata.messageTo = messageTo;
        metadata.messageType = messageType;
        metadata.encryptedMsg = encryptedMsg;
        return metadata;
    }
}



================================================
FILE: contracts/metadata/IEncryptedMetadata.sol
================================================
// SPDX-License-Identifier: Ecosystem
pragma solidity 0.8.27;

// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// types
import {Metadata} from "../types/Types.sol";

/**
 * @title IEncryptedMetadata
 * @notice Interface for encrypted metadata functionality
 * @dev This interface defines the external functions that can be called on contracts
 *      that implement encrypted metadata capabilities.
 */
interface IEncryptedMetadata {
    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when encrypted metadata is sent between users
     * @param from Address of the sender of the metadata
     * @param to Address of the receiver of the metadata
     * @param metadata Structured metadata containing message details and encrypted content
     */
    event PrivateMessage(
        address indexed from,
        address indexed to,
        Metadata metadata
    );

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Sends encrypted metadata to a registered user
     * @param to Address of the recipient of the encrypted metadata
     * @param message Encrypted message bytes to be sent
     * @dev This function allows any registered user to send encrypted metadata to another
     *      registered user. The message should be encrypted with the recipient's public key
     *      before calling this function.
     */
    function sendEncryptedMetadata(address to, bytes calldata message) external;
}



================================================
FILE: contracts/prod/BurnVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract BurnVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 20500123508036250241732436039045855491142840147741568076165900093824331281316;
    uint256 constant deltax2 = 17951494579165795533532847235529611089521789751209994758862962564682445617412;
    uint256 constant deltay1 = 5834387578477044714458263369208539598498352288497332887384107712494722576583;
    uint256 constant deltay2 = 15268404118840851015046775717571916089738924216088942953684197626467386210997;

    
    uint256 constant IC0x = 11786268729161045937652164714990691490770027441460947932012316631529733292940;
    uint256 constant IC0y = 9581132102330540074693305331254898451475664668584360899026097918947512977366;
    
    uint256 constant IC1x = 914822366018062648285730205402683692599853766866159406178623354781735659599;
    uint256 constant IC1y = 8553697750564092712813746981763759579862680918228138684307182805192139236520;
    
    uint256 constant IC2x = 17908121343774581376092646765067170799970925894057937307165335210962871507135;
    uint256 constant IC2y = 6739483966006459958647545663755815825611388802168101513616676265213547687212;
    
    uint256 constant IC3x = 143359351657650308208480824138891765346610788279862658068353643164441844115;
    uint256 constant IC3y = 1688658345879791302522420761526578526163188876279486731177660400972657648742;
    
    uint256 constant IC4x = 18309718863517978042660293994537440591428742486455947599492279373595114219500;
    uint256 constant IC4y = 3543366565414834921232477531525858456841505305202548147687587105557694958104;
    
    uint256 constant IC5x = 2179968961403977829543241099157331775731416225717055667057125732267317798366;
    uint256 constant IC5y = 14579564811228528586131093319854876770716135551807922280189147940915226636750;
    
    uint256 constant IC6x = 12128037778350917133400346467296434075039661406517118820895803963198786951800;
    uint256 constant IC6y = 12810377956478161485381774828600271058686148075894654796038454545352947160776;
    
    uint256 constant IC7x = 9593873745453136272405518724864540111195676150385738265238288297101461351389;
    uint256 constant IC7y = 18140226050853380485925948980064648409518762214351351505488025177062130412015;
    
    uint256 constant IC8x = 5344462067192893979551241744484644250693230460027867247351105468329395690915;
    uint256 constant IC8y = 2435072349815413116277252545573449685604686772441816336584542983683379409914;
    
    uint256 constant IC9x = 15867459271796662494529143386082298582993967528167005628586571617103329782767;
    uint256 constant IC9y = 1031216327552632558464991513003642749331915406636029936411939647607628738052;
    
    uint256 constant IC10x = 11710830742293210758218398274130454937288722189717294688374583983853957500247;
    uint256 constant IC10y = 18095934287133238566717320534781010028273178446261522698705303702525394211898;
    
    uint256 constant IC11x = 5451223849987641096615559250356903902465481513182931751171182631482949381911;
    uint256 constant IC11y = 6791511973211811945927811502706661666842895298126970397039460184655612620453;
    
    uint256 constant IC12x = 12576390828389735220141209658777087276380270144557056528857559882798323629447;
    uint256 constant IC12y = 19191122649652045476856774223103624470066531140701020233373995430155185392289;
    
    uint256 constant IC13x = 3208115974817470421120218397409974778673673537533531169452261659740974257278;
    uint256 constant IC13y = 1563495302870822079389756646952495877672019554537528044396737285924026906103;
    
    uint256 constant IC14x = 15803266454704411593372706477399336420388826076293995292354385277988446601281;
    uint256 constant IC14y = 14061261779941396671642560007918916383355024387096318566313366433584709024499;
    
    uint256 constant IC15x = 1473892103720096233092115851822223251992401285317974909943916318348184767365;
    uint256 constant IC15y = 3670020837101119839757171869792531530222770849398108379916390350369899561438;
    
    uint256 constant IC16x = 8909686676336745813415338575513600352109241710831786249590248291624151036333;
    uint256 constant IC16y = 4561980313802046241453616743996179799784948333408123666456078054975402233930;
    
    uint256 constant IC17x = 9644420134970614917918276763660740255881705883613568754990717610748161142338;
    uint256 constant IC17y = 6057246608400625128574045490366205109267182635495031148770746354579442521952;
    
    uint256 constant IC18x = 3478588600416828411411103709929443364350875935722379535054531373495869197302;
    uint256 constant IC18y = 14312139497598775136457694532354226575027823182198251149840842365373433448408;
    
    uint256 constant IC19x = 16478469522390352876826812932849485876750021274758447084770343652372421581875;
    uint256 constant IC19y = 5525105724620928136283079314841429313946285054350434613540639344526895834484;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[19] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations โ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/MintVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract MintVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 6506135815943976343670204718908252778100436948044695952269504614489235747522;
    uint256 constant deltax2 = 12917761706367159448552669332158549008424338800753983174002760426851264899916;
    uint256 constant deltay1 = 21054759061354342502671069523347944444365476693281335142489232816218318279843;
    uint256 constant deltay2 = 921807516250667254679639816527091672038652453691410152532432179406742682074;

    
    uint256 constant IC0x = 10121904041541460154551260390411876526139574666949788432677764574044027742051;
    uint256 constant IC0y = 6395114105467352463516423639828272877440036954754220055848039516989817256674;
    
    uint256 constant IC1x = 5586762719201810155133862083740714325655748243483738877755810028542797644739;
    uint256 constant IC1y = 9387879719287370926595730382657598610335084850078203728936667449453246554359;
    
    uint256 constant IC2x = 19420434315212518030589186167981244595406343548992012458488730749825996100239;
    uint256 constant IC2y = 3482657374383353276279298693752239555763142972311841530862645391131143881873;
    
    uint256 constant IC3x = 21667521945257749121492909465236139091096077691835364325355606431375269082282;
    uint256 constant IC3y = 12156175257782822331801928906256367913221851960540994586932487722549923413345;
    
    uint256 constant IC4x = 16828357126590671631798447095302651492589140460428270542352941484237941156483;
    uint256 constant IC4y = 3785759973408012513975276660945174958105045591429994983968533282503371539336;
    
    uint256 constant IC5x = 21244321325522105477060254124915502034148248502931960755663601081500950076300;
    uint256 constant IC5y = 14687177467139662957844534389099557537735007475047254307829149459337997284150;
    
    uint256 constant IC6x = 21404447565616225355770439075122853382066792760583316781611395109968504614761;
    uint256 constant IC6y = 3777910210505077428584254669424713454396973987622630869249106067166590299357;
    
    uint256 constant IC7x = 5644690004940482546460856256670502914882531219591199090065888636589494736039;
    uint256 constant IC7y = 16345970805899097192278870928687506101715169625232631539981164972434652655022;
    
    uint256 constant IC8x = 16593367704572145491497340027058421406291597779030039134573703992464863830646;
    uint256 constant IC8y = 19275772679724763916884927502599327291258343548738975909520313332884772129528;
    
    uint256 constant IC9x = 18338635157990571739660769292280252719367811451620901782236478705200001456515;
    uint256 constant IC9y = 12580365946981294431067603413481570211192375767222833113101936660967490853342;
    
    uint256 constant IC10x = 19880773599746588943745194809450382516728304373879942615347513263173728275196;
    uint256 constant IC10y = 128548754750873577554444615682746852358621588347676854260473817368140033519;
    
    uint256 constant IC11x = 6476719107464483530164368276818653110527411272303410163053488615734788766586;
    uint256 constant IC11y = 13331539055996208679678758084320772815107338352425913859433335410845899223811;
    
    uint256 constant IC12x = 17393436839515851750885277096607160266036302533767007170590322671069079326483;
    uint256 constant IC12y = 17336491525577930609097646312281682071744277090982994234361498925040239739760;
    
    uint256 constant IC13x = 14059139663320156276001577403575266145309546640724899667521029234074221180403;
    uint256 constant IC13y = 5963232262834884334488206091864494084893490405377454589196552297795638041488;
    
    uint256 constant IC14x = 13813470258321934033051704279698252148783024920181797002453328082368105474789;
    uint256 constant IC14y = 19760333797981660449134124218356560284106192590380149679255903109561686546313;
    
    uint256 constant IC15x = 11858117840318587547791069185551586430435948995333725070770764697634898894992;
    uint256 constant IC15y = 16621799951101200543458233987158204772158254202860685491749532125765298740749;
    
    uint256 constant IC16x = 13584356250500421508084566767718022822120888453124821650989966819848963029582;
    uint256 constant IC16y = 21121442557480691564262522113115528175177021588076736568194595390503813944019;
    
    uint256 constant IC17x = 4326226245481542040767942040881999777137473163343274779447151141265545792486;
    uint256 constant IC17y = 21183580388477113613358837765893868421637670220571970210021457037640835173809;
    
    uint256 constant IC18x = 2704745980008452624320271214496436840853635777289985169457654318338905712053;
    uint256 constant IC18y = 5498942242451865915343845370075402718280213375705928811712272696867696623122;
    
    uint256 constant IC19x = 18021323881247358977456866382503667963535769536490271165761105041938333860259;
    uint256 constant IC19y = 15056011404667104875167366478630077579580289596849055349190254216447781136049;
    
    uint256 constant IC20x = 2428670635260390602473903592482933886252233168437493591205178349351514000281;
    uint256 constant IC20y = 862350060646299115005420081148519933461348146447694025974629367115211964519;
    
    uint256 constant IC21x = 20557922324599650576215164022162024912213509843003042307546636524489843547931;
    uint256 constant IC21y = 1061522392679391742130691544383963509531829000498209937975610885874122363387;
    
    uint256 constant IC22x = 9114256858842496488535186312068922854228150055952688114444862375910254881995;
    uint256 constant IC22y = 20868937436899006110617091404782344741103549613810098330797141428653796030423;
    
    uint256 constant IC23x = 392332888128429361037702708407695212788446855280618226506466973682041689462;
    uint256 constant IC23y = 10986782868722900357976121669302445297980271976862420955075995610762868745084;
    
    uint256 constant IC24x = 12335561474727855982123382035622477594232361573497391299243618736725476900631;
    uint256 constant IC24y = 20340286770637453607265533856091115758478742882346824576410498508028320071146;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[24] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations โ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/RegistrationVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract RegistrationVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 19753714125923452630385433581442722093941065264298048276246815338797167448169;
    uint256 constant deltax2 = 2824093012045694268556486522753590084359236940213189502690301706344424715581;
    uint256 constant deltay1 = 18067530836866733450125362089378459710977233400131368676354166923678178030850;
    uint256 constant deltay2 = 12986835757414062294165220819491853575831232959693796161862995405626568533639;

    
    uint256 constant IC0x = 5049073754175979375715331231494813434614104647476713784192278874636518287456;
    uint256 constant IC0y = 13973039660095243213304729343482928815131903560133937124822026621516335683252;
    
    uint256 constant IC1x = 6960760860997719127050640389023071189120419160885047633543132031266205842967;
    uint256 constant IC1y = 14311210142759362992805316832152765774097518712372467130307901891389375007789;
    
    uint256 constant IC2x = 14970325264892984291437720194401230916657388050759523602370378142660744831477;
    uint256 constant IC2y = 15860538555168123807647719982845297214031403618163443664157964964439662885432;
    
    uint256 constant IC3x = 9095633778879314058949553908878900274830732566924382454865365752356228820208;
    uint256 constant IC3y = 872555237120135122336016443589602918886936394020805627011933688108936774726;
    
    uint256 constant IC4x = 16383214040587918206822141493152567743771449527138865305823970747014581995205;
    uint256 constant IC4y = 15807972914519003321398888297328267389104135252699104466520087670194802499103;
    
    uint256 constant IC5x = 19865793340402973866436804410911022538640660662316164831277333170166538152800;
    uint256 constant IC5y = 1466380730966029920868782474285618825793197367831481952454164420798011324299;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[5] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations โ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/TransferVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract TransferVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 3763145489265154227084511171694601212878632438189047805035774181671200721579;
    uint256 constant deltax2 = 19123758782558680960137049284286660834755919438304772090386326942336280507607;
    uint256 constant deltay1 = 2055449651368268424611099662557640196156614451951214953872156041652270884888;
    uint256 constant deltay2 = 4894238513642303098263860622238471992887790214981922367145986542927713649242;

    
    uint256 constant IC0x = 10534947708174160215201992304779041355498470735561003306499717122566742770626;
    uint256 constant IC0y = 977905257499899758791217822505228003462337033122097368830210745360601555342;
    
    uint256 constant IC1x = 3280711512314934753992505317526746468153049821370324146752079659712174232300;
    uint256 constant IC1y = 9336028462433315123867796333994191785575550026414826950323988687234821492567;
    
    uint256 constant IC2x = 15162904757480315297547642942646568889101029164132171480256830884259150251283;
    uint256 constant IC2y = 5543236365374398176471504758808152977042933422387633848583378303299793270756;
    
    uint256 constant IC3x = 6084599581719503190421548874454410642759752303455385862653438619168850972257;
    uint256 constant IC3y = 18221408640134590893699663063879232072826509494821669770579541736533993832423;
    
    uint256 constant IC4x = 13515294784299896617263177420364080405138679960108803709127908717931838641125;
    uint256 constant IC4y = 18537954088397403593567974022084871913708328503334967617431436055023979447391;
    
    uint256 constant IC5x = 18052165982957660268255521614825223786335394780677647206458385784232406504157;
    uint256 constant IC5y = 15194585058280412021740640814141568454746627730826424655106679430538982053654;
    
    uint256 constant IC6x = 6795673837897345581582685299965371845759418273539377917021912839836254998739;
    uint256 constant IC6y = 21657993441803516491832636271681043591945604671357149970048825080204553686618;
    
    uint256 constant IC7x = 11289069591450532499401972724447572002376453520281915368481681110785600567292;
    uint256 constant IC7y = 11928539623033527208857415982521538988739084305734749009299860340216923817607;
    
    uint256 constant IC8x = 21069306450658538733134282147277445263698906490240400327689099847099016892805;
    uint256 constant IC8y = 17386225215792739261329655602621235879743955668381844924635942683420074576174;
    
    uint256 constant IC9x = 14345437456753227245495940686700720956058390526322202366808609527984033660993;
    uint256 constant IC9y = 20783457650276182735214466418096310752840639854110597710747660731724327511323;
    
    uint256 constant IC10x = 4486441340824192164364882510367580608217147444088109552210786362403055241932;
    uint256 constant IC10y = 16553383197162304205323300390384875515644589603157855319848881923653657055218;
    
    uint256 constant IC11x = 7299849271075286253602519481881832740498497504048928918662655218108429284825;
    uint256 constant IC11y = 21860902462897801250346538563498742432578812847135047747638191825760100188844;
    
    uint256 constant IC12x = 20812311364493619358550828916571084941809811622004047558332288367068444292636;
    uint256 constant IC12y = 12016931719373400562450857278580603432222260403491989130190760226223433669838;
    
    uint256 constant IC13x = 5497135883066110411842507436361453534364438777740194801977407015457789050083;
    uint256 constant IC13y = 960289848958742655061746467902157315103658957325800360115467733778920704760;
    
    uint256 constant IC14x = 5231929274251912956972062967045818685875910122905492872577246977634648737843;
    uint256 constant IC14y = 2405680064306334170931852015314781533305421897621973941278348820986549273557;
    
    uint256 constant IC15x = 14432423838507076163732475853088150200901869051870980078541847122928808702858;
    uint256 constant IC15y = 13162477912034036392091090217125050953003275307601447359448369192560307791075;
    
    uint256 constant IC16x = 6035380084134788387796489655621652133939237219692536713085830198890102531157;
    uint256 constant IC16y = 2399413675745655961934247765244583346698339793807331712093749883838255391396;
    
    uint256 constant IC17x = 1755840344064269003982904724784588829875883176859314530482477354204358128073;
    uint256 constant IC17y = 2254035658088032093438783815005800506175183609989063203400053587352866305963;
    
    uint256 constant IC18x = 10798890848385583150817432575812471927781281538956290209396088794995757251699;
    uint256 constant IC18y = 17954866604704083608550796134404236420626288308545111154506695506614087706302;
    
    uint256 constant IC19x = 16347505387353659907142234702135154337293088908179815677326286365566466652892;
    uint256 constant IC19y = 8145400935245335001708439352534792707071085106081878093341920760316939810339;
    
    uint256 constant IC20x = 1675146216777597460950545026188423914140684419320163593588767283439513220964;
    uint256 constant IC20y = 3350896492191726464487860464991880712916569207980460035951208489640794805493;
    
    uint256 constant IC21x = 14963360443843679002951981438607054782948196458205149005110445616986857962149;
    uint256 constant IC21y = 5453682123596332752358242170390357649813170313370080322693195792615766005582;
    
    uint256 constant IC22x = 15857139261281078612816698520673496528634524033018907015066869560007114561368;
    uint256 constant IC22y = 1980632957785357477112204530352463186795117003870653324765557649080191593069;
    
    uint256 constant IC23x = 16478788219117512612181000397725550334291930466463033672428118170129909755975;
    uint256 constant IC23y = 448496014898525130300582250347934155241571361910686004171961088395557906873;
    
    uint256 constant IC24x = 1666825517524796314004984207461413135984918930374439646195676102947777182322;
    uint256 constant IC24y = 4231769516076965497747593863600552237823540573882692739018851158660080939768;
    
    uint256 constant IC25x = 3076619425752586210204729303861073992338095413231945893603783564036991027253;
    uint256 constant IC25y = 18163258048301667325957382686787210971933697470347155712452125397431467657627;
    
    uint256 constant IC26x = 12240984649194028123658663640999248201069935674255565459899301410323450592735;
    uint256 constant IC26y = 7409006959659622318645744477945350299438380296542336739366936950900796739795;
    
    uint256 constant IC27x = 14527565647042473833164468956000362795519314198262866225352631554103417406048;
    uint256 constant IC27y = 19163038429636451765415902370901493252440686868311522712756801834049736087286;
    
    uint256 constant IC28x = 4563064787502578607504522503795653524780441771903390561095040321594991012805;
    uint256 constant IC28y = 17132961897233615551711030277418083026528303676258815957139396120116493761491;
    
    uint256 constant IC29x = 10825384216191058605866379876945565560465943245071973007006264312285398033060;
    uint256 constant IC29y = 21577743268709413526652653885555866375927505893806393223914213433533358336358;
    
    uint256 constant IC30x = 6397191691971602863357148514208654665119261190406272901198661597143240375;
    uint256 constant IC30y = 19034368636483100848266322777417046441872774162624857636955426992047727086319;
    
    uint256 constant IC31x = 13887187887323344570981409187274970320617448786085046258948210932080686653886;
    uint256 constant IC31y = 18715879836330833238341482186679228139561235361790447129420164142460558259244;
    
    uint256 constant IC32x = 11249333327764660601508194401900817731177098928541819675032435010243826533510;
    uint256 constant IC32y = 18594519484247875970157793842670472272992161543336964034550143549078316481776;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[32] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                
                g1_mulAccC(_pVk, IC31x, IC31y, calldataload(add(pubSignals, 960)))
                
                g1_mulAccC(_pVk, IC32x, IC32y, calldataload(add(pubSignals, 992)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations โ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            
            checkField(calldataload(add(_pubSignals, 992)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/WithdrawVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract WithdrawVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 17937261609492175473978423283366042492782788118934277743325590061927472686823;
    uint256 constant deltax2 = 9134393277137786117877602562175203472042554058536880581948679621094751253663;
    uint256 constant deltay1 = 21830579691680039608885512644157042138865859432216493093304779889887319651703;
    uint256 constant deltay2 = 13560247966092290370160513680671248860780213214350811711788627488150106599867;

    
    uint256 constant IC0x = 17592896514411238838534259943087906039445412467749501855660552694930011809103;
    uint256 constant IC0y = 12732983330708765219970549274392016128270173019293005848551474757324971194427;
    
    uint256 constant IC1x = 4884577932082347864149139524102040008488705064603684844915539314596644874132;
    uint256 constant IC1y = 5456447315604083878474265800827509892021228387863831389892962189069605516459;
    
    uint256 constant IC2x = 17313454373712045907554165434725963402117845429222578159130609582778779362163;
    uint256 constant IC2y = 4407461008783085705651216674025467181197484228135456843989535495240785812495;
    
    uint256 constant IC3x = 10893636774628876142899763192646905724708189468282917758613650147010478133301;
    uint256 constant IC3y = 148896310776292842756025446759984436974180847194558332931999839598427070960;
    
    uint256 constant IC4x = 10775675593870925743575084889624246391515781987722804772444693341240701433005;
    uint256 constant IC4y = 21091396295200083161363697039830865943762788335711072967082811732416412142212;
    
    uint256 constant IC5x = 3277805223442060778292405741942548007218490041051348547437304074109624107356;
    uint256 constant IC5y = 14423944753390168508001610935122911632893435927783118919600891838924075393335;
    
    uint256 constant IC6x = 16279740598746831017838829127065220413108847820004536437353222843036288927209;
    uint256 constant IC6y = 11934056246616513677892280054066225650223628502415902228226616908265848867449;
    
    uint256 constant IC7x = 5071131858486439523644545889310168311903353944707113398976996997278587799687;
    uint256 constant IC7y = 11022965843210062064457659632129711893317662131236104884153566306811626505122;
    
    uint256 constant IC8x = 19131780283367531273448020668619041357172962162156115675741827445246630873287;
    uint256 constant IC8y = 10224436589841763650559926912214172567856653421053590774767009207269607380898;
    
    uint256 constant IC9x = 9015890207964856811111785067351720194541561850029096381425406768947368358563;
    uint256 constant IC9y = 6047643904429654109574184105636835293535463759429215740849034643735922891159;
    
    uint256 constant IC10x = 14203417831592538293633573944212232646895161398477212007798306234115933198031;
    uint256 constant IC10y = 16402598342815946882326203254821041228554468765346033642071484587006914175418;
    
    uint256 constant IC11x = 20547058030012031602382050197843576579725635037139342207584317836070120910810;
    uint256 constant IC11y = 18032163858711245709516724511475426102219042616668426511217798974437856519723;
    
    uint256 constant IC12x = 148439843878200889608411203087042067351611646430696078100079098168514978714;
    uint256 constant IC12y = 9307113381205316554384865850704068163340346564569932871492676068849222362101;
    
    uint256 constant IC13x = 21753481289618352374517009260504147501427757590648179575845005895425333005720;
    uint256 constant IC13y = 15435923224398640375717587240417911857458317269020496236194087111795302601904;
    
    uint256 constant IC14x = 15556836099875422007583907774078621468033908465380872159150755233143098695951;
    uint256 constant IC14y = 1129744811704326861736580949783332840905388382080396668503461990830533174097;
    
    uint256 constant IC15x = 13442230315665714018082790733663853073869607935268797374915472095839891294991;
    uint256 constant IC15y = 6217288894318109502763318183559473125294772219565374069029777927475585687108;
    
    uint256 constant IC16x = 13992512973627636194543618755294557224102658899504040367095379192332931057711;
    uint256 constant IC16y = 5489859536562727184655955989301069690715491550780438666774255315815483859767;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[16] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations โ F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/tokens/FeeERC20.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {SimpleERC20} from "./SimpleERC20.sol";

/**
 * @title FeeERC20
 * @dev ERC20 token with a fee mechanism for testing
 */
contract FeeERC20 is SimpleERC20 {
    uint256 public feeRate;
    address public feeCollector;

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimal,
        uint256 feeRates,
        address feeCollectors
    ) SimpleERC20(name, symbol, decimal) {
        feeRate = feeRates;
        feeCollector = feeCollectors;
    }

    /**
     * @dev Override transferFrom to apply a fee
     * @param sender The address to transfer from
     * @param recipient The address to transfer to
     * @param amount The amount to transfer
     * @return A boolean that indicates if the operation was successful
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = _msgSender();

        // Calculate fee
        uint256 fee = (amount * feeRate) / 100;
        uint256 amountAfterFee = amount - fee;

        // Deduct allowance
        _spendAllowance(sender, spender, amount);

        // Transfer amount after fee to recipient
        _transfer(sender, recipient, amountAfterFee);

        // Transfer fee to fee collector
        if (fee > 0) {
            _transfer(sender, feeCollector, fee);
        }

        return true;
    }
}



================================================
FILE: contracts/tokens/SimpleERC20.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract SimpleERC20 is ERC20 {
    // token decimals
    uint8 public decimals_;

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimal
    ) ERC20(name, symbol) {
        decimals_ = decimal;
    }

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }

    function decimals() public view virtual override returns (uint8) {
        return decimals_;
    }
}



================================================
FILE: contracts/tokens/TokenTracker.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {Ownable2Step, Ownable} from "@openzeppelin/contracts/access/Ownable2Step.sol";
import {TokenBlacklisted, InvalidOperation} from "../errors/Errors.sol";

/**
 * @title TokenTracker
 * @notice Contract for tracking ERC20 tokens in the encrypted ERC system
 * @dev This contract manages:
 *      1. Token registration and identification
 *      2. Token blacklisting for security
 *      3. Contract Mode (converter vs standalone)
 *
 * The contract can operate in two modes:
 * - Converter Mode: Wraps existing ERC20 tokens into encrypted tokens
 * - Standalone Mode: Operates as a standalone encrypted token
 */
contract TokenTracker is Ownable2Step {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice The next available token ID
    /// @dev Token IDs start from 1, with 0 reserved for the standalone version
    uint256 public nextTokenId = 1;

    /// @notice Indicates if the contract is operating in converter mode
    bool public isConverter;

    /// @notice Mapping from token address to token ID
    mapping(address tokenAddress => uint256 tokenId) public tokenIds;

    /// @notice Mapping from token ID to token address
    mapping(uint256 tokenId => address tokenAddress) public tokenAddresses;

    /// @notice Array of all registered token addresses
    address[] public tokens;

    /// @notice Mapping to track blacklisted tokens
    mapping(address tokenAddress => bool isBlacklisted)
        public blacklistedTokens;

    ///////////////////////////////////////////////////
    ///                   Modifiers                 ///
    ///////////////////////////////////////////////////

    /**
     * @notice Ensures the function is only called in converter mode
     * @dev Reverts with InvalidOperation if called in standalone mode
     */
    modifier onlyForConverter() {
        if (!isConverter) {
            revert InvalidOperation();
        }
        _;
    }

    /**
     * @notice Ensures the function is only called in standalone mode
     * @dev Reverts with InvalidOperation if called in converter mode
     */
    modifier onlyForStandalone() {
        if (isConverter) {
            revert InvalidOperation();
        }
        _;
    }

    /**
     * @notice Ensures the token is not blacklisted
     * @param tokenAddress Address of the token to check
     * @dev Reverts with TokenBlacklisted if the token is blacklisted
     */
    modifier revertIfBlacklisted(address tokenAddress) {
        if (blacklistedTokens[tokenAddress]) {
            revert TokenBlacklisted(tokenAddress);
        }
        _;
    }

    ///////////////////////////////////////////////////
    ///                   Constructor               ///
    ///////////////////////////////////////////////////

    /**
     * @notice Initializes the TokenTracker contract
     * @param isConverter_ Determines if the contract operates in converter mode
     * @dev Sets the initial mode of operation and initializes the owner
     */
    constructor(bool isConverter_) Ownable(msg.sender) {
        isConverter = isConverter_;
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Sets the blacklist status of a token
     * @param token Address of the token to blacklist/unblacklist
     * @param blacklisted True to blacklist, false to unblacklist
     * @dev Only the owner can call this function
     */
    function setTokenBlacklist(
        address token,
        bool blacklisted
    ) external onlyOwner {
        blacklistedTokens[token] = blacklisted;
    }

    /**
     * @notice Returns an array of all registered token addresses
     * @return Array of token addresses
     * @dev Used for enumeration and listing all supported tokens
     */
    function getTokens() external view returns (address[] memory) {
        return tokens;
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Adds a new token to the tracker
     * @param tokenAddress Address of the token to add
     * @dev This function:
     *      1. Assigns a new token ID
     *      2. Updates the token mappings
     *      3. Adds the token to the tokens array
     *      4. Increments the next token ID
     */
    function _addToken(address tokenAddress) internal {
        uint256 newTokenId = nextTokenId;
        tokenIds[tokenAddress] = newTokenId;
        tokenAddresses[newTokenId] = tokenAddress;
        tokens.push(tokenAddress);
        nextTokenId++;
    }
}



================================================
FILE: contracts/types/Types.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

struct Point {
    uint256 x;
    uint256 y;
}

struct CreateEncryptedERCParams {
    // registrar contract address for fetching users public key
    address registrar;
    // eERC is converter mode or not
    bool isConverter;
    // eERC Token
    string name;
    string symbol;
    uint8 decimals;
    // verifiers
    address mintVerifier;
    address withdrawVerifier;
    address transferVerifier;
    address burnVerifier;
}

struct AmountPCT {
    uint256[7] pct;
    uint256 index;
}

struct EncryptedBalance {
    EGCT eGCT;
    mapping(uint256 index => BalanceHistory history) balanceList;
    uint256 nonce;
    uint256 transactionIndex;
    uint256[7] balancePCT; // user balance pcts
    AmountPCT[] amountPCTs; // user amount pcts
}

struct BalanceHistory {
    uint256 index;
    bool isValid;
}

struct EGCT {
    Point c1;
    Point c2;
}

/// @dev The proof base is used to verify the proof
struct ProofPoints {
    uint256[2] a;
    uint256[2][2] b;
    uint256[2] c;
}

struct RegisterProof {
    ProofPoints proofPoints;
    uint256[5] publicSignals;
}

struct MintProof {
    ProofPoints proofPoints;
    uint256[24] publicSignals;
}

struct TransferProof {
    ProofPoints proofPoints;
    uint256[32] publicSignals;
}

struct BurnProof {
    ProofPoints proofPoints;
    uint256[19] publicSignals;
}

struct WithdrawProof {
    ProofPoints proofPoints;
    uint256[16] publicSignals;
}

struct TransferInputs {
    EGCT providedBalance;
    EGCT senderEncryptedAmount;
    EGCT receiverEncryptedAmount;
    uint256[7] amountPCT;
}

struct Metadata {
    address messageFrom;
    address messageTo;
    string messageType;
    bytes encryptedMsg;
}



================================================
FILE: contracts/verifiers/BurnCircuitGroth16Verifier.sol
================================================
// SPDX-License-Identifier: MIT

/* AUTOGENERATED FILE BY HARDHAT-ZKIT. DO NOT EDIT. */

pragma solidity >=0.7.0 <0.9.0;

contract BurnCircuitGroth16Verifier {
    // @dev scalar field size
    uint256 public constant SCALAR_FIELD_SIZE =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    /// @dev base field size
    uint256 public constant BASE_FIELD_SIZE =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    /// @dev verification key data
    uint256 public constant ALPHA_X =
        20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 public constant ALPHA_Y =
        9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 public constant BETA_X1 =
        4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 public constant BETA_X2 =
        6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 public constant BETA_Y1 =
        21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 public constant BETA_Y2 =
        10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 public constant GAMMA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant GAMMA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant GAMMA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant GAMMA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 public constant DELTA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant DELTA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant DELTA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant DELTA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;

    uint256 public constant IC0_X =
        6901175356638081608311197414548846861180656487838344346821425826024891512425;
    uint256 public constant IC0_Y =
        16944064565335445729234872967061190126362989003416853826016805426130180238191;
    uint256 public constant IC1_X =
        17908121343774581376092646765067170799970925894057937307165335210962871507135;
    uint256 public constant IC1_Y =
        6739483966006459958647545663755815825611388802168101513616676265213547687212;
    uint256 public constant IC2_X =
        766312427469543414624781412742178740436577019446000599209144238628925292414;
    uint256 public constant IC2_Y =
        11956596380120466965959213032841211036588141256244479446912141909087743946449;
    uint256 public constant IC3_X =
        9834218022277006635455703178457965188100848955744692108208207593466809819916;
    uint256 public constant IC3_Y =
        5985476150835890762503639978680541204908901815001963876083809679448099772187;
    uint256 public constant IC4_X =
        14827234556798753501841602996273223453620286706976793196274886644504394417263;
    uint256 public constant IC4_Y =
        17185284608112950506629319460803937653685676730131697135772583956246683209368;
    uint256 public constant IC5_X =
        17529671244301122497049371127369274616617935801308036584230660946886543200270;
    uint256 public constant IC5_Y =
        21375965875653643781871988041044406562099360028820246922430008152355558076267;
    uint256 public constant IC6_X =
        2071394549783234155236090578090590694025714713435714686283263242515370887037;
    uint256 public constant IC6_Y =
        1360924170815016231172148644602657489538698591468910875031083731851187567999;
    uint256 public constant IC7_X =
        10294779462906061052931321788054691400173934802237652306928745571023248394387;
    uint256 public constant IC7_Y =
        6555248292739776048079409559973894167013450042783785080733702895769749566613;
    uint256 public constant IC8_X =
        4433257889246655161353853222728772973385032114589816543634201923482683435584;
    uint256 public constant IC8_Y =
        14737241692493285661348398748630216205024305186831037514190361703045651615269;
    uint256 public constant IC9_X =
        14662929317288257322870633955431196105372083992377701985085624881517883523163;
    uint256 public constant IC9_Y =
        13045157851276202363238319024416490799176208505845980771766086158756862458455;
    uint256 public constant IC10_X =
        10464607531594481747431773960796216724225398526452385781876076453050117351904;
    uint256 public constant IC10_Y =
        17227459943128246860971844058080372581110192073599679941420162883374908732283;
    uint256 public constant IC11_X =
        745839102907798772556197076666683733791895469218705021459706695701505037999;
    uint256 public constant IC11_Y =
        11282995679713265974084133361652481201591627543141168082075682177048149337453;
    uint256 public constant IC12_X =
        17929575843708091862123276864146152761508698565499701379217956191629740643940;
    uint256 public constant IC12_Y =
        19694868618398715637769102075783868212304717698983166562284533403937378692315;
    uint256 public constant IC13_X =
        19788140654052540486857453303544057569825570368720987020309299320004547960581;
    uint256 public constant IC13_Y =
        6883822212531810402176678585679740471039138816982867861815020183660906571642;
    uint256 public constant IC14_X =
        6016243318855719046735289125777883097005663608233773332990082345142498280371;
    uint256 public constant IC14_Y =
        21204516959587943017810864594613242220785397660490599724380523851223540954454;
    uint256 public constant IC15_X =
        9891573095652303648634434897797773521123041746620991186215470158961116717665;
    uint256 public constant IC15_Y =
        15129361566109667756079905439551006265474721391302786501924664404711249139905;
    uint256 public constant IC16_X =
        9439270817025434198507441583978754692817321436471324362734438362897111301924;
    uint256 public constant IC16_Y =
        17736726489009951896104159456871058989709210357063650885766330312145063724146;
    uint256 public constant IC17_X =
        7287813417026604917333767312326818451716773551965506932628922979658721400484;
    uint256 public constant IC17_Y =
        21190069513632277449640126663995547292551888059992765226941465993312580710136;
    uint256 public constant IC18_X =
        18870427155174730509179857527710685647524233977259143240992234215761896727263;
    uint256 public constant IC18_Y =
        21595208618611453816106702920660402890633778123650117008434425697322727495324;
    uint256 public constant IC19_X =
        2474736367332117814843921180480737874685068379574560055026846626150944220277;
    uint256 public constant IC19_Y =
        11798959751686284671429858411798094190882362783079508053655067482307321072055;
    
    /// @dev memory pointer sizes
    uint16 public constant P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE = 128;
    uint16 public constant P_TOTAL_SIZE = 896;

    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[19] memory publicSignals_
    ) public view returns (bool verified_) {
        assembly {
            function checkField(signal_) -> res_ {
                res_ := lt(signal_, SCALAR_FIELD_SIZE)
            }

            function g1MulAdd(pR_, x_, y_, s_) -> res_ {
                let pointer_ := mload(64) // free pointer

                mstore(pointer_, x_)
                mstore(add(pointer_, 32), y_)
                mstore(add(pointer_, 64), s_)

                res_ := staticcall(6000, 7, pointer_, 96, pointer_, 64) // ecMul
                res_ := and(res_, gt(returndatasize(), 0)) // check that multiplication succeeded

                if iszero(res_) {
                    leave
                }

                mstore(add(pointer_, 64), mload(pR_))
                mstore(add(pointer_, 96), mload(add(pR_, 32)))

                res_ := staticcall(150, 6, pointer_, 128, pR_, 64) // ecAdd
                res_ := and(res_, gt(returndatasize(), 0)) // check that addition succeeded
            }

            function checkPairing(pA_, pB_, pC_, pubSignals_, pointer_) -> res_ {
                let pPairing_ := add(pointer_, P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE)

                mstore(pointer_, IC0_X)
                mstore(add(pointer_, 32), IC0_Y)

                /// @dev compute the linear combination of public signals
                if iszero(g1MulAdd(pointer_, IC1_X, IC1_Y, mload(add(pubSignals_, 0)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC2_X, IC2_Y, mload(add(pubSignals_, 32)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC3_X, IC3_Y, mload(add(pubSignals_, 64)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC4_X, IC4_Y, mload(add(pubSignals_, 96)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC5_X, IC5_Y, mload(add(pubSignals_, 128)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC6_X, IC6_Y, mload(add(pubSignals_, 160)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC7_X, IC7_Y, mload(add(pubSignals_, 192)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC8_X, IC8_Y, mload(add(pubSignals_, 224)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC9_X, IC9_Y, mload(add(pubSignals_, 256)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC10_X, IC10_Y, mload(add(pubSignals_, 288)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC11_X, IC11_Y, mload(add(pubSignals_, 320)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC12_X, IC12_Y, mload(add(pubSignals_, 352)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC13_X, IC13_Y, mload(add(pubSignals_, 384)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC14_X, IC14_Y, mload(add(pubSignals_, 416)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC15_X, IC15_Y, mload(add(pubSignals_, 448)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC16_X, IC16_Y, mload(add(pubSignals_, 480)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC17_X, IC17_Y, mload(add(pubSignals_, 512)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC18_X, IC18_Y, mload(add(pubSignals_, 544)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC19_X, IC19_Y, mload(add(pubSignals_, 576)))) {
                    leave
                }
                
                /// @dev -A
                mstore(pPairing_, mload(pA_))
                mstore(
                    add(pPairing_, 32),
                    mod(sub(BASE_FIELD_SIZE, mload(add(pA_, 32))), BASE_FIELD_SIZE)
                )

                /// @dev B
                mstore(add(pPairing_, 64), mload(mload(pB_)))
                mstore(add(pPairing_, 96), mload(add(mload(pB_), 32)))
                mstore(add(pPairing_, 128), mload(mload(add(pB_, 32))))
                mstore(add(pPairing_, 160), mload(add(mload(add(pB_, 32)), 32)))

                /// @dev alpha1
                mstore(add(pPairing_, 192), ALPHA_X)
                mstore(add(pPairing_, 224), ALPHA_Y)

                /// @dev beta2
                mstore(add(pPairing_, 256), BETA_X1)
                mstore(add(pPairing_, 288), BETA_X2)
                mstore(add(pPairing_, 320), BETA_Y1)
                mstore(add(pPairing_, 352), BETA_Y2)

                /// @dev public signals
                mstore(add(pPairing_, 384), mload(pointer_))
                mstore(add(pPairing_, 416), mload(add(pointer_, 32)))

                /// @dev gamma2
                mstore(add(pPairing_, 448), GAMMA_X1)
                mstore(add(pPairing_, 480), GAMMA_X2)
                mstore(add(pPairing_, 512), GAMMA_Y1)
                mstore(add(pPairing_, 544), GAMMA_Y2)

                /// @dev C
                mstore(add(pPairing_, 576), mload(pC_))
                mstore(add(pPairing_, 608), mload(add(pC_, 32)))

                /// @dev delta2
                mstore(add(pPairing_, 640), DELTA_X1)
                mstore(add(pPairing_, 672), DELTA_X2)
                mstore(add(pPairing_, 704), DELTA_Y1)
                mstore(add(pPairing_, 736), DELTA_Y2)

                res_ := staticcall(181000, 8, pPairing_, 768, pPairing_, 32) // ecPairing
                res_ := and(res_, mload(pPairing_)) // check that pairing succeeded
            }

            let pointer_ := mload(64) // free pointer
            mstore(64, add(pointer_, P_TOTAL_SIZE))

            /// @dev check that all public signals are in F
            verified_ := 1
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 0))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 32))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 64))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 96))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 128))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 160))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 192))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 224))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 256))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 288))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 320))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 352))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 384))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 416))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 448))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 480))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 512))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 544))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 576))))
            
            /// @dev check pairings
            if not(iszero(verified_)) {
                verified_ := checkPairing(pointA_, pointB_, pointC_, publicSignals_, pointer_)
            }
        }
    }
}



================================================
FILE: contracts/verifiers/MintCircuitGroth16Verifier.sol
================================================
// SPDX-License-Identifier: MIT

/* AUTOGENERATED FILE BY HARDHAT-ZKIT. DO NOT EDIT. */

pragma solidity >=0.7.0 <0.9.0;

contract MintCircuitGroth16Verifier {
    // @dev scalar field size
    uint256 public constant SCALAR_FIELD_SIZE =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    /// @dev base field size
    uint256 public constant BASE_FIELD_SIZE =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    /// @dev verification key data
    uint256 public constant ALPHA_X =
        20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 public constant ALPHA_Y =
        9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 public constant BETA_X1 =
        4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 public constant BETA_X2 =
        6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 public constant BETA_Y1 =
        21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 public constant BETA_Y2 =
        10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 public constant GAMMA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant GAMMA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant GAMMA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant GAMMA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 public constant DELTA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant DELTA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant DELTA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant DELTA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;

    uint256 public constant IC0_X =
        10121904041541460154551260390411876526139574666949788432677764574044027742051;
    uint256 public constant IC0_Y =
        6395114105467352463516423639828272877440036954754220055848039516989817256674;
    uint256 public constant IC1_X =
        5586762719201810155133862083740714325655748243483738877755810028542797644739;
    uint256 public constant IC1_Y =
        9387879719287370926595730382657598610335084850078203728936667449453246554359;
    uint256 public constant IC2_X =
        19420434315212518030589186167981244595406343548992012458488730749825996100239;
    uint256 public constant IC2_Y =
        3482657374383353276279298693752239555763142972311841530862645391131143881873;
    uint256 public constant IC3_X =
        21667521945257749121492909465236139091096077691835364325355606431375269082282;
    uint256 public constant IC3_Y =
        12156175257782822331801928906256367913221851960540994586932487722549923413345;
    uint256 public constant IC4_X =
        16828357126590671631798447095302651492589140460428270542352941484237941156483;
    uint256 public constant IC4_Y =
        3785759973408012513975276660945174958105045591429994983968533282503371539336;
    uint256 public constant IC5_X =
        21244321325522105477060254124915502034148248502931960755663601081500950076300;
    uint256 public constant IC5_Y =
        14687177467139662957844534389099557537735007475047254307829149459337997284150;
    uint256 public constant IC6_X =
        21404447565616225355770439075122853382066792760583316781611395109968504614761;
    uint256 public constant IC6_Y =
        3777910210505077428584254669424713454396973987622630869249106067166590299357;
    uint256 public constant IC7_X =
        5644690004940482546460856256670502914882531219591199090065888636589494736039;
    uint256 public constant IC7_Y =
        16345970805899097192278870928687506101715169625232631539981164972434652655022;
    uint256 public constant IC8_X =
        16593367704572145491497340027058421406291597779030039134573703992464863830646;
    uint256 public constant IC8_Y =
        19275772679724763916884927502599327291258343548738975909520313332884772129528;
    uint256 public constant IC9_X =
        18338635157990571739660769292280252719367811451620901782236478705200001456515;
    uint256 public constant IC9_Y =
        12580365946981294431067603413481570211192375767222833113101936660967490853342;
    uint256 public constant IC10_X =
        19880773599746588943745194809450382516728304373879942615347513263173728275196;
    uint256 public constant IC10_Y =
        128548754750873577554444615682746852358621588347676854260473817368140033519;
    uint256 public constant IC11_X =
        6476719107464483530164368276818653110527411272303410163053488615734788766586;
    uint256 public constant IC11_Y =
        13331539055996208679678758084320772815107338352425913859433335410845899223811;
    uint256 public constant IC12_X =
        17393436839515851750885277096607160266036302533767007170590322671069079326483;
    uint256 public constant IC12_Y =
        17336491525577930609097646312281682071744277090982994234361498925040239739760;
    uint256 public constant IC13_X =
        14059139663320156276001577403575266145309546640724899667521029234074221180403;
    uint256 public constant IC13_Y =
        5963232262834884334488206091864494084893490405377454589196552297795638041488;
    uint256 public constant IC14_X =
        13813470258321934033051704279698252148783024920181797002453328082368105474789;
    uint256 public constant IC14_Y =
        19760333797981660449134124218356560284106192590380149679255903109561686546313;
    uint256 public constant IC15_X =
        11858117840318587547791069185551586430435948995333725070770764697634898894992;
    uint256 public constant IC15_Y =
        16621799951101200543458233987158204772158254202860685491749532125765298740749;
    uint256 public constant IC16_X =
        13584356250500421508084566767718022822120888453124821650989966819848963029582;
    uint256 public constant IC16_Y =
        21121442557480691564262522113115528175177021588076736568194595390503813944019;
    uint256 public constant IC17_X =
        4326226245481542040767942040881999777137473163343274779447151141265545792486;
    uint256 public constant IC17_Y =
        21183580388477113613358837765893868421637670220571970210021457037640835173809;
    uint256 public constant IC18_X =
        2704745980008452624320271214496436840853635777289985169457654318338905712053;
    uint256 public constant IC18_Y =
        5498942242451865915343845370075402718280213375705928811712272696867696623122;
    uint256 public constant IC19_X =
        18021323881247358977456866382503667963535769536490271165761105041938333860259;
    uint256 public constant IC19_Y =
        15056011404667104875167366478630077579580289596849055349190254216447781136049;
    uint256 public constant IC20_X =
        2428670635260390602473903592482933886252233168437493591205178349351514000281;
    uint256 public constant IC20_Y =
        862350060646299115005420081148519933461348146447694025974629367115211964519;
    uint256 public constant IC21_X =
        20557922324599650576215164022162024912213509843003042307546636524489843547931;
    uint256 public constant IC21_Y =
        1061522392679391742130691544383963509531829000498209937975610885874122363387;
    uint256 public constant IC22_X =
        9114256858842496488535186312068922854228150055952688114444862375910254881995;
    uint256 public constant IC22_Y =
        20868937436899006110617091404782344741103549613810098330797141428653796030423;
    uint256 public constant IC23_X =
        392332888128429361037702708407695212788446855280618226506466973682041689462;
    uint256 public constant IC23_Y =
        10986782868722900357976121669302445297980271976862420955075995610762868745084;
    uint256 public constant IC24_X =
        12335561474727855982123382035622477594232361573497391299243618736725476900631;
    uint256 public constant IC24_Y =
        20340286770637453607265533856091115758478742882346824576410498508028320071146;
    
    /// @dev memory pointer sizes
    uint16 public constant P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE = 128;
    uint16 public constant P_TOTAL_SIZE = 896;

    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[24] memory publicSignals_
    ) public view returns (bool verified_) {
        assembly {
            function checkField(signal_) -> res_ {
                res_ := lt(signal_, SCALAR_FIELD_SIZE)
            }

            function g1MulAdd(pR_, x_, y_, s_) -> res_ {
                let pointer_ := mload(64) // free pointer

                mstore(pointer_, x_)
                mstore(add(pointer_, 32), y_)
                mstore(add(pointer_, 64), s_)

                res_ := staticcall(6000, 7, pointer_, 96, pointer_, 64) // ecMul
                res_ := and(res_, gt(returndatasize(), 0)) // check that multiplication succeeded

                if iszero(res_) {
                    leave
                }

                mstore(add(pointer_, 64), mload(pR_))
                mstore(add(pointer_, 96), mload(add(pR_, 32)))

                res_ := staticcall(150, 6, pointer_, 128, pR_, 64) // ecAdd
                res_ := and(res_, gt(returndatasize(), 0)) // check that addition succeeded
            }

            function checkPairing(pA_, pB_, pC_, pubSignals_, pointer_) -> res_ {
                let pPairing_ := add(pointer_, P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE)

                mstore(pointer_, IC0_X)
                mstore(add(pointer_, 32), IC0_Y)

                /// @dev compute the linear combination of public signals
                if iszero(g1MulAdd(pointer_, IC1_X, IC1_Y, mload(add(pubSignals_, 0)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC2_X, IC2_Y, mload(add(pubSignals_, 32)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC3_X, IC3_Y, mload(add(pubSignals_, 64)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC4_X, IC4_Y, mload(add(pubSignals_, 96)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC5_X, IC5_Y, mload(add(pubSignals_, 128)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC6_X, IC6_Y, mload(add(pubSignals_, 160)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC7_X, IC7_Y, mload(add(pubSignals_, 192)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC8_X, IC8_Y, mload(add(pubSignals_, 224)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC9_X, IC9_Y, mload(add(pubSignals_, 256)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC10_X, IC10_Y, mload(add(pubSignals_, 288)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC11_X, IC11_Y, mload(add(pubSignals_, 320)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC12_X, IC12_Y, mload(add(pubSignals_, 352)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC13_X, IC13_Y, mload(add(pubSignals_, 384)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC14_X, IC14_Y, mload(add(pubSignals_, 416)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC15_X, IC15_Y, mload(add(pubSignals_, 448)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC16_X, IC16_Y, mload(add(pubSignals_, 480)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC17_X, IC17_Y, mload(add(pubSignals_, 512)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC18_X, IC18_Y, mload(add(pubSignals_, 544)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC19_X, IC19_Y, mload(add(pubSignals_, 576)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC20_X, IC20_Y, mload(add(pubSignals_, 608)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC21_X, IC21_Y, mload(add(pubSignals_, 640)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC22_X, IC22_Y, mload(add(pubSignals_, 672)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC23_X, IC23_Y, mload(add(pubSignals_, 704)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC24_X, IC24_Y, mload(add(pubSignals_, 736)))) {
                    leave
                }
                
                /// @dev -A
                mstore(pPairing_, mload(pA_))
                mstore(
                    add(pPairing_, 32),
                    mod(sub(BASE_FIELD_SIZE, mload(add(pA_, 32))), BASE_FIELD_SIZE)
                )

                /// @dev B
                mstore(add(pPairing_, 64), mload(mload(pB_)))
                mstore(add(pPairing_, 96), mload(add(mload(pB_), 32)))
                mstore(add(pPairing_, 128), mload(mload(add(pB_, 32))))
                mstore(add(pPairing_, 160), mload(add(mload(add(pB_, 32)), 32)))

                /// @dev alpha1
                mstore(add(pPairing_, 192), ALPHA_X)
                mstore(add(pPairing_, 224), ALPHA_Y)

                /// @dev beta2
                mstore(add(pPairing_, 256), BETA_X1)
                mstore(add(pPairing_, 288), BETA_X2)
                mstore(add(pPairing_, 320), BETA_Y1)
                mstore(add(pPairing_, 352), BETA_Y2)

                /// @dev public signals
                mstore(add(pPairing_, 384), mload(pointer_))
                mstore(add(pPairing_, 416), mload(add(pointer_, 32)))

                /// @dev gamma2
                mstore(add(pPairing_, 448), GAMMA_X1)
                mstore(add(pPairing_, 480), GAMMA_X2)
                mstore(add(pPairing_, 512), GAMMA_Y1)
                mstore(add(pPairing_, 544), GAMMA_Y2)

                /// @dev C
                mstore(add(pPairing_, 576), mload(pC_))
                mstore(add(pPairing_, 608), mload(add(pC_, 32)))

                /// @dev delta2
                mstore(add(pPairing_, 640), DELTA_X1)
                mstore(add(pPairing_, 672), DELTA_X2)
                mstore(add(pPairing_, 704), DELTA_Y1)
                mstore(add(pPairing_, 736), DELTA_Y2)

                res_ := staticcall(181000, 8, pPairing_, 768, pPairing_, 32) // ecPairing
                res_ := and(res_, mload(pPairing_)) // check that pairing succeeded
            }

            let pointer_ := mload(64) // free pointer
            mstore(64, add(pointer_, P_TOTAL_SIZE))

            /// @dev check that all public signals are in F
            verified_ := 1
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 0))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 32))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 64))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 96))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 128))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 160))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 192))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 224))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 256))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 288))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 320))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 352))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 384))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 416))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 448))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 480))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 512))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 544))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 576))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 608))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 640))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 672))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 704))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 736))))
            
            /// @dev check pairings
            if not(iszero(verified_)) {
                verified_ := checkPairing(pointA_, pointB_, pointC_, publicSignals_, pointer_)
            }
        }
    }
}



================================================
FILE: contracts/verifiers/RegistrationCircuitGroth16Verifier.sol
================================================
// SPDX-License-Identifier: MIT

/* AUTOGENERATED FILE BY HARDHAT-ZKIT. DO NOT EDIT. */

pragma solidity >=0.7.0 <0.9.0;

contract RegistrationCircuitGroth16Verifier {
    // @dev scalar field size
    uint256 public constant SCALAR_FIELD_SIZE =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    /// @dev base field size
    uint256 public constant BASE_FIELD_SIZE =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    /// @dev verification key data
    uint256 public constant ALPHA_X =
        20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 public constant ALPHA_Y =
        9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 public constant BETA_X1 =
        4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 public constant BETA_X2 =
        6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 public constant BETA_Y1 =
        21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 public constant BETA_Y2 =
        10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 public constant GAMMA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant GAMMA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant GAMMA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant GAMMA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 public constant DELTA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant DELTA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant DELTA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant DELTA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;

    uint256 public constant IC0_X =
        4004410872179300339480249405398939298715031489893009961199535208964457923750;
    uint256 public constant IC0_Y =
        11142026210898871476346451274761099606196839371161747578101583645702654533240;
    uint256 public constant IC1_X =
        14970325264892984291437720194401230916657388050759523602370378142660744831477;
    uint256 public constant IC1_Y =
        15860538555168123807647719982845297214031403618163443664157964964439662885432;
    uint256 public constant IC2_X =
        2280562765509182195246897364500489648120102222444059313572774422753200337271;
    uint256 public constant IC2_Y =
        7147694953124310609924568435428058789638619830198023240430532891482445253803;
    uint256 public constant IC3_X =
        7737404298715916349870992960929602974683638711993694006376159661700137192127;
    uint256 public constant IC3_Y =
        7116770325362339113448473214465082117296435085200119804036017348236401720128;
    uint256 public constant IC4_X =
        3130277824222995531291107528843021785954629147236040284065307643519664903928;
    uint256 public constant IC4_Y =
        11742475342174768235971584303810158858484260897318069476115756668898865449280;
    uint256 public constant IC5_X =
        14791539702458079086636207858304521437578092734215012107895193807307152746110;
    uint256 public constant IC5_Y =
        12489284483607948781669905789845942689563255773386215312172350852214666005897;
    
    /// @dev memory pointer sizes
    uint16 public constant P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE = 128;
    uint16 public constant P_TOTAL_SIZE = 896;

    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[5] memory publicSignals_
    ) public view returns (bool verified_) {
        assembly {
            function checkField(signal_) -> res_ {
                res_ := lt(signal_, SCALAR_FIELD_SIZE)
            }

            function g1MulAdd(pR_, x_, y_, s_) -> res_ {
                let pointer_ := mload(64) // free pointer

                mstore(pointer_, x_)
                mstore(add(pointer_, 32), y_)
                mstore(add(pointer_, 64), s_)

                res_ := staticcall(6000, 7, pointer_, 96, pointer_, 64) // ecMul
                res_ := and(res_, gt(returndatasize(), 0)) // check that multiplication succeeded

                if iszero(res_) {
                    leave
                }

                mstore(add(pointer_, 64), mload(pR_))
                mstore(add(pointer_, 96), mload(add(pR_, 32)))

                res_ := staticcall(150, 6, pointer_, 128, pR_, 64) // ecAdd
                res_ := and(res_, gt(returndatasize(), 0)) // check that addition succeeded
            }

            function checkPairing(pA_, pB_, pC_, pubSignals_, pointer_) -> res_ {
                let pPairing_ := add(pointer_, P_PUBLIC_SIGNALS_ACCUMULATOR_SIZE)

                mstore(pointer_, IC0_X)
                mstore(add(pointer_, 32), IC0_Y)

                /// @dev compute the linear combination of public signals
                if iszero(g1MulAdd(pointer_, IC1_X, IC1_Y, mload(add(pubSignals_, 0)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC2_X, IC2_Y, mload(add(pubSignals_, 32)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC3_X, IC3_Y, mload(add(pubSignals_, 64)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC4_X, IC4_Y, mload(add(pubSignals_, 96)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC5_X, IC5_Y, mload(add(pubSignals_, 128)))) {
                    leave
                }
                
                /// @dev -A
                mstore(pPairing_, mload(pA_))
                mstore(
                    add(pPairing_, 32),
                    mod(sub(BASE_FIELD_SIZE, mload(add(pA_, 32))), BASE_FIELD_SIZE)
                )

                /// @dev B
                mstore(add(pPairing_, 64), mload(mload(pB_)))
                mstore(add(pPairing_, 96), mload(add(mload(pB_), 32)))
                mstore(add(pPairing_, 128), mload(mload(add(pB_, 32))))
                mstore(add(pPairing_, 160), mload(add(mload(add(pB_, 32)), 32)))

                /// @dev alpha1
                mstore(add(pPairing_, 192), ALPHA_X)
                mstore(add(pPairing_, 224), ALPHA_Y)

                /// @dev beta2
                mstore(add(pPairing_, 256), BETA_X1)
                mstore(add(pPairing_, 288), BETA_X2)
                mstore(add(pPairing_, 320), BETA_Y1)
                mstore(add(pPairing_, 352), BETA_Y2)

                /// @dev public signals
                mstore(add(pPairing_, 384), mload(pointer_))
                mstore(add(pPairing_, 416), mload(add(pointer_, 32)))

                /// @dev gamma2
                mstore(add(pPairing_, 448), GAMMA_X1)
                mstore(add