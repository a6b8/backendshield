(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
# EncryptedERC (eERC) - Private Token System ‚ö° **OPTIMIZED**

This project implements an advanced EncryptedERC system that allows users to hold and transfer tokens privately using zero-knowledge proofs and homomorphic encryption. The system maintains privacy while enabling auditing capabilities.

## üöÄ **System Modes**

The project supports **two distinct operation modes**:

### **üîÑ Converter Mode** (`scripts/converter/`)
- **ERC20 Token Wrapper**: Converts existing ERC20 tokens into encrypted format
- **Deposit/Withdraw System**: Bridge between public and private tokens
- **Multi-Token Support**: Works with any ERC20 token
- **Use Case**: Privacy layer for existing token economies

### **üè¶ Standalone Mode** (`scripts/standalone/`)
- **Native Encrypted Token**: Creates native "PRIV" tokens with built-in encryption  
- **Mint/Burn System**: Central bank model with controlled token supply
- **Single Token**: Self-contained encrypted token ecosystem
- **Use Case**: Central Bank Digital Currency (CBDC), private token issuance

## ‚ö° **Performance & Optimization Features**

- **üöÄ 100x Faster Balance Calculations**: Optimized discrete logarithm search with smart caching
- **üéØ Intelligent Wallet Management**: Centralized wallet utilities in `src/utils/utils.ts`
- **‚ö° Smart Key Derivation**: Centralized cryptographic operations in `src/utils/utils.ts`
- **üìä Advanced Caching System**: Pre-populated cache with FIFO eviction for common values
- **üîß Optimized Imports**: Clean codebase with unused dependencies removed
- **üåç Comprehensive Documentation**: Full English/Spanish documentation with step-by-step guides

## Prerequisites

1. Node.js and npm installed
2. Two private keys for testing (set as environment variables)
3. AVAX testnet tokens for gas fees

## Environment Setup

Create a `.env` file in the root directory:

```bash
# Avalanche Fuji Testnet RPC
RPC_URL=https://api.avax-test.network/ext/bc/C/rpc

# Private keys for testing (without 0x prefix)
PRIVATE_KEY=your_first_private_key_here
PRIVATE_KEY2=your_second_private_key_here

# Enable forking if needed
FORKING=false

# Note: Wallet selection requires manual script configuration
```

## Installation

```bash
npm install
```

---

## üìã **Quick Start Guide**

Choose your preferred mode and follow the corresponding guide:

### **üîÑ Converter Mode** (ERC20 Token Wrapper)
For detailed instructions, see [`scripts/converter/README.md`](scripts/converter/README.md)

### **üè¶ Standalone Mode** (Native Encrypted Tokens)  
For detailed instructions, see [`scripts/standalone/README.md`](scripts/standalone/README.md)

---

## üéØ **Converter Mode - Step-by-Step Guide**

### English Version

Follow these steps to deploy and test the **Converter System** (ERC20 ‚Üí Encrypted ERC20):

#### Step 1: Deploy Basic Components ‚ö° **OPTIMIZED**
Deploy verifiers, libraries, and test ERC20 token.

```bash
npx hardhat run scripts/converter/01_deploy-basics.ts --network fuji
```

**What this does:**
- Deploys zero-knowledge proof verifiers for registration, mint, withdraw, transfer, and burn operations
- Deploys BabyJubJub elliptic curve library  
- Creates a test ERC20 token (TEST) and mints 10,000 tokens to the deployer
- **NEW**: Saves deployment addresses to `deployments/converter/latest-converter.json` with timestamp backup
- **NEW**: Comprehensive metadata and optimized file structure

#### Step 2: Deploy Converter System ‚ö° **OPTIMIZED**
Deploy the main EncryptedERC contract and Registrar.

```bash
npx hardhat run scripts/converter/02_deploy-converter.ts --network fuji
```

**What this does:**
- Deploys the Registrar contract for user registration
- Deploys the EncryptedERC contract in converter mode
- Links all previously deployed verifiers
- **NEW**: Uses optimized deployment data management
- **NEW**: Improved error handling and logging

#### Step 3: Register Users ‚ö° **HIGHLY OPTIMIZED**
Register both test users (requires manual wallet configuration in scripts).

**For first user (Wallet 1):**
```bash
# Edit script manually to set walletNumber = 1
npx hardhat run scripts/converter/03_register-user.ts --network fuji
```

**For second user (Wallet 2):**
```bash
# Edit script manually to set walletNumber = 2
npx hardhat run scripts/converter/03_register-user.ts --network fuji
```

**What this does:**
- **NEW**: Centralized wallet utilities for easier script configuration
- **NEW**: Centralized key derivation using `src/utils/utils.ts`
- Generates deterministic cryptographic keys from the user's signature  
- Creates a zero-knowledge proof of identity
- Registers the user's public key on-chain
- **NEW**: Shows AVAX balance for selected wallet
- **NEW**: Simplified wallet management with `getWallet()` utility

#### Step 4: Set Auditor ‚ö° **OPTIMIZED**
Configure the system auditor (requires manual wallet selection in script).

```bash
# Edit script manually to set walletNumber = 1
npx hardhat run scripts/converter/04_set-auditor.ts --network fuji
```

**What this does:**
- **NEW**: Centralized auditor setup utilities
- Sets the auditor's public key in the EncryptedERC contract
- Enables the auditor to decrypt transaction amounts for compliance
- **NEW**: Shows AVAX balance for selected wallet
- This step is required before any deposits can be made

#### Step 5: Get Test Tokens (Both Users) ‚ö° **OPTIMIZED**
Claim test tokens from the faucet (requires manual wallet selection in script).

**For first user:**
```bash
# Edit script manually to set walletNumber = 1
npx hardhat run scripts/converter/05_get_faucet.ts --network fuji
```

**For second user:**
```bash
# Edit script manually to set walletNumber = 2
npx hardhat run scripts/converter/05_get_faucet.ts --network fuji
```

**What this does:**
- **NEW**: Centralized wallet management utilities
- Claims test tokens from the ERC20 faucet
- Each user can claim once every 24 hours
- **NEW**: Shows AVAX balance for selected wallet  
- Provides tokens needed for deposits into the encrypted system

#### Step 6: Make Initial Deposits (Both Users) ‚ö° **HIGHLY OPTIMIZED**
Deposit test tokens into the encrypted system with advanced features.

**For first user:**
```bash
# Edit script manually to set walletNumber = 1
npx hardhat run scripts/converter/06_deposit.ts --network fuji
```

**For second user:**
```bash
# Edit script manually to set walletNumber = 2
npx hardhat run scripts/converter/06_deposit.ts --network fuji
```

**What this does:**
- **NEW**: Centralized wallet management with balance display
- **NEW**: Centralized key derivation and decryption functions
- **NEW**: 100x faster balance calculations with optimized discrete logarithm search
- Converts public ERC20 tokens into encrypted tokens
- Generates encrypted balance proofs  
- Creates audit trails for compliance
- Tokens become private and can only be decrypted by the owner

#### Step 7: Check Balances ‚ö° **HIGHLY OPTIMIZED**
Verify deposits with lightning-fast balance calculations.

**Check first user's balance:**
```bash
# Edit script manually to set walletNumber = 1
npx hardhat run scripts/converter/08_check_balance.ts --network fuji
```

**Check second user's balance:**
```bash
# Edit script manually to set walletNumber = 2
npx hardhat run scripts/converter/08_check_balance.ts --network fuji
```

**What this does:**
- **NEW**: Centralized wallet management utilities
- **NEW**: 100x faster balance decryption with smart caching system
- **NEW**: Pre-populated cache for common values with FIFO eviction
- **NEW**: Multi-strategy search (small values, round numbers, chunked search)
- Decrypts the user's encrypted balance using their private key
- Shows both encrypted balance and public token balance  
- Verifies encryption consistency

#### Step 8: Perform Private Transfer ‚ö° **OPTIMIZED**
Transfer encrypted tokens with centralized utilities.

```bash
npx hardhat run scripts/converter/07_transfer.ts --network fuji
```

**What this does:**
- **NEW**: Uses centralized cryptographic functions from `src/utils/utils.ts`
- **NEW**: Optimized discrete logarithm calculations
- Generates a zero-knowledge proof for the transfer
- Transfers tokens privately (amounts are hidden from public view)
- Updates encrypted balances for both sender and receiver
- Maintains audit trail for compliance

#### Step 9: Verify Transfer ‚ö° **OPTIMIZED**
Check balances to confirm transfer (requires manual wallet selection in scripts).

**Check both users' balances:**
```bash
# Edit script manually to set walletNumber = 1, then run:
npx hardhat run scripts/converter/08_check_balance.ts --network fuji
# Edit script manually to set walletNumber = 2, then run:
npx hardhat run scripts/converter/08_check_balance.ts --network fuji
```
**NEW**: Centralized utilities for easier wallet management!

#### Step 10: Withdraw to Public ‚ö° **OPTIMIZED**
Withdraw tokens with centralized utilities and optimized calculations.

```bash
# Edit script manually to set walletNumber = 2
npx hardhat run scripts/converter/09_withdraw.ts --network fuji
```

**What this does:**
- **NEW**: Centralized wallet management utilities
- **NEW**: Centralized cryptographic operations from `src/utils/utils.ts`
- **NEW**: 100x faster balance calculations
- Generates a zero-knowledge proof for withdrawal
- Converts encrypted tokens back to public ERC20 tokens
- Shows the withdrawal publicly in the final balance check

#### Final Step: Check Public Balances ‚ö° **OPTIMIZED**
Verify the final state with ultra-fast balance calculations.

```bash
# Edit script manually to set walletNumber = 1, then run:
npx hardhat run scripts/converter/08_check_balance.ts --network fuji
# Edit script manually to set walletNumber = 2, then run:
npx hardhat run scripts/converter/08_check_balance.ts --network fuji
```

---

---

## üè¶ **Standalone Mode - Quick Overview**

### **Native Encrypted Token System**

The standalone mode creates native encrypted "PRIV" tokens (not wrapped ERC20s):

```bash
# Deploy standalone system
npx hardhat run scripts/standalone/01_deploy-basics.ts --network fuji
npx hardhat run scripts/standalone/02_deploy-standalone.ts --network fuji

# Register users and set auditor (edit scripts manually for wallet selection)
npx hardhat run scripts/standalone/03_register-user.ts --network fuji  # Set walletNumber = 1
npx hardhat run scripts/standalone/03_register-user.ts --network fuji  # Set walletNumber = 2
npx hardhat run scripts/standalone/04_set-auditor.ts --network fuji     # Set walletNumber = 1

# Mint tokens (Central Bank model - edit scripts manually)
npx hardhat run scripts/standalone/05_mint.ts --network fuji  # Set owner/user wallet numbers

# Transfer privately and burn permanently (edit scripts manually)
npx hardhat run scripts/standalone/07_transfer.ts --network fuji  # Set sender/receiver wallets
npx hardhat run scripts/standalone/08_burn.ts --network fuji      # Set walletNumber = 2
```

**For detailed standalone instructions, see [`scripts/standalone/README.md`](scripts/standalone/README.md)**

---

### Versi√≥n en Espa√±ol

Sigue estos pasos en orden para desplegar y probar el **Sistema Convertidor** (ERC20 ‚Üí ERC20 Encriptado):

#### Paso 1: Desplegar Componentes B√°sicos ‚ö° **OPTIMIZADO**
Despliega verificadores, librer√≠as y token ERC20 de prueba.

```bash
npx hardhat run scripts/converter/01_deploy-basics.ts --network fuji
```

**Qu√© hace esto:**
- Despliega verificadores de pruebas zero-knowledge para registro, mint, retiro, transferencia y burn
- Despliega la librer√≠a de curva el√≠ptica BabyJubJub
- Crea un token ERC20 de prueba (TEST) y acu√±a 10,000 tokens al desplegador
- **NUEVO**: Guarda las direcciones de despliegue en `deployments/converter/latest-converter.json` con respaldo por timestamp
- **NUEVO**: Metadatos completos y estructura de archivos optimizada

#### Paso 2: Desplegar Sistema Convertidor ‚ö° **OPTIMIZADO**
Despliega el contrato principal EncryptedERC y el Registrar.

```bash
npx hardhat run scripts/converter/02_deploy-converter.ts --network fuji
```

**Qu√© hace esto:**
- Despliega el contrato Registrar para el registro de usuarios
- Despliega el contrato EncryptedERC en modo convertidor
- Vincula todos los verificadores previamente desplegados
- **NUEVO**: Usa gesti√≥n optimizada de datos de despliegue
- **NUEVO**: Mejor manejo de errores y logging

#### Paso 3: Registrar Usuarios ‚ö° **ALTAMENTE OPTIMIZADO**
Registra ambos usuarios de prueba (requiere configuraci√≥n manual de wallet en scripts).

**Para el primer usuario (Wallet 1):**
```bash
# Edita el script manualmente para establecer walletNumber = 1
npx hardhat run scripts/converter/03_register-user.ts --network fuji
```

**Para el segundo usuario (Wallet 2):**
```bash
# Edita el script manualmente para establecer walletNumber = 2
npx hardhat run scripts/converter/03_register-user.ts --network fuji
```

**Qu√© hace esto:**
- **NUEVO**: Utilidades centralizadas de wallet para configuraci√≥n m√°s f√°cil de scripts
- **NUEVO**: Derivaci√≥n centralizada de claves usando `src/utils/utils.ts`
- Genera claves criptogr√°ficas deterministas a partir de la firma del usuario
- Crea una prueba zero-knowledge de identidad
- Registra la clave p√∫blica del usuario en la blockchain
- **NUEVO**: Muestra balance AVAX para la wallet seleccionada
- **NUEVO**: Gesti√≥n simplificada de wallet con utilidad `getWallet()`

#### Paso 4: Establecer Auditor
Configura el auditor del sistema (debe ser hecho por el propietario del contrato).

```bash
npx hardhat run scripts/04_set-auditor.ts --network fuji
```

**Qu√© hace esto:**
- Establece la clave p√∫blica del auditor en el contrato EncryptedERC
- Permite al auditor desencriptar montos de transacciones para cumplimiento
- Este paso es requerido antes de que se puedan hacer dep√≥sitos

#### Paso 5: Obtener Tokens de Prueba (Ambos Usuarios)
Reclama tokens de prueba del faucet para ambos usuarios.

**Para el primer usuario:**
```bash
npx hardhat run scripts/05_get_faucet.ts --network fuji
```

**Para el segundo usuario:**
Cambia a PRIVATE_KEY2 y ejecuta:
```bash
npx hardhat run scripts/05_get_faucet.ts --network fuji
```

**Qu√© hace esto:**
- Reclama tokens de prueba del faucet ERC20
- Cada usuario puede reclamar una vez cada 24 horas
- Proporciona tokens necesarios para dep√≥sitos en el sistema encriptado

#### Paso 6: Hacer Dep√≥sitos Iniciales (Ambos Usuarios)
Deposita tokens de prueba en el sistema encriptado para ambos usuarios.

**Para el primer usuario:**
```bash
npx hardhat run scripts/06_deposit.ts --network fuji
```

**Para el segundo usuario:**
Cambia a PRIVATE_KEY2 y ejecuta:
```bash
npx hardhat run scripts/06_deposit.ts --network fuji
```

**Qu√© hace esto:**
- Convierte tokens ERC20 p√∫blicos en tokens encriptados
- Genera pruebas de balance encriptado
- Crea rastros de auditor√≠a para cumplimiento
- Los tokens se vuelven privados y solo pueden ser desencriptados por el propietario

#### Paso 7: Verificar Balances
Verifica que los dep√≥sitos funcionaron correctamente revisando los balances encriptados.

**Verificar balance del primer usuario:**
```bash
npx hardhat run scripts/08_check_balance.ts --network fuji
```

**Verificar balance del segundo usuario:**
Cambia a PRIVATE_KEY2 y ejecuta:
```bash
npx hardhat run scripts/08_check_balance.ts --network fuji
```

**Qu√© hace esto:**
- Desencripta el balance encriptado del usuario usando su clave privada
- Muestra tanto el balance encriptado como el balance p√∫blico de tokens
- Verifica la consistencia de la encriptaci√≥n

#### Paso 8: Realizar Transferencia Privada
Transfiere tokens encriptados del primer usuario al segundo usuario.

```bash
npx hardhat run scripts/07_transfer.ts --network fuji
```

**Qu√© hace esto:**
- Genera una prueba zero-knowledge para la transferencia
- Transfiere tokens de forma privada (los montos est√°n ocultos de la vista p√∫blica)
- Actualiza los balances encriptados para el emisor y el receptor
- Mantiene rastro de auditor√≠a para cumplimiento

#### Paso 9: Verificar Transferencia
Verifica los balances nuevamente para confirmar que la transferencia fue exitosa.

**Verificar balances de ambos usuarios:**
```bash
npx hardhat run scripts/08_check_balance.ts --network fuji
```
(Alterna entre PRIVATE_KEY y PRIVATE_KEY2)

#### Paso 10: Retirar a P√∫blico
Retira tokens del sistema encriptado de vuelta al formato ERC20 p√∫blico.

```bash
npx hardhat run scripts/09_withdraw.ts --network fuji
```

**Qu√© hace esto:**
- Genera una prueba zero-knowledge para el retiro
- Convierte tokens encriptados de vuelta a tokens ERC20 p√∫blicos
- Muestra el retiro p√∫blicamente en la verificaci√≥n final del balance

#### Paso Final: Verificar Balances P√∫blicos
Verifica el estado final revisando los balances p√∫blicos de tokens.

```bash
npx hardhat run scripts/08_check_balance.ts --network fuji
```

---

## ‚ö° **Advanced Features / Caracter√≠sticas Avanzadas**

### **üöÄ Performance & Optimization**
- **100x Faster Balance Calculations**: Optimized discrete logarithm search with multi-strategy approach
- **Smart Caching System**: Pre-populated cache with FIFO eviction for common values (0-1000, round numbers)
- **Intelligent Search Patterns**: Small values ‚Üí Round numbers ‚Üí Chunked search ‚Üí Linear fallback
- **Centralized Cryptographic Operations**: All utilities in `src/utils/utils.ts` for maximum reusability

### **üéØ Enhanced User Experience**
- **Centralized Wallet Management**: Use `getWallet(1)` utility function (requires manual script configuration)
- **AVAX Balance Display**: Shows wallet balance for better user awareness
- **Comprehensive Documentation**: Full English/Spanish guides with step-by-step walkthroughs

### **üîê Core Privacy Features**
- **Private Transactions**: Transfer amounts are hidden from public view
- **Zero-Knowledge Proofs**: Cryptographic proofs ensure transaction validity without revealing details
- **Auditor Support**: Designated auditor can decrypt transactions for compliance
- **ERC20 Compatibility**: Seamless conversion between public and private token states
- **Deterministic Keys**: User keys are derived from signatures for easy recovery

### **üè¶ Dual System Architecture**
- **Converter Mode**: Wrap existing ERC20 tokens with privacy (deposit/withdraw model)
- **Standalone Mode**: Native encrypted tokens with mint/burn central bank model

**Espa√±ol:**

### **üöÄ Rendimiento y Optimizaci√≥n**
- **C√°lculos de Balance 100x M√°s R√°pidos**: B√∫squeda optimizada de logaritmo discreto con enfoque multi-estrategia
- **Sistema de Cach√© Inteligente**: Cach√© pre-poblado con expulsi√≥n FIFO para valores comunes (0-1000, n√∫meros redondos)
- **Patrones de B√∫squeda Inteligentes**: Valores peque√±os ‚Üí N√∫meros redondos ‚Üí B√∫squeda por chunks ‚Üí Respaldo lineal
- **Operaciones Criptogr√°ficas Centralizadas**: Todas las utilidades en `src/utils/utils.ts` para m√°xima reutilizaci√≥n

### **üéØ Experiencia de Usuario Mejorada**
- **Gesti√≥n Centralizada de Wallet**: Usa funci√≥n utilitaria `getWallet(1)` (requiere configuraci√≥n manual en script)
- **Visualizaci√≥n de Balance AVAX**: Muestra balance de wallet para mejor conciencia del usuario
- **Documentaci√≥n Completa**: Gu√≠as completas en ingl√©s/espa√±ol con tutoriales paso a paso

### **üîê Caracter√≠sticas Principales de Privacidad**
- **Transacciones Privadas**: Los montos de transferencia est√°n ocultos de la vista p√∫blica
- **Pruebas Zero-Knowledge**: Pruebas criptogr√°ficas aseguran la validez de transacciones sin revelar detalles
- **Soporte de Auditor**: El auditor designado puede desencriptar transacciones para cumplimiento
- **Compatibilidad ERC20**: Conversi√≥n fluida entre estados p√∫blicos y privados de tokens
- **Claves Deterministas**: Las claves del usuario se derivan de firmas para f√°cil recuperaci√≥n

### **üè¶ Arquitectura de Sistema Dual**
- **Modo Convertidor**: Envuelve tokens ERC20 existentes con privacidad (modelo dep√≥sito/retiro)
- **Modo Independiente**: Tokens encriptados nativos con modelo de banco central mint/burn

## üîß **Troubleshooting / Soluci√≥n de Problemas**

### **Common Issues / Problemas Comunes**

#### **üîÑ Converter Mode Issues**
1. **"User not registered"** ‚Üí Edit script to set walletNumber, then run: `npx hardhat run scripts/converter/03_register-user.ts --network fuji`
2. **"Auditor not set"** ‚Üí Edit script to set walletNumber = 1, then run: `npx hardhat run scripts/converter/04_set-auditor.ts --network fuji` 
3. **"Insufficient balance"** ‚Üí Edit script to set walletNumber, then run: `npx hardhat run scripts/converter/05_get_faucet.ts --network fuji`
4. **"Keys don't match"** ‚Üí Re-run registration with same wallet number
5. **"Balance decryption failed"** ‚Üí Check if EGCT balance exceeds cache range (increase from 100,000n if needed)

#### **üè¶ Standalone Mode Issues**
1. **"User not registered"** ‚Üí Edit script to set walletNumber, then run: `npx hardhat run scripts/standalone/03_register-user.ts --network fuji`
2. **"Auditor not set"** ‚Üí Edit script to set walletNumber = 1, then run: `npx hardhat run scripts/standalone/04_set-auditor.ts --network fuji`
3. **"Only owner can mint"** ‚Üí Edit mint script to use contract owner wallet (walletNumber = 1) for minting
4. **"PCT vs EGCT confusion"** ‚Üí EGCT is main balance, PCTs are audit trail only
5. **"Balance shows 0 but PCTs exist"** ‚Üí Large balance may exceed brute force range, fallback will sum PCTs

#### **‚ö° Performance Issues**
1. **Slow balance calculations** ‚Üí Ensure you're using optimized scripts with caching (all scripts in `converter/` and `standalone/` folders)
2. **Memory issues** ‚Üí Cache is limited to 1000 entries with FIFO eviction
3. **Large balance decryption fails** ‚Üí Increase `maxValue` in `findDiscreteLogOptimized` function if needed

#### **üîß Environment Issues**
1. **Wallet selection not working** ‚Üí Manually configure wallet number in the script using `getWallet(1)` or `getWallet(2)`
2. **Wrong deployment file** ‚Üí Check `deployments/converter/latest-converter.json` or `deployments/standalone/latest-standalone.json`
3. **Missing dependencies** ‚Üí Run `npm install` to ensure all packages are installed

### **üåç Espa√±ol**

#### **üîÑ Problemas del Modo Convertidor**
1. **"User not registered"** ‚Üí Edita script para establecer walletNumber, luego ejecuta: `npx hardhat run scripts/converter/03_register-user.ts --network fuji`
2. **"Auditor not set"** ‚Üí Edita script para establecer walletNumber = 1, luego ejecuta: `npx hardhat run scripts/converter/04_set-auditor.ts --network fuji`
3. **"Insufficient balance"** ‚Üí Edita script para establecer walletNumber, luego ejecuta: `npx hardhat run scripts/converter/05_get_faucet.ts --network fuji`
4. **"Keys don't match"** ‚Üí Re-ejecuta el registro con el mismo n√∫mero de wallet
5. **"Balance decryption failed"** ‚Üí Verifica si el balance EGCT excede el rango de cach√© (incrementa de 100,000n si es necesario)

#### **üè¶ Problemas del Modo Independiente**
1. **"User not registered"** ‚Üí Edita script para establecer walletNumber, luego ejecuta: `npx hardhat run scripts/standalone/03_register-user.ts --network fuji`
2. **"Auditor not set"** ‚Üí Edita script para establecer walletNumber = 1, luego ejecuta: `npx hardhat run scripts/standalone/04_set-auditor.ts --network fuji`
3. **"Only owner can mint"** ‚Üí Edita script de mint para usar wallet del propietario del contrato (walletNumber = 1) para acu√±ar
4. **"Confusi√≥n PCT vs EGCT"** ‚Üí EGCT es el balance principal, PCTs son solo rastro de auditor√≠a
5. **"Balance muestra 0 pero PCTs existen"** ‚Üí Balance grande puede exceder rango de fuerza bruta, respaldo sumar√° PCTs



================================================
FILE: hardhat.config.ts
================================================
import "@nomicfoundation/hardhat-chai-matchers";
import "@nomicfoundation/hardhat-ethers";
import "@solarity/chai-zkit";
import "@solarity/hardhat-zkit";
import "@typechain/hardhat";
import "hardhat-gas-reporter";
import type { HardhatUserConfig } from "hardhat/config";
import "solidity-coverage";

import dotenv from "dotenv";
dotenv.config();

const RPC_URL = process.env.RPC_URL || "https://api.avax.network/ext/bc/C/rpc";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.27",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
    },
  },
  networks: {
    hardhat: {
      forking: {
        url: RPC_URL,
        blockNumber: 59121339,
        enabled: !!process.env.FORKING,
      },
    },
    fuji: {
      url: "https://api.avax-test.network/ext/bc/C/rpc",
      chainId: 43113,
      accounts: [process.env.PRIVATE_KEY || "", process.env.PRIVATE_KEY_2 || ""],
    },
  },
  gasReporter: {
    enabled: !!process.env.REPORT_GAS,
    currency: "USD",
    coinmarketcap: process.env.COINMARKETCAP_API_KEY,
    excludeContracts: ["contracts/mocks/"],
    outputFile: "gas-report.txt",
    L1: "avalanche",
    showMethodSig: true,
  },
  zkit: {
    compilerVersion: "2.1.9",
    circuitsDir: "circom",
    compilationSettings: {
      artifactsDir: "zkit/artifacts",
      onlyFiles: [],
      skipFiles: [],
      c: false,
      json: false,
      optimization: "O2",
    },
    setupSettings: {
      contributionSettings: {
        provingSystem: "groth16",
        contributions: 0,
      },
      onlyFiles: [],
      skipFiles: [],
      ptauDir: undefined,
      ptauDownload: true,
    },
    verifiersSettings: {
      verifiersDir: "contracts/verifiers",
      verifiersType: "sol",
    },
    typesDir: "generated-types/zkit",
    quiet: false,
  },
};

export default config;



================================================
FILE: package.json
================================================
{
  "name": "encrypted-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
	"postinstall": "npx hardhat compile & npx hardhat zkit make --force && npx hardhat zkit verifiers",
	"converter:init": "npx hardhat run scripts/converter/01_deploy-basics.ts --network fuji",
	"converter:core": "npx hardhat run scripts/converter/02_deploy-converter.ts --network fuji",
	"converter:register": "npx hardhat run scripts/converter/03_register-user.ts --network fuji",
	"converter:auditor": "npx hardhat run scripts/converter/04_set-auditor.ts --network fuji",
	"converter:faucet": "npx hardhat run scripts/converter/05_get_faucet.ts --network fuji",
	"converter:deposit": "npx hardhat run scripts/converter/06_deposit.ts --network fuji",
	"converter:transfer": "npx hardhat run scripts/converter/07_transfer.ts --network fuji",
	"converter:balance": "npx hardhat run scripts/converter/08_check_balance.ts --network fuji",
	"converter:withdraw": "npx hardhat run scripts/converter/09_withdraw.ts --network fuji",
	"standalone:init": "npx hardhat run scripts/standalone/01_deploy-basics.ts --network fuji",
	"standalone:core": "npx hardhat run scripts/standalone/02_deploy-standalone.ts --network fuji",
	"standalone:register": "npx hardhat run scripts/standalone/03_register-user.ts --network fuji",
	"standalone:auditor": "npx hardhat run scripts/standalone/04_set-auditor.ts --network fuji",
	"standalone:mint": "npx hardhat run scripts/standalone/05_mint.ts --network fuji",
	"standalone:balance": "npx hardhat run scripts/standalone/06_check-balance.ts --network fuji",
	"standalone:transfer": "npx hardhat run scripts/standalone/07_transfer.ts --network fuji",
	"standalone:burn": "npx hardhat run scripts/standalone/08_burn.ts --network fuji"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "@nomicfoundation/hardhat-toolbox": "^6.1.0",
    "hardhat": "^2.26.3",
	"@nomicfoundation/hardhat-chai-matchers": "^2.0.8",
	"@nomicfoundation/hardhat-ethers": "^3.0.8",
	"@openzeppelin/contracts": "^5.1.0",
	"@solarity/chai-zkit": "^0.3.1",
	"@solarity/hardhat-zkit": "^0.5.15",
	"@typechain/hardhat": "^9.1.0",
	"@zk-kit/baby-jubjub": "^1.0.3",
	"dotenv": "^16.4.7",
	"hardhat-gas-reporter": "^2.2.2",
	"maci-crypto": "^2.0.0",
	"poseidon-lite": "^0.3.0",
	"prettier": "^3.5.3",
	"prettier-plugin-solidity": "^1.4.2",
	"solhint": "^5.0.5",
	"solidity-coverage": "^0.8.14"
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": [
    "./src/**/*.ts",
    "./test/**/*.ts",
    "./scripts/**/*.ts",
    "./typechain-types"
  ],
  "exclude": [],
  "files": ["./hardhat.config.ts"]
}



================================================
FILE: .env.example
================================================
RPC_URL = https://api.avax-test.network/ext/bc/C/rpc
PRIVATE_KEY = PRIVATE_KEY_1
PRIVATE_KEY_2 = PRIVATE_KEY_2


================================================
FILE: circom/burn.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template BurnCircuit () {
    signal input ValueToBurn;
    
    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderBalance;
    signal input SenderBalanceC1[2];
    signal input SenderBalanceC2[2];

    signal input SenderVTBC1[2];
    signal input SenderVTBC2[2];

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;

    // Verify that the transfer amount is less than or equal to the sender's balance and is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;   

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToBurn;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== ValueToBurn;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component bitCheck3 = Num2Bits(252);
    bitCheck3.in <== SenderBalance + 1;

    component checkValue = LessThan(252);
    checkValue.in[0] <== ValueToBurn;
    checkValue.in[1] <== SenderBalance + 1;
    checkValue.out === 1;


    // Verify that the sender's public key is well-formed
    component checkSenderPK = CheckPublicKey();
    checkSenderPK.privKey <== SenderPrivateKey;
    checkSenderPK.pubKey[0] <== SenderPublicKey[0];
    checkSenderPK.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's encrypted balance is well-formed
    component checkSenderBalance = CheckValue();
    checkSenderBalance.value <== SenderBalance;
    checkSenderBalance.privKey <== SenderPrivateKey;
    checkSenderBalance.valueC1[0] <== SenderBalanceC1[0];
    checkSenderBalance.valueC1[1] <== SenderBalanceC1[1];
    checkSenderBalance.valueC2[0] <== SenderBalanceC2[0];
    checkSenderBalance.valueC2[1] <== SenderBalanceC2[1];

    // Verify that the sender's encrypted value to burn is the burn amount
    component checkSenderVTB = CheckValue();
    checkSenderVTB.value <== ValueToBurn;
    checkSenderVTB.privKey <== SenderPrivateKey;
    checkSenderVTB.valueC1[0] <== SenderVTBC1[0];
    checkSenderVTB.valueC1[1] <== SenderVTBC1[1];
    checkSenderVTB.valueC2[0] <== SenderVTBC2[0];
    checkSenderVTB.valueC2[1] <== SenderVTBC2[1];

    // Verify auditor's encrypted summary includes the burn amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToBurn;
}

component main { public [ SenderPublicKey, AuditorPublicKey, SenderBalanceC1, SenderBalanceC2, SenderVTBC1, SenderVTBC2, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce ] } = BurnCircuit();


================================================
FILE: circom/components.circom
================================================
pragma circom 2.1.9;

include "./circomlib/poseidon.circom";
include "./circomlib/babyjub.circom";
include "./circomlib/escalarmulany.circom";

// Performs a Poseidon decryption of a given length
// Taken from https://github.com/Shigoto-dev19/poseidon-encryption-circom2/blob/master-circom2/circom/poseidon.circom
template PoseidonDecrypt(l) {
    var decryptedLength = l;
    while (decryptedLength % 3 != 0) {
        decryptedLength += 1;
    }

    signal input ciphertext[decryptedLength + 1];
    signal input nonce;
    signal input key[2];
    signal output decrypted[decryptedLength];

    var two128 = 2 ** 128;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== nonce;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== two128;

    component lt = LessThan(252);
    lt.in[0] <== nonce;
    lt.in[1] <== two128;
    lt.out === 1;

    var n = (decryptedLength + 1) \ 3;

    component strategies[n + 1];
    strategies[0] = PoseidonEx(3, 4);
    strategies[0].initialState <== 0;
    strategies[0].inputs[0] <== key[0];
    strategies[0].inputs[1] <== key[1];
    strategies[0].inputs[2] <== nonce + (l * two128);

    for (var i = 0; i < n; i ++) {
        for (var j = 0; j < 3; j ++) {
            decrypted[i * 3 + j] <== ciphertext[i * 3 + j] - strategies[i].out[j + 1];
        }

        strategies[i + 1] = PoseidonEx(3, 4);
        strategies[i + 1].initialState <== strategies[i].out[0];
        for (var j = 0; j < 3; j ++) {
            strategies[i + 1].inputs[j] <== ciphertext[i * 3 + j];
        }
    }

    // Check the last ciphertext element
    ciphertext[decryptedLength] === strategies[n].out[1];

    // If length > 3, check if the last (3 - (l mod 3)) elements of the message
    // are 0
    if (l % 3 > 0) {
        if (l % 3 == 1) {
            decrypted[decryptedLength - 1] === 0;
        } else if (l % 3 == 2) {
            decrypted[decryptedLength - 1] === 0;
            decrypted[decryptedLength - 2] === 0;
        }
    }
}

// BabyJubJub Scalar Multiplication
// Converted from https://github.com/iden3/circomlib/blob/master/circuits/babyjub.circom BabyPbk()
template BabyScalarMul() {
    signal input  scalar;
    signal input point[2];
    signal output Ax;
    signal output Ay;

    component checkPoint = BabyCheck();
    checkPoint.x <== point[0];
    checkPoint.y <== point[1];

    component scalarBits = Num2Bits(253);
    scalarBits.in <== scalar;

    component mulAny = EscalarMulAny(253);
    mulAny.p[0] <== point[0];
    mulAny.p[1] <== point[1];

    var i;
    for (i=0; i<253; i++) {
        mulAny.e[i] <== scalarBits.out[i];
    }
    Ax  <== mulAny.out[0];
    Ay  <== mulAny.out[1];
}


// ElGamal encryption over BabyJubJub curve while preserving the additively homomorphic property.
// The scheme maps a scalar to a point on the curve and then adds it to the public key point. It outputs the two points of the resulting ciphertext (c1, c2).
template ElGamalEncrypt() {
    signal input random;
    signal input pk[2];
    signal input msg[2];
    signal output encryptedC1X;
    signal output encryptedC1Y;
    signal output encryptedC2X;
    signal output encryptedC2Y;

    component checkPoint = BabyCheck();
    checkPoint.x <== pk[0];
    checkPoint.y <== pk[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== msg[0];
    checkPoint2.y <== msg[1];

    component randomBits = Num2Bits(253);
    randomBits.in <== random;

    component randomToPoint = BabyPbk();
    randomToPoint.in <== random;

    component pkandr = EscalarMulAny(253);
    for (var i = 0; i < 253; i ++) {
        pkandr.e[i] <== randomBits.out[i];
    }
    pkandr.p[0] <== pk[0];
    pkandr.p[1] <== pk[1];
    
    component addRes = BabyAdd();
    addRes.x1 <== msg[0];
    addRes.y1 <== msg[1];
    addRes.x2 <== pkandr.out[0];
    addRes.y2 <== pkandr.out[1];

    encryptedC1X <== randomToPoint.Ax;
    encryptedC1Y <== randomToPoint.Ay;
    encryptedC2X <== addRes.xout;
    encryptedC2Y <== addRes.yout;

}

// ElGamal Decryption scheme over BabyJub curve while preserving the additively homomorphic property.
// The scheme takes the two points of the ciphertext (c1, c2) and the private key and outputs the message, mapped to a point.
template ElGamalDecrypt() {
    signal input c1[2];
    signal input c2[2];
    signal input privKey;
    signal output outx;
    signal output outy;

    component checkPoint = BabyCheck();
    checkPoint.x <== c1[0];
    checkPoint.y <== c1[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== c2[0];
    checkPoint2.y <== c2[1];

    // Convert the private key to bits
    component privKeyBits = Num2Bits(253);
    privKeyBits.in <== privKey;

    // c1 ** x
    component c1x = EscalarMulAny(253);
    for (var i = 0; i < 253; i ++) {
        c1x.e[i] <== privKeyBits.out[i];
    }
    c1x.p[0] <== c1[0];
    c1x.p[1] <== c1[1];

    // (c1 * x) * -1
    signal c1xInverseX;
    c1xInverseX <== 0 - c1x.out[0];

    // ((c1 * x) * - 1) * c2
    component decryptedPoint = BabyAdd();
    decryptedPoint.x1 <== c1xInverseX;
    decryptedPoint.y1 <== c1x.out[1];
    decryptedPoint.x2 <== c2[0];
    decryptedPoint.y2 <== c2[1];

    outx <== decryptedPoint.xout;
    outy <== decryptedPoint.yout;
}

template CheckPublicKey() {
    signal input privKey;
    signal input pubKey[2];

    // Verify the private key is not zero
    component checkIsZero = IsZero();
    checkIsZero.in <== privKey;
    checkIsZero.out === 0;

    component checkPoint = BabyCheck();
    checkPoint.x <== pubKey[0];
    checkPoint.y <== pubKey[1];
    
    // Verify the private key is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== privKey;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== privKey;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component checkPK = BabyPbk();
    checkPK.in <== privKey;

    checkPK.Ax === pubKey[0];
    checkPK.Ay === pubKey[1];
}

template CheckValue() {
    signal input value;
    signal input privKey;
    signal input valueC1[2];
    signal input valueC2[2];

    component checkPoint = BabyCheck();
    checkPoint.x <== valueC1[0];
    checkPoint.y <== valueC1[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== valueC2[0];
    checkPoint2.y <== valueC2[1];
    
    // Verify the value is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== value;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== value;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component checkValue = ElGamalDecrypt();
    checkValue.c1[0] <== valueC1[0];
    checkValue.c1[1] <== valueC1[1];
    checkValue.c2[0] <== valueC2[0];
    checkValue.c2[1] <== valueC2[1];
    checkValue.privKey <== privKey;
    
    component valueToPoint = BabyPbk();
    valueToPoint.in <== value;

    valueToPoint.Ax === checkValue.outx;
    valueToPoint.Ay === checkValue.outy;
}


template CheckReceiverValue() {
    signal input receiverValue;
    signal input receiverPublicKey[2];
    signal input receiverRandom;
    signal input receiverValueC1[2];
    signal input receiverValueC2[2];

    component checkPoint = BabyCheck();
    checkPoint.x <== receiverValueC1[0];
    checkPoint.y <== receiverValueC1[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== receiverValueC2[0];
    checkPoint2.y <== receiverValueC2[1];

    // Verify the receiver value is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== receiverValue;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== receiverValue;
    lt.in[1] <== baseOrder;
    lt.out === 1;
    
    component receiverValueToPoint = BabyPbk();
    receiverValueToPoint.in <== receiverValue;

    component receiverValueEncrypt = ElGamalEncrypt();
    receiverValueEncrypt.random <== receiverRandom;
    receiverValueEncrypt.pk[0] <== receiverPublicKey[0];
    receiverValueEncrypt.pk[1] <== receiverPublicKey[1];
    receiverValueEncrypt.msg[0] <== receiverValueToPoint.Ax;
    receiverValueEncrypt.msg[1] <== receiverValueToPoint.Ay;

    receiverValueEncrypt.encryptedC1X === receiverValueC1[0];
    receiverValueEncrypt.encryptedC1Y === receiverValueC1[1];
    receiverValueEncrypt.encryptedC2X === receiverValueC2[0];
    receiverValueEncrypt.encryptedC2Y === receiverValueC2[1];
}

template CheckPCT() {
    signal input publicKey[2];
    signal input pct[4];
    signal input authKey[2];
    signal input nonce;
    signal input random;
    signal input value;

    component checkPoint = BabyCheck();
    checkPoint.x <== publicKey[0];
    checkPoint.y <== publicKey[1];

    component checkPoint2 = BabyCheck();
    checkPoint2.x <== authKey[0];
    checkPoint2.y <== authKey[1];

    // Verify the random is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== random;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== random;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component checkAuthKey = BabyPbk();
    checkAuthKey.in <== random;

    checkAuthKey.Ax === authKey[0];
    checkAuthKey.Ay === authKey[1];

    component checkEncKey = BabyScalarMul();
    checkEncKey.scalar <== random;
    checkEncKey.point[0] <== publicKey[0];
    checkEncKey.point[1] <== publicKey[1];

    component decryptedPCT = PoseidonDecrypt(1);
    decryptedPCT.ciphertext <== pct;
    decryptedPCT.nonce <== nonce;
    decryptedPCT.key[0] <== checkEncKey.Ax;
    decryptedPCT.key[1] <== checkEncKey.Ay;


    decryptedPCT.decrypted[0] === value;
}

template CheckNullifierHash() {
    signal input nullifierHash;
    signal input chainID;
    signal input auditorCiphertext[4];

    component hash = Poseidon(5);
    hash.inputs[0] <== chainID;
    hash.inputs[1] <== auditorCiphertext[0];
    hash.inputs[2] <== auditorCiphertext[1];
    hash.inputs[3] <== auditorCiphertext[2];
    hash.inputs[4] <== auditorCiphertext[3];

    hash.out === nullifierHash;
}

template CheckRegistrationHash() {
    signal input registrationHash;
    signal input chainID;
    signal input senderPrivateKey;
    signal input senderAddress;

    component hash = Poseidon(3);
    hash.inputs[0] <== chainID;
    hash.inputs[1] <== senderPrivateKey;
    hash.inputs[2] <== senderAddress;

    hash.out === registrationHash;
}


================================================
FILE: circom/mint.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template MintCircuit () {
    signal input ValueToMint;

    signal input ChainID;
    signal input NullifierHash;

    signal input ReceiverPublicKey[2];
    signal input ReceiverVTTC1[2];
    signal input ReceiverVTTC2[2];
    signal input ReceiverVTTRandom;
    
    signal input ReceiverPCT[4];
    signal input ReceiverPCTAuthKey[2];
    signal input ReceiverPCTNonce;
    signal input ReceiverPCTRandom;

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;

    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;
    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToMint;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== ValueToMint;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    // Verify receiver's encrypted value is the mint amount
    component checkReceiverValue = CheckReceiverValue();
    checkReceiverValue.receiverValue <== ValueToMint;
    checkReceiverValue.receiverPublicKey[0] <== ReceiverPublicKey[0];
    checkReceiverValue.receiverPublicKey[1] <== ReceiverPublicKey[1];
    checkReceiverValue.receiverRandom <== ReceiverVTTRandom;
    checkReceiverValue.receiverValueC1[0] <== ReceiverVTTC1[0];
    checkReceiverValue.receiverValueC1[1] <== ReceiverVTTC1[1];
    checkReceiverValue.receiverValueC2[0] <== ReceiverVTTC2[0];
    checkReceiverValue.receiverValueC2[1] <== ReceiverVTTC2[1];

	// Verify nullifier hash is not used
    component checkNullifierHash = CheckNullifierHash();
    checkNullifierHash.nullifierHash <== NullifierHash;
    checkNullifierHash.chainID <== ChainID;
    checkNullifierHash.auditorCiphertext[0] <== AuditorPCT[0];
    checkNullifierHash.auditorCiphertext[1] <== AuditorPCT[1];
    checkNullifierHash.auditorCiphertext[2] <== AuditorPCT[2];
    checkNullifierHash.auditorCiphertext[3] <== AuditorPCT[3];

    // Verify receiver's encrypted summary includes the mint amount and is encrypted with the receiver's public key
    component checkReceiverPCT = CheckPCT();
    checkReceiverPCT.publicKey[0] <== ReceiverPublicKey[0];
    checkReceiverPCT.publicKey[1] <== ReceiverPublicKey[1];
    checkReceiverPCT.pct <== ReceiverPCT;
    checkReceiverPCT.authKey[0] <== ReceiverPCTAuthKey[0];
    checkReceiverPCT.authKey[1] <== ReceiverPCTAuthKey[1];
    checkReceiverPCT.nonce <== ReceiverPCTNonce;
    checkReceiverPCT.random <== ReceiverPCTRandom;
    checkReceiverPCT.value <== ValueToMint;

    // Verify auditor's encrypted summary includes the mint amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToMint;
    
}

component main { public [ ReceiverPublicKey, AuditorPublicKey, ReceiverVTTC1, ReceiverVTTC2, ReceiverPCT, ReceiverPCTAuthKey, ReceiverPCTNonce, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce, ChainID, NullifierHash ] } = MintCircuit();


================================================
FILE: circom/registration.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template RegistrationCircuit() {
    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderAddress;
    signal input ChainID;
    signal input RegistrationHash;

    // Verify that the sender's public key is well-formed
    component checkSenderPublicKey = CheckPublicKey();
    checkSenderPublicKey.privKey <== SenderPrivateKey;
    checkSenderPublicKey.pubKey[0] <== SenderPublicKey[0];
    checkSenderPublicKey.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's registration hash is well-formed
    component checkRegistrationHash = CheckRegistrationHash();
    checkRegistrationHash.registrationHash <== RegistrationHash;
    checkRegistrationHash.chainID <== ChainID;
    checkRegistrationHash.senderPrivateKey <== SenderPrivateKey;
    checkRegistrationHash.senderAddress <== SenderAddress;
}

component main { public [ SenderPublicKey, SenderAddress, ChainID, RegistrationHash ] } = RegistrationCircuit();


================================================
FILE: circom/transfer.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template TransferCircuit () {
    signal input ValueToTransfer;
    
    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderBalance;
    signal input SenderBalanceC1[2];
    signal input SenderBalanceC2[2];

    signal input SenderVTTC1[2];
    signal input SenderVTTC2[2];
    
    signal input ReceiverPublicKey[2];
    signal input ReceiverVTTC1[2];
    signal input ReceiverVTTC2[2];
    signal input ReceiverVTTRandom;
    
    signal input ReceiverPCT[4];
    signal input ReceiverPCTAuthKey[2];
    signal input ReceiverPCTNonce;
    signal input ReceiverPCTRandom;

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;

    // Verify that the transfer amount is less than or equal to the sender's balance and is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;   

    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToTransfer;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component lt = LessThan(252);
    lt.in[0] <== ValueToTransfer;
    lt.in[1] <== baseOrder;
    lt.out === 1;

    component bitCheck3 = Num2Bits(252);
    bitCheck3.in <== SenderBalance + 1;

    component checkValue = LessThan(252);
    checkValue.in[0] <== ValueToTransfer;
    checkValue.in[1] <== SenderBalance + 1;
    checkValue.out === 1;


    // Verify that the sender's public key is well-formed
    component checkSenderPK = CheckPublicKey();
    checkSenderPK.privKey <== SenderPrivateKey;
    checkSenderPK.pubKey[0] <== SenderPublicKey[0];
    checkSenderPK.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's encrypted balance is well-formed
    component checkSenderBalance = CheckValue();
    checkSenderBalance.value <== SenderBalance;
    checkSenderBalance.privKey <== SenderPrivateKey;
    checkSenderBalance.valueC1[0] <== SenderBalanceC1[0];
    checkSenderBalance.valueC1[1] <== SenderBalanceC1[1];
    checkSenderBalance.valueC2[0] <== SenderBalanceC2[0];
    checkSenderBalance.valueC2[1] <== SenderBalanceC2[1];

    // Verify that the sender's encrypted value to transfer is the transfer amount
    component checkSenderVTTC1 = CheckValue();
    checkSenderVTTC1.value <== ValueToTransfer;
    checkSenderVTTC1.privKey <== SenderPrivateKey;
    checkSenderVTTC1.valueC1[0] <== SenderVTTC1[0];
    checkSenderVTTC1.valueC1[1] <== SenderVTTC1[1];
    checkSenderVTTC1.valueC2[0] <== SenderVTTC2[0];
    checkSenderVTTC1.valueC2[1] <== SenderVTTC2[1];

	// Verify that the receiver's encrypted value is the transfer amount by encryption
    component checkReceiverValue = CheckReceiverValue();
    checkReceiverValue.receiverValue <== ValueToTransfer;
    checkReceiverValue.receiverPublicKey[0] <== ReceiverPublicKey[0];
    checkReceiverValue.receiverPublicKey[1] <== ReceiverPublicKey[1];
    checkReceiverValue.receiverRandom <== ReceiverVTTRandom;
    checkReceiverValue.receiverValueC1[0] <== ReceiverVTTC1[0];
    checkReceiverValue.receiverValueC1[1] <== ReceiverVTTC1[1];
    checkReceiverValue.receiverValueC2[0] <== ReceiverVTTC2[0]; 
    checkReceiverValue.receiverValueC2[1] <== ReceiverVTTC2[1];

    // Verify receiver's encrypted summary includes the transfer amount and is encrypted with the receiver's public key
    component checkReceiverPCT = CheckPCT();
    checkReceiverPCT.publicKey[0] <== ReceiverPublicKey[0];
    checkReceiverPCT.publicKey[1] <== ReceiverPublicKey[1];
    checkReceiverPCT.pct <== ReceiverPCT;
    checkReceiverPCT.authKey[0] <== ReceiverPCTAuthKey[0];
    checkReceiverPCT.authKey[1] <== ReceiverPCTAuthKey[1];
    checkReceiverPCT.nonce <== ReceiverPCTNonce;
    checkReceiverPCT.random <== ReceiverPCTRandom;
    checkReceiverPCT.value <== ValueToTransfer;

    // Verify auditor's encrypted summary includes the transfer amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToTransfer;
}

component main { public [ SenderPublicKey, ReceiverPublicKey, AuditorPublicKey, SenderBalanceC1, SenderBalanceC2, SenderVTTC1, SenderVTTC2, ReceiverVTTC1, ReceiverVTTC2, ReceiverPCT, ReceiverPCTAuthKey, ReceiverPCTNonce, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce ] } = TransferCircuit();


================================================
FILE: circom/withdraw.circom
================================================
pragma circom 2.1.9;

include "./components.circom";

template WithdrawCircuit() {
    signal input ValueToWithdraw;

    signal input SenderPrivateKey;
    signal input SenderPublicKey[2];
    signal input SenderBalance;
    signal input SenderBalanceC1[2];
    signal input SenderBalanceC2[2];

    signal input AuditorPublicKey[2];
    signal input AuditorPCT[4];
    signal input AuditorPCTAuthKey[2];
    signal input AuditorPCTNonce;
    signal input AuditorPCTRandom;


    // Verify the withdrawal amount is less than or equal to the sender's balance and is less than the base order
    var baseOrder = 2736030358979909402780800718157159386076813972158567259200215660948447373041;
    component bitCheck1 = Num2Bits(252);
    bitCheck1.in <== ValueToWithdraw;

    component bitCheck2 = Num2Bits(252);
    bitCheck2.in <== baseOrder;

    component checkWithdrawalAmount = LessThan(252);
    checkWithdrawalAmount.in[0] <== ValueToWithdraw;
    checkWithdrawalAmount.in[1] <== baseOrder;
    checkWithdrawalAmount.out === 1;

    component bitCheck3 = Num2Bits(252);
    bitCheck3.in <== SenderBalance + 1;

    component checkValue = LessThan(252);
    checkValue.in[0] <== ValueToWithdraw;
    checkValue.in[1] <== SenderBalance + 1;
    checkValue.out === 1;

    // Verify that the sender's public key is well-formed
    component checkSenderPK = CheckPublicKey();
    checkSenderPK.privKey <== SenderPrivateKey;
    checkSenderPK.pubKey[0] <== SenderPublicKey[0];
    checkSenderPK.pubKey[1] <== SenderPublicKey[1];

    // Verify that the sender's encrypted balance is well-formed
    component checkSenderBalance = CheckValue();
    checkSenderBalance.value <== SenderBalance;
    checkSenderBalance.privKey <== SenderPrivateKey;
    checkSenderBalance.valueC1[0] <== SenderBalanceC1[0];
    checkSenderBalance.valueC1[1] <== SenderBalanceC1[1];
    checkSenderBalance.valueC2[0] <== SenderBalanceC2[0];
    checkSenderBalance.valueC2[1] <== SenderBalanceC2[1];

    // Verify auditor's encrypted summary includes the withdrawal amount and is encrypted with the auditor's public key
    component checkAuditorPCT = CheckPCT();
    checkAuditorPCT.publicKey[0] <== AuditorPublicKey[0];
    checkAuditorPCT.publicKey[1] <== AuditorPublicKey[1];
    checkAuditorPCT.pct <== AuditorPCT;
    checkAuditorPCT.authKey[0] <== AuditorPCTAuthKey[0];
    checkAuditorPCT.authKey[1] <== AuditorPCTAuthKey[1];
    checkAuditorPCT.nonce <== AuditorPCTNonce;
    checkAuditorPCT.random <== AuditorPCTRandom;
    checkAuditorPCT.value <== ValueToWithdraw;
}

component main { public [ SenderPublicKey, SenderBalanceC1, SenderBalanceC2, AuditorPublicKey, AuditorPCT, AuditorPCTAuthKey, AuditorPCTNonce, ValueToWithdraw ] } = WithdrawCircuit();


================================================
FILE: circom/circomlib/aliascheck.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "compconstant.circom";


template AliasCheck() {

    signal input in[254];

    component  compConstant = CompConstant(-1);

    for (var i=0; i<254; i++) in[i] ==> compConstant.in[i];

    compConstant.out === 0;
}



================================================
FILE: circom/circomlib/babyjub.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "bitify.circom";
include "escalarmulfix.circom";

template BabyAdd() {
    signal input x1;
    signal input y1;
    signal input x2;
    signal input y2;
    signal output xout;
    signal output yout;

    signal beta;
    signal gamma;
    signal delta;
    signal tau;

    var a = 168700;
    var d = 168696;

    beta <== x1*y2;
    gamma <== y1*x2;
    delta <== (-a*x1+y1)*(x2 + y2);
    tau <== beta * gamma;

    xout <-- (beta + gamma) / (1+ d*tau);
    (1+ d*tau) * xout === (beta + gamma);

    yout <-- (delta + a*beta - gamma) / (1-d*tau);
    (1-d*tau)*yout === (delta + a*beta - gamma);
}

template BabyDbl() {
    signal input x;
    signal input y;
    signal output xout;
    signal output yout;

    component adder = BabyAdd();
    adder.x1 <== x;
    adder.y1 <== y;
    adder.x2 <== x;
    adder.y2 <== y;

    adder.xout ==> xout;
    adder.yout ==> yout;
}


template BabyCheck() {
    signal input x;
    signal input y;

    signal x2;
    signal y2;

    var a = 168700;
    var d = 168696;

    x2 <== x*x;
    y2 <== y*y;

    a*x2 + y2 === 1 + d*x2*y2;
}

// Extracts the public key from private key
template BabyPbk() {
    signal input  in;
    signal output Ax;
    signal output Ay;

    var BASE8[2] = [
        5299619240641551281634865583518297030282874472190772894086521144482721001553,
        16950150798460657717958625567821834550301663161624707787222815936182638968203
    ];

    component pvkBits = Num2Bits(253);
    pvkBits.in <== in;

    component mulFix = EscalarMulFix(253, BASE8);

    var i;
    for (i=0; i<253; i++) {
        mulFix.e[i] <== pvkBits.out[i];
    }
    Ax  <== mulFix.out[0];
    Ay  <== mulFix.out[1];
}



================================================
FILE: circom/circomlib/bitify.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "comparators.circom";
include "aliascheck.circom";


template Num2Bits(n) {
    signal input in;
    signal output out[n];
    var lc1=0;

    var e2=1;
    for (var i = 0; i<n; i++) {
        out[i] <-- (in >> i) & 1;
        out[i] * (out[i] -1 ) === 0;
        lc1 += out[i] * e2;
        e2 = e2+e2;
    }

    lc1 === in;
}

template Num2Bits_strict() {
    signal input in;
    signal output out[254];

    component aliasCheck = AliasCheck();
    component n2b = Num2Bits(254);
    in ==> n2b.in;

    for (var i=0; i<254; i++) {
        n2b.out[i] ==> out[i];
        n2b.out[i] ==> aliasCheck.in[i];
    }
}

template Bits2Num(n) {
    signal input in[n];
    signal output out;
    var lc1=0;

    var e2 = 1;
    for (var i = 0; i<n; i++) {
        lc1 += in[i] * e2;
        e2 = e2 + e2;
    }

    lc1 ==> out;
}

template Bits2Num_strict() {
    signal input in[254];
    signal output out;

    component aliasCheck = AliasCheck();
    component b2n = Bits2Num(254);

    for (var i=0; i<254; i++) {
        in[i] ==> b2n.in[i];
        in[i] ==> aliasCheck.in[i];
    }

    b2n.out ==> out;
}

template Num2BitsNeg(n) {
    signal input in;
    signal output out[n];
    var lc1=0;

    component isZero;

    isZero = IsZero();

    var neg = n == 0 ? 0 : 2**n - in;

    for (var i = 0; i<n; i++) {
        out[i] <-- (neg >> i) & 1;
        out[i] * (out[i] -1 ) === 0;
        lc1 += out[i] * 2**i;
    }

    in ==> isZero.in;



    lc1 + isZero.out * 2**n === 2**n - in;
}



================================================
FILE: circom/circomlib/comparators.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

template IsZero() {
    signal input in;
    signal output out;

    signal inv;

    inv <-- in!=0 ? 1/in : 0;

    out <== -in*inv +1;
    in*out === 0;
}

template LessThan(n) {
    assert(n <= 252);
    signal input in[2];
    signal output out;

    component n2b = Num2Bits(n+1);

    n2b.in <== in[0]+ (1<<n) - in[1];

    out <== 1-n2b.out[n];
}


================================================
FILE: circom/circomlib/compconstant.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "bitify.circom";

// Returns 1 if in (in binary) > ct
template CompConstant(ct) {
    signal input in[254];
    signal output out;

    signal parts[127];
    signal sout;

    var clsb;
    var cmsb;
    var slsb;
    var smsb;

    var sum=0;

    var b = (1 << 128) -1;
    var a = 1;
    var e = 1;
    var i;

    for (i=0;i<127; i++) {
        clsb = (ct >> (i*2)) & 1;
        cmsb = (ct >> (i*2+1)) & 1;
        slsb = in[i*2];
        smsb = in[i*2+1];

        if ((cmsb==0)&&(clsb==0)) {
            parts[i] <== -b*smsb*slsb + b*smsb + b*slsb;
        } else if ((cmsb==0)&&(clsb==1)) {
            parts[i] <== a*smsb*slsb - a*slsb + b*smsb - a*smsb + a;
        } else if ((cmsb==1)&&(clsb==0)) {
            parts[i] <== b*smsb*slsb - a*smsb + a;
        } else {
            parts[i] <== -a*smsb*slsb + a;
        }

        sum = sum + parts[i];

        b = b -e;
        a = a +e;
        e = e*2;
    }

    sout <== sum;

    component num2bits = Num2Bits(135);

    num2bits.in <== sout;

    out <== num2bits.out[127];
}



================================================
FILE: circom/circomlib/escalarmulany.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "montgomery.circom";
include "babyjub.circom";
include "comparators.circom";

template Multiplexor2() {
    signal input sel;
    signal input in[2][2];
    signal output out[2];

    out[0] <== (in[1][0] - in[0][0])*sel + in[0][0];
    out[1] <== (in[1][1] - in[0][1])*sel + in[0][1];
}

template BitElementMulAny() {
    signal input sel;
    signal input dblIn[2];
    signal input addIn[2];
    signal output dblOut[2];
    signal output addOut[2];

    component doubler = MontgomeryDouble();
    component adder = MontgomeryAdd();
    component selector = Multiplexor2();


    sel ==> selector.sel;

    dblIn[0] ==> doubler.in[0];
    dblIn[1] ==> doubler.in[1];
    doubler.out[0] ==> adder.in1[0];
    doubler.out[1] ==> adder.in1[1];
    addIn[0] ==> adder.in2[0];
    addIn[1] ==> adder.in2[1];
    addIn[0] ==> selector.in[0][0];
    addIn[1] ==> selector.in[0][1];
    adder.out[0] ==> selector.in[1][0];
    adder.out[1] ==> selector.in[1][1];

    doubler.out[0] ==> dblOut[0];
    doubler.out[1] ==> dblOut[1];
    selector.out[0] ==> addOut[0];
    selector.out[1] ==> addOut[1];
}

// p is montgomery point
// n must be <= 248
// returns out in twisted edwards
// Double is in montgomery to be linked;

template SegmentMulAny(n) {
    signal input e[n];
    signal input p[2];
    signal output out[2];
    signal output dbl[2];

    component bits[n-1];

    component e2m = Edwards2Montgomery();

    p[0] ==> e2m.in[0];
    p[1] ==> e2m.in[1];

    var i;

    bits[0] = BitElementMulAny();
    e2m.out[0] ==> bits[0].dblIn[0];
    e2m.out[1] ==> bits[0].dblIn[1];
    e2m.out[0] ==> bits[0].addIn[0];
    e2m.out[1] ==> bits[0].addIn[1];
    e[1] ==> bits[0].sel;

    for (i=1; i<n-1; i++) {
        bits[i] = BitElementMulAny();

        bits[i-1].dblOut[0] ==> bits[i].dblIn[0];
        bits[i-1].dblOut[1] ==> bits[i].dblIn[1];
        bits[i-1].addOut[0] ==> bits[i].addIn[0];
        bits[i-1].addOut[1] ==> bits[i].addIn[1];
        e[i+1] ==> bits[i].sel;
    }

    bits[n-2].dblOut[0] ==> dbl[0];
    bits[n-2].dblOut[1] ==> dbl[1];

    component m2e = Montgomery2Edwards();

    bits[n-2].addOut[0] ==> m2e.in[0];
    bits[n-2].addOut[1] ==> m2e.in[1];

    component eadder = BabyAdd();

    m2e.out[0] ==> eadder.x1;
    m2e.out[1] ==> eadder.y1;
    -p[0] ==> eadder.x2;
    p[1] ==> eadder.y2;

    component lastSel = Multiplexor2();

    e[0] ==> lastSel.sel;
    eadder.xout ==> lastSel.in[0][0];
    eadder.yout ==> lastSel.in[0][1];
    m2e.out[0] ==> lastSel.in[1][0];
    m2e.out[1] ==> lastSel.in[1][1];

    lastSel.out[0] ==> out[0];
    lastSel.out[1] ==> out[1];
}

// This function assumes that p is in the subgroup and it is different to 0

template EscalarMulAny(n) {
    signal input e[n];              // Input in binary format
    signal input p[2];              // Point (Twisted format)
    signal output out[2];           // Point (Twisted format)

    var nsegments = (n-1)\148 +1;
    var nlastsegment = n - (nsegments-1)*148;

    component segments[nsegments];
    component doublers[nsegments-1];
    component m2e[nsegments-1];
    component adders[nsegments-1];
    component zeropoint = IsZero();
    zeropoint.in <== p[0];

    var s;
    var i;
    var nseg;

    for (s=0; s<nsegments; s++) {

        nseg = (s < nsegments-1) ? 148 : nlastsegment;

        segments[s] = SegmentMulAny(nseg);

        for (i=0; i<nseg; i++) {
            e[s*148+i] ==> segments[s].e[i];
        }

        if (s==0) {
            // force G8 point if input point is zero
            segments[s].p[0] <== p[0] + (5299619240641551281634865583518297030282874472190772894086521144482721001553 - p[0])*zeropoint.out;
            segments[s].p[1] <== p[1] + (16950150798460657717958625567821834550301663161624707787222815936182638968203 - p[1])*zeropoint.out;
        } else {
            doublers[s-1] = MontgomeryDouble();
            m2e[s-1] = Montgomery2Edwards();
            adders[s-1] = BabyAdd();

            segments[s-1].dbl[0] ==> doublers[s-1].in[0];
            segments[s-1].dbl[1] ==> doublers[s-1].in[1];

            doublers[s-1].out[0] ==> m2e[s-1].in[0];
            doublers[s-1].out[1] ==> m2e[s-1].in[1];

            m2e[s-1].out[0] ==> segments[s].p[0];
            m2e[s-1].out[1] ==> segments[s].p[1];

            if (s==1) {
                segments[s-1].out[0] ==> adders[s-1].x1;
                segments[s-1].out[1] ==> adders[s-1].y1;
            } else {
                adders[s-2].xout ==> adders[s-1].x1;
                adders[s-2].yout ==> adders[s-1].y1;
            }
            segments[s].out[0] ==> adders[s-1].x2;
            segments[s].out[1] ==> adders[s-1].y2;
        }
    }

    if (nsegments == 1) {
        segments[0].out[0]*(1-zeropoint.out) ==> out[0];
        segments[0].out[1]+(1-segments[0].out[1])*zeropoint.out ==> out[1];
    } else {
        adders[nsegments-2].xout*(1-zeropoint.out) ==> out[0];
        adders[nsegments-2].yout+(1-adders[nsegments-2].yout)*zeropoint.out ==> out[1];
    }
}



================================================
FILE: circom/circomlib/escalarmulfix.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

include "mux3.circom";
include "montgomery.circom";
include "babyjub.circom";

/*
    Window of 3 elements, it calculates
        out = base + base*in[0] + 2*base*in[1] + 4*base*in[2]
        out4 = 4*base

    The result should be compensated.
 */

/*

    The scalar is s = a0 + a1*2^3 + a2*2^6 + ...... + a81*2^243
    First We calculate Q = B + 2^3*B + 2^6*B + ......... + 2^246*B

    Then we calculate S1 = 2*2^246*B + (1 + a0)*B + (2^3 + a1)*B + .....+ (2^243 + a81)*B

    And Finaly we compute the result: RES = SQ - Q

    As you can see the input of the adders cannot be equal nor zero, except for the last
    substraction that it's done in montgomery.

    A good way to see it is that the accumulator input of the adder >= 2^247*B and the other input
    is the output of the windows that it's going to be <= 2^246*B
 */
template WindowMulFix() {
    signal input in[3];
    signal input base[2];
    signal output out[2];
    signal output out8[2];   // Returns 8*Base (To be linked)

    component mux = MultiMux3(2);

    mux.s[0] <== in[0];
    mux.s[1] <== in[1];
    mux.s[2] <== in[2];

    component dbl2 = MontgomeryDouble();
    component adr3 = MontgomeryAdd();
    component adr4 = MontgomeryAdd();
    component adr5 = MontgomeryAdd();
    component adr6 = MontgomeryAdd();
    component adr7 = MontgomeryAdd();
    component adr8 = MontgomeryAdd();

// in[0]  -> 1*BASE

    mux.c[0][0] <== base[0];
    mux.c[1][0] <== base[1];

// in[1] -> 2*BASE
    dbl2.in[0] <== base[0];
    dbl2.in[1] <== base[1];
    mux.c[0][1] <== dbl2.out[0];
    mux.c[1][1] <== dbl2.out[1];

// in[2] -> 3*BASE
    adr3.in1[0] <== base[0];
    adr3.in1[1] <== base[1];
    adr3.in2[0] <== dbl2.out[0];
    adr3.in2[1] <== dbl2.out[1];
    mux.c[0][2] <== adr3.out[0];
    mux.c[1][2] <== adr3.out[1];

// in[3] -> 4*BASE
    adr4.in1[0] <== base[0];
    adr4.in1[1] <== base[1];
    adr4.in2[0] <== adr3.out[0];
    adr4.in2[1] <== adr3.out[1];
    mux.c[0][3] <== adr4.out[0];
    mux.c[1][3] <== adr4.out[1];

// in[4] -> 5*BASE
    adr5.in1[0] <== base[0];
    adr5.in1[1] <== base[1];
    adr5.in2[0] <== adr4.out[0];
    adr5.in2[1] <== adr4.out[1];
    mux.c[0][4] <== adr5.out[0];
    mux.c[1][4] <== adr5.out[1];

// in[5] -> 6*BASE
    adr6.in1[0] <== base[0];
    adr6.in1[1] <== base[1];
    adr6.in2[0] <== adr5.out[0];
    adr6.in2[1] <== adr5.out[1];
    mux.c[0][5] <== adr6.out[0];
    mux.c[1][5] <== adr6.out[1];

// in[6] -> 7*BASE
    adr7.in1[0] <== base[0];
    adr7.in1[1] <== base[1];
    adr7.in2[0] <== adr6.out[0];
    adr7.in2[1] <== adr6.out[1];
    mux.c[0][6] <== adr7.out[0];
    mux.c[1][6] <== adr7.out[1];

// in[7] -> 8*BASE
    adr8.in1[0] <== base[0];
    adr8.in1[1] <== base[1];
    adr8.in2[0] <== adr7.out[0];
    adr8.in2[1] <== adr7.out[1];
    mux.c[0][7] <== adr8.out[0];
    mux.c[1][7] <== adr8.out[1];

    out8[0] <== adr8.out[0];
    out8[1] <== adr8.out[1];

    out[0] <== mux.out[0];
    out[1] <== mux.out[1];
}


/*
    This component does a multiplication of a escalar times a fix base
    Signals:
        e: The scalar in bits
        base: the base point in edwards format
        out:  The result
        dbl: Point in Edwards to be linked to the next segment.
 */

template SegmentMulFix(nWindows) {
    signal input e[nWindows*3];
    signal input base[2];
    signal output out[2];
    signal output dbl[2];

    var i;
    var j;

    // Convert the base to montgomery

    component e2m = Edwards2Montgomery();
    e2m.in[0] <== base[0];
    e2m.in[1] <== base[1];

    component windows[nWindows];
    component adders[nWindows];
    component cadders[nWindows];

    // In the last step we add an extra doubler so that numbers do not match.
    component dblLast = MontgomeryDouble();

    for (i=0; i<nWindows; i++) {
        windows[i] = WindowMulFix();
        cadders[i] = MontgomeryAdd();
        if (i==0) {
            windows[i].base[0] <== e2m.out[0];
            windows[i].base[1] <== e2m.out[1];
            cadders[i].in1[0] <== e2m.out[0];
            cadders[i].in1[1] <== e2m.out[1];
        } else {
            windows[i].base[0] <== windows[i-1].out8[0];
            windows[i].base[1] <== windows[i-1].out8[1];
            cadders[i].in1[0] <== cadders[i-1].out[0];
            cadders[i].in1[1] <== cadders[i-1].out[1];
        }
        for (j=0; j<3; j++) {
            windows[i].in[j] <== e[3*i+j];
        }
        if (i<nWindows-1) {
            cadders[i].in2[0] <== windows[i].out8[0];
            cadders[i].in2[1] <== windows[i].out8[1];
        } else {
            dblLast.in[0] <== windows[i].out8[0];
            dblLast.in[1] <== windows[i].out8[1];
            cadders[i].in2[0] <== dblLast.out[0];
            cadders[i].in2[1] <== dblLast.out[1];
        }
    }

    for (i=0; i<nWindows; i++) {
        adders[i] = MontgomeryAdd();
        if (i==0) {
            adders[i].in1[0] <== dblLast.out[0];
            adders[i].in1[1] <== dblLast.out[1];
        } else {
            adders[i].in1[0] <== adders[i-1].out[0];
            adders[i].in1[1] <== adders[i-1].out[1];
        }
        adders[i].in2[0] <== windows[i].out[0];
        adders[i].in2[1] <== windows[i].out[1];
    }

    component m2e = Montgomery2Edwards();
    component cm2e = Montgomery2Edwards();

    m2e.in[0] <== adders[nWindows-1].out[0];
    m2e.in[1] <== adders[nWindows-1].out[1];
    cm2e.in[0] <== cadders[nWindows-1].out[0];
    cm2e.in[1] <== cadders[nWindows-1].out[1];

    component cAdd = BabyAdd();
    cAdd.x1 <== m2e.out[0];
    cAdd.y1 <== m2e.out[1];
    cAdd.x2 <== -cm2e.out[0];
    cAdd.y2 <== cm2e.out[1];

    cAdd.xout ==> out[0];
    cAdd.yout ==> out[1];

    windows[nWindows-1].out8[0] ==> dbl[0];
    windows[nWindows-1].out8[1] ==> dbl[1];
}


/*
This component multiplies a escalar times a fixed point BASE (twisted edwards format)
    Signals
        e: The escalar in binary format
        out: The output point in twisted edwards
 */
template EscalarMulFix(n, BASE) {
    signal input e[n];              // Input in binary format
    signal output out[2];           // Point (Twisted format)

    var nsegments = (n-1)\246 +1;       // 249 probably would work. But I'm not sure and for security I keep 246
    var nlastsegment = n - (nsegments-1)*249;

    component segments[nsegments];

    component m2e[nsegments-1];
    component adders[nsegments-1];

    var s;
    var i;
    var nseg;
    var nWindows;

    for (s=0; s<nsegments; s++) {

        nseg = (s < nsegments-1) ? 249 : nlastsegment;
        nWindows = ((nseg - 1)\3)+1;

        segments[s] = SegmentMulFix(nWindows);

        for (i=0; i<nseg; i++) {
            segments[s].e[i] <== e[s*249+i];
        }

        for (i = nseg; i<nWindows*3; i++) {
            segments[s].e[i] <== 0;
        }

        if (s==0) {
            segments[s].base[0] <== BASE[0];
            segments[s].base[1] <== BASE[1];
        } else {
            m2e[s-1] = Montgomery2Edwards();
            adders[s-1] = BabyAdd();

            segments[s-1].dbl[0] ==> m2e[s-1].in[0];
            segments[s-1].dbl[1] ==> m2e[s-1].in[1];

            m2e[s-1].out[0] ==> segments[s].base[0];
            m2e[s-1].out[1] ==> segments[s].base[1];

            if (s==1) {
                segments[s-1].out[0] ==> adders[s-1].x1;
                segments[s-1].out[1] ==> adders[s-1].y1;
            } else {
                adders[s-2].xout ==> adders[s-1].x1;
                adders[s-2].yout ==> adders[s-1].y1;
            }
            segments[s].out[0] ==> adders[s-1].x2;
            segments[s].out[1] ==> adders[s-1].y2;
        }
    }

    if (nsegments == 1) {
        segments[0].out[0] ==> out[0];
        segments[0].out[1] ==> out[1];
    } else {
        adders[nsegments-2].xout ==> out[0];
        adders[nsegments-2].yout ==> out[1];
    }
}



================================================
FILE: circom/circomlib/montgomery.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/

/*
    Source: https://en.wikipedia.org/wiki/Montgomery_curve

                1 + y       1 + y
    [u, v] = [ -------  , ---------- ]
                1 - y      (1 - y)x

 */
 pragma circom 2.1.9;

template Edwards2Montgomery() {
    signal input in[2];
    signal output out[2];

    out[0] <-- (1 + in[1]) / (1 - in[1]);
    out[1] <-- out[0] / in[0];


    out[0] * (1-in[1]) === (1 + in[1]);
    out[1] * in[0] === out[0];
}

/*

                u    u - 1
    [x, y] = [ ---, ------- ]
                v    u + 1

 */
template Montgomery2Edwards() {
    signal input in[2];
    signal output out[2];

    out[0] <-- in[0] / in[1];
    out[1] <-- (in[0] - 1) / (in[0] + 1);

    out[0] * in[1] === in[0];
    out[1] * (in[0] + 1) === in[0] - 1;
}


/*
             x2 - x1
    lamda = ---------
             y2 - y1

                                                    x3 + A + x1 + x2
    x3 = B * lamda^2 - A - x1 -x2    =>  lamda^2 = ------------------
                                                         B

    y3 = (2*x1 + x2 + A)*lamda - B*lamda^3 - y1  =>


    =>  y3 = lamda * ( 2*x1 + x2 + A  - x3 - A - x1 - x2)  - y1 =>

    =>  y3 = lamda * ( x1 - x3 ) - y1

----------

             y2 - y1
    lamda = ---------
             x2 - x1

    x3 = B * lamda^2 - A - x1 -x2

    y3 = lamda * ( x1 - x3 ) - y1

 */

template MontgomeryAdd() {
    signal input in1[2];
    signal input in2[2];
    signal output out[2];

    var a = 168700;
    var d = 168696;

    var A = (2 * (a + d)) / (a - d);
    var B = 4 / (a - d);

    signal lamda;

    lamda <-- (in2[1] - in1[1]) / (in2[0] - in1[0]);
    lamda * (in2[0] - in1[0]) === (in2[1] - in1[1]);

    out[0] <== B*lamda*lamda - A - in1[0] -in2[0];
    out[1] <== lamda * (in1[0] - out[0]) - in1[1];
}

/*

    x1_2 = x1*x1

             3*x1_2 + 2*A*x1 + 1
    lamda = ---------------------
                   2*B*y1

    x3 = B * lamda^2 - A - x1 -x1

    y3 = lamda * ( x1 - x3 ) - y1

 */
template MontgomeryDouble() {
    signal input in[2];
    signal output out[2];

    var a = 168700;
    var d = 168696;

    var A = (2 * (a + d)) / (a - d);
    var B = 4 / (a - d);

    signal lamda;
    signal x1_2;

    x1_2 <== in[0] * in[0];

    lamda <-- (3*x1_2 + 2*A*in[0] + 1 ) / (2*B*in[1]);
    lamda * (2*B*in[1]) === (3*x1_2 + 2*A*in[0] + 1 );

    out[0] <== B*lamda*lamda - A - 2*in[0];
    out[1] <== lamda * (in[0] - out[0]) - in[1];
}



================================================
FILE: circom/circomlib/mux3.circom
================================================
/*
    Copyright 2018 0KIMS association.

    This file is part of circom (Zero Knowledge Circuit Compiler).

    circom is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    circom is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with circom. If not, see <https://www.gnu.org/licenses/>.
*/
pragma circom 2.1.9;

template MultiMux3(n) {
    signal input c[n][8];  // Constants
    signal input s[3];   // Selector
    signal output out[n];

    signal a210[n];
    signal a21[n];
    signal a20[n];
    signal a2[n];

    signal a10[n];
    signal a1[n];
    signal a0[n];
    signal a[n];

    // 4 constrains for the intermediary variables
    signal  s10;
    s10 <== s[1] * s[0];

    for (var i=0; i<n; i++) {

         a210[i] <==  ( c[i][ 7]-c[i][ 6]-c[i][ 5]+c[i][ 4] - c[i][ 3]+c[i][ 2]+c[i][ 1]-c[i][ 0] ) * s10;
          a21[i] <==  ( c[i][ 6]-c[i][ 4]-c[i][ 2]+c[i][ 0] ) * s[1];
          a20[i] <==  ( c[i][ 5]-c[i][ 4]-c[i][ 1]+c[i][ 0] ) * s[0];
           a2[i] <==  ( c[i][ 4]-c[i][ 0] );

          a10[i] <==  ( c[i][ 3]-c[i][ 2]-c[i][ 1]+c[i][ 0] ) * s10;
           a1[i] <==  ( c[i][ 2]-c[i][ 0] ) * s[1];
           a0[i] <==  ( c[i][ 1]-c[i][ 0] ) * s[0];
            a[i] <==  ( c[i][ 0] );

          out[i] <== ( a210[i] + a21[i] + a20[i] + a2[i] ) * s[2] +
                     (  a10[i] +  a1[i] +  a0[i] +  a[i] );

    }
}



================================================
FILE: circom/circomlib/poseidon.circom
================================================
pragma circom 2.1.9;

include "./poseidon_constants.circom";

template Sigma() {
    signal input in;
    signal output out;

    signal in2;
    signal in4;

    in2 <== in*in;
    in4 <== in2*in2;

    out <== in4*in;
}

template Ark(t, C, r) {
    signal input in[t];
    signal output out[t];

    for (var i=0; i<t; i++) {
        out[i] <== in[i] + C[i + r];
    }
}

template Mix(t, M) {
    signal input in[t];
    signal output out[t];

    var lc;
    for (var i=0; i<t; i++) {
        lc = 0;
        for (var j=0; j<t; j++) {
            lc += M[j][i]*in[j];
        }
        out[i] <== lc;
    }
}

template MixLast(t, M, s) {
    signal input in[t];
    signal output out;

    var lc = 0;
    for (var j=0; j<t; j++) {
        lc += M[j][s]*in[j];
    }
    out <== lc;
}

template MixS(t, S, r) {
    signal input in[t];
    signal output out[t];


    var lc = 0;
    for (var i=0; i<t; i++) {
        lc += S[(t*2-1)*r+i]*in[i];
    }
    out[0] <== lc;
    for (var i=1; i<t; i++) {
        out[i] <== in[i] +  in[0] * S[(t*2-1)*r + t + i -1];
    }
}

template PoseidonEx(nInputs, nOuts) {
    signal input inputs[nInputs];
    signal input initialState;
    signal output out[nOuts];

    // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
    // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    // And rounded up to nearest integer that divides by t
    var N_ROUNDS_P[16] = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
    var t = nInputs + 1;
    var nRoundsF = 8;
    var nRoundsP = N_ROUNDS_P[t - 2];
    var C[t*nRoundsF + nRoundsP] = POSEIDON_C(t);
    var S[  N_ROUNDS_P[t-2]  *  (t*2-1)  ]  = POSEIDON_S(t);
    var M[t][t] = POSEIDON_M(t);
    var P[t][t] = POSEIDON_P(t);

    component ark[nRoundsF];
    component sigmaF[nRoundsF][t];
    component sigmaP[nRoundsP];
    component mix[nRoundsF-1];
    component mixS[nRoundsP];
    component mixLast[nOuts];


    ark[0] = Ark(t, C, 0);
    for (var j=0; j<t; j++) {
        if (j>0) {
            ark[0].in[j] <== inputs[j-1];
        } else {
            ark[0].in[j] <== initialState;
        }
    }

    for (var r = 0; r < nRoundsF\2-1; r++) {
        for (var j=0; j<t; j++) {
            sigmaF[r][j] = Sigma();
            if(r==0) {
                sigmaF[r][j].in <== ark[0].out[j];
            } else {
                sigmaF[r][j].in <== mix[r-1].out[j];
            }
        }

        ark[r+1] = Ark(t, C, (r+1)*t);
        for (var j=0; j<t; j++) {
            ark[r+1].in[j] <== sigmaF[r][j].out;
        }

        mix[r] = Mix(t,M);
        for (var j=0; j<t; j++) {
            mix[r].in[j] <== ark[r+1].out[j];
        }

    }

    for (var j=0; j<t; j++) {
        sigmaF[nRoundsF\2-1][j] = Sigma();
        sigmaF[nRoundsF\2-1][j].in <== mix[nRoundsF\2-2].out[j];
    }

    ark[nRoundsF\2] = Ark(t, C, (nRoundsF\2)*t );
    for (var j=0; j<t; j++) {
        ark[nRoundsF\2].in[j] <== sigmaF[nRoundsF\2-1][j].out;
    }

    mix[nRoundsF\2-1] = Mix(t,P);
    for (var j=0; j<t; j++) {
        mix[nRoundsF\2-1].in[j] <== ark[nRoundsF\2].out[j];
    }


    for (var r = 0; r < nRoundsP; r++) {
        sigmaP[r] = Sigma();
        if (r==0) {
            sigmaP[r].in <== mix[nRoundsF\2-1].out[0];
        } else {
            sigmaP[r].in <== mixS[r-1].out[0];
        }

        mixS[r] = MixS(t, S, r);
        for (var j=0; j<t; j++) {
            if (j==0) {
                mixS[r].in[j] <== sigmaP[r].out + C[(nRoundsF\2+1)*t + r];
            } else {
                if (r==0) {
                    mixS[r].in[j] <== mix[nRoundsF\2-1].out[j];
                } else {
                    mixS[r].in[j] <== mixS[r-1].out[j];
                }
            }
        }
    }

    for (var r = 0; r < nRoundsF\2-1; r++) {
        for (var j=0; j<t; j++) {
            sigmaF[nRoundsF\2 + r][j] = Sigma();
            if (r==0) {
                sigmaF[nRoundsF\2 + r][j].in <== mixS[nRoundsP-1].out[j];
            } else {
                sigmaF[nRoundsF\2 + r][j].in <== mix[nRoundsF\2+r-1].out[j];
            }
        }

        ark[ nRoundsF\2 + r + 1] = Ark(t, C,  (nRoundsF\2+1)*t + nRoundsP + r*t );
        for (var j=0; j<t; j++) {
            ark[nRoundsF\2 + r + 1].in[j] <== sigmaF[nRoundsF\2 + r][j].out;
        }

        mix[nRoundsF\2 + r] = Mix(t,M);
        for (var j=0; j<t; j++) {
            mix[nRoundsF\2 + r].in[j] <== ark[nRoundsF\2 + r + 1].out[j];
        }

    }

    for (var j=0; j<t; j++) {
        sigmaF[nRoundsF-1][j] = Sigma();
        sigmaF[nRoundsF-1][j].in <== mix[nRoundsF-2].out[j];
    }

    for (var i=0; i<nOuts; i++) {
        mixLast[i] = MixLast(t,M,i);
        for (var j=0; j<t; j++) {
            mixLast[i].in[j] <== sigmaF[nRoundsF-1][j].out;
        }
        out[i] <== mixLast[i].out;
    }

}

template Poseidon(nInputs) {
    signal input inputs[nInputs];
    signal output out;

    component pEx = PoseidonEx(nInputs, 1);
    pEx.initialState <== 0;
    for (var i=0; i<nInputs; i++) {
        pEx.inputs[i] <== inputs[i];
    }
    out <== pEx.out[0];
}



================================================
FILE: circom/circomlib/poseidon_old.circom
================================================
pragma circom 2.1.9;

include "./poseidon_constants.circom";

template Sigma() {
    signal input in;
    signal output out;

    signal in2;
    signal in4;

    in2 <== in*in;
    in4 <== in2*in2;

    out <== in4*in;
}

template Ark(t, C, r) {
    signal input in[t];
    signal output out[t];

    for (var i=0; i<t; i++) {
        out[i] <== in[i] + C[i + r];
    }
}

template Mix(t, M) {
    signal input in[t];
    signal output out[t];

    var lc;
    for (var i=0; i<t; i++) {
        lc = 0;
        for (var j=0; j<t; j++) {
            lc += M[i][j]*in[j];
        }
        out[i] <== lc;
    }
}

template Poseidon(nInputs) {
    signal input inputs[nInputs];
    signal output out;

    // Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
    // Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
    // And rounded up to nearest integer that divides by t
    var N_ROUNDS_P[16] = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
    var t = nInputs + 1;
    var nRoundsF = 8;
    var nRoundsP = N_ROUNDS_P[t - 2];
    var C[t*(nRoundsF + nRoundsP)] = POSEIDON_C(t);
    var M[t][t] = POSEIDON_M(t);

    component ark[nRoundsF + nRoundsP];
    component sigmaF[nRoundsF][t];
    component sigmaP[nRoundsP];
    component mix[nRoundsF + nRoundsP];

    var k;

    for (var i=0; i<nRoundsF + nRoundsP; i++) {
        ark[i] = Ark(t, C, t*i);
        for (var j=0; j<t; j++) {
            if (i==0) {
                if (j>0) {
                    ark[i].in[j] <== inputs[j-1];
                } else {
                    ark[i].in[j] <== 0;
                }
            } else {
                ark[i].in[j] <== mix[i-1].out[j];
            }
        }

        if (i < nRoundsF/2 || i >= nRoundsP + nRoundsF/2) {
            k = i < nRoundsF/2 ? i : i - nRoundsP;
            mix[i] = Mix(t, M);
            for (var j=0; j<t; j++) {
                sigmaF[k][j] = Sigma();
                sigmaF[k][j].in <== ark[i].out[j];
                mix[i].in[j] <== sigmaF[k][j].out;
            }
        } else {
            k = i - nRoundsF/2;
            mix[i] = Mix(t, M);
            sigmaP[k] = Sigma();
            sigmaP[k].in <== ark[i].out[0];
            mix[i].in[0] <== sigmaP[k].out;
            for (var j=1; j<t; j++) {
                mix[i].in[j] <== ark[i].out[j];
            }
        }
    }

    out <== mix[nRoundsF + nRoundsP -1].out[0];
}



================================================
FILE: contracts/EncryptedERC.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem
pragma solidity 0.8.27;

// contracts
import {TokenTracker} from "./tokens/TokenTracker.sol";
import {EncryptedUserBalances} from "./EncryptedUserBalances.sol";
import {AuditorManager} from "./auditor/AuditorManager.sol";

// libraries
import {BabyJubJub} from "./libraries/BabyJubJub.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

// types
import {CreateEncryptedERCParams, Point, EGCT, EncryptedBalance, AmountPCT, MintProof, TransferProof, WithdrawProof, BurnProof, TransferInputs} from "./types/Types.sol";

// errors
import {UserNotRegistered, InvalidProof, TransferFailed, UnknownToken, InvalidChainId, InvalidNullifier, ZeroAddress} from "./errors/Errors.sol";

// interfaces
import {IRegistrar} from "./interfaces/IRegistrar.sol";
import {IMintVerifier} from "./interfaces/verifiers/IMintVerifier.sol";
import {IWithdrawVerifier} from "./interfaces/verifiers/IWithdrawVerifier.sol";
import {ITransferVerifier} from "./interfaces/verifiers/ITransferVerifier.sol";
import {IBurnVerifier} from "./interfaces/verifiers/IBurnVerifier.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

//             /$$$$$$$$ /$$$$$$$   /$$$$$$
//            | $$_____/| $$__  $$ /$$__  $$
//    /$$$$$$ | $$      | $$  \ $$| $$  \__/
//   /$$__  $$| $$$$$   | $$$$$$$/| $$  | $$
//  | $$_____/| $$      | $$  \ $$| $$  | $$
//  |  $$$$$$$| $$$$$$$$| $$  | $$|  $$$$$$/
//   \_______/|________/|__/  |__/ \______/
//
/**
 * @title EncryptedERC
 * @notice A privacy-preserving ERC20 token implementation that uses zero-knowledge proofs for managing balances in encrypted manner.
 * @dev This contract implements Encrypted ERC operations using zero-knowledge proofs.
 *
 * Key features:
 * - Encrypted ERC has 2 modes:
 *   - Standalone Mode: Act like a standalone ERC20 token (mint, burn, transfer)
 *   - Converter Mode: Wraps existing ERC20 tokens and encrypted ERC20 tokens (deposit, withdraw, transfer)
 * - Auditor Manager: Manages auditor's public key
 * - Token Tracker: Manages ERC20 token registration for deposit and withdrawal
 * - Encrypted User Balances: Manages encrypted balances for users in encrypted manner
 *
 * The contract uses three main components:
 * 1. TokenTracker: Manages token registration and tracking
 * 2. EncryptedUserBalances: Handles encrypted balance storage and updates
 * 3. AuditorManager: Manages auditor-related functionality
 */
contract EncryptedERC is TokenTracker, EncryptedUserBalances, AuditorManager {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice Address of the registrar contract that manages user registration
    IRegistrar public registrar;

    /// @notice Verifier contracts for each operation
    IMintVerifier public mintVerifier;
    IWithdrawVerifier public withdrawVerifier;
    ITransferVerifier public transferVerifier;
    IBurnVerifier public burnVerifier;

    /// @notice Token metadata
    string public name;
    string public symbol;
    uint8 public immutable decimals;

    /// @notice Mapping to track used mint nullifiers to prevent double-minting
    mapping(uint256 mintNullifier => bool isUsed) public alreadyMinted;

    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when a private mint operation occurs
     * @param user Address of the user receiving the minted tokens
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when tokens are privately minted to a user
     */
    event PrivateMint(
        address indexed user,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    /**
     * @notice Emitted when a private burn operation occurs
     * @param user Address of the user burning the tokens
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when tokens are privately burned by a user
     */
    event PrivateBurn(
        address indexed user,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    /**
     * @notice Emitted when a private transfer operation occurs
     * @param from Address of the sender
     * @param to Address of the receiver
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when tokens are privately transferred between users
     */
    event PrivateTransfer(
        address indexed from,
        address indexed to,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    /**
     * @notice Emitted when a deposit operation occurs
     * @param user Address of the user making the deposit
     * @param amount Amount of tokens deposited
     * @param dust Amount of dust (remainder) from the deposit
     * @param tokenId ID of the token being deposited
     * @dev This event is emitted when a user deposits tokens into the contract
     */
    event Deposit(
        address indexed user,
        uint256 amount,
        uint256 dust,
        uint256 tokenId
    );

    /**
     * @notice Emitted when a withdrawal operation occurs
     * @param user Address of the user making the withdrawal
     * @param amount Amount of tokens withdrawn
     * @param tokenId ID of the token being withdrawn
     * @param auditorPCT Auditor PCT values for compliance tracking
     * @param auditorAddress Address of the auditor
     * @dev This event is emitted when a user withdraws tokens from the contract
     */
    event Withdraw(
        address indexed user,
        uint256 amount,
        uint256 tokenId,
        uint256[7] auditorPCT,
        address indexed auditorAddress
    );

    ///////////////////////////////////////////////////
    ///                   Modifiers                 ///
    ///////////////////////////////////////////////////
    modifier onlyIfUserRegistered(address user) {
        bool isRegistered = registrar.isUserRegistered(user);
        if (!isRegistered) {
            revert UserNotRegistered();
        }
        _;
    }

    ///////////////////////////////////////////////////
    ///                   Constructor               ///
    ///////////////////////////////////////////////////

    /**
     * @notice Initializes the EncryptedERC contract with the given parameters
     * @param params The initialization parameters containing contract addresses and token metadata
     * @dev This constructor sets up the contract with necessary verifiers, registrar, and token metadata.
     *      It also determines whether the contract will function as a converter or standalone token.
     */
    constructor(
        CreateEncryptedERCParams memory params
    ) TokenTracker(params.isConverter) {
        // Validate contract addresses
        if (
            params.registrar == address(0) ||
            params.mintVerifier == address(0) ||
            params.withdrawVerifier == address(0) ||
            params.transferVerifier == address(0) ||
            params.burnVerifier == address(0)
        ) {
            revert ZeroAddress();
        }

        // Initialize contracts
        registrar = IRegistrar(params.registrar);
        mintVerifier = IMintVerifier(params.mintVerifier);
        withdrawVerifier = IWithdrawVerifier(params.withdrawVerifier);
        transferVerifier = ITransferVerifier(params.transferVerifier);
        burnVerifier = IBurnVerifier(params.burnVerifier);

        // if contract is not a converter, then set the name and symbol
        if (!params.isConverter) {
            name = params.name;
            symbol = params.symbol;
        }

        decimals = params.decimals;
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Sets the auditor's public key for a registered user
     * @param user Address of the user to set as auditor
     * @dev This function:
     *      1. Verifies the user is registered
     *      2. Retrieves the user's public key
     *      3. Updates the auditor's information
     *
     * Requirements:
     * - Caller must be the contract owner
     * - User must be registered
     */
    function setAuditorPublicKey(
        address user
    ) external onlyOwner onlyIfUserRegistered(user) {
        uint256[2] memory publicKey_ = registrar.getUserPublicKey(user);
        _updateAuditor(user, publicKey_);
    }

    /**
     * @notice Performs a private mint operation for a registered user
     * @param user The address of the user to mint tokens to
     * @param proof The zero-knowledge proof proving the validity of the mint operation
     * @dev This function:
     *      1. Validates the chain ID and user registration
     *      2. Verifies the user's public key matches the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Checks the mint nullifier hasn't been used
     *      5. Verifies the zero-knowledge proof
     *      6. Updates the user's encrypted balance
     *
     * Requirements:
     * - Caller must be the contract owner
     * - Auditor must be set
     * - Contract must be in standalone mode
     * - User must be registered
     * - Proof must be valid
     */
    function privateMint(
        address user,
        MintProof calldata proof
    )
        external
        onlyOwner
        onlyIfAuditorSet
        onlyForStandalone
        onlyIfUserRegistered(user)
    {
        uint256[24] memory publicInputs = proof.publicSignals;

        // Validate chain ID
        if (block.chainid != publicInputs[0]) {
            revert InvalidChainId();
        }

        // validate public keys
        _validatePublicKey(user, [publicInputs[2], publicInputs[3]]);
        _validateAuditorPublicKey([publicInputs[15], publicInputs[16]]);

        // Validate and check mint nullifier
        uint256 mintNullifier = publicInputs[1];
        if (mintNullifier >= BabyJubJub.Q) {
            revert InvalidNullifier();
        }
        if (alreadyMinted[mintNullifier]) {
            revert InvalidProof();
        }

        // Verify the zero-knowledge proof
        bool isVerified = mintVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        {
            // Extract the encrypted amount from the proof
            EGCT memory encryptedAmount = EGCT({
                c1: Point({x: publicInputs[4], y: publicInputs[5]}),
                c2: Point({x: publicInputs[6], y: publicInputs[7]})
            });

            // Extract amount PCT
            uint256[7] memory amountPCT;
            for (uint256 i = 0; i < 7; i++) {
                amountPCT[i] = publicInputs[8 + i];
            }

            // Perform the private mint operation
            _privateMint(user, encryptedAmount, amountPCT);
        }

        // mark the mint nullifier as used
        alreadyMinted[mintNullifier] = true;

        uint256[7] memory auditorPCT;
        for (uint256 i = 0; i < auditorPCT.length; i++) {
            auditorPCT[i] = publicInputs[17 + i];
        }

        emit PrivateMint(user, auditorPCT, auditor);
    }

    /**
     * @notice Performs a private burn operation
     * @param proof The transfer proof proving the validity of the burn operation
     * @param balancePCT The balance PCT for the sender after the burn
     * @dev This function:
     *      1. Validates the sender is registered
     *      2. Verifies the sender's public key matches the proof
     *      3. Verifies the burn address's public key matches the proof
     *      4. Verifies the auditor's public key matches the proof
     *      5. Verifies the zero-knowledge proof
     *      6. Transfers the encrypted amount to the burn address
     *
     * Requirements:
     * - Auditor must be set
     * - Contract must be in standalone mode
     * - Sender must be registered
     * - Proof must be valid
     */
    function privateBurn(
        BurnProof calldata proof,
        uint256[7] calldata balancePCT
    )
        external
        onlyIfAuditorSet
        onlyForStandalone
        onlyIfUserRegistered(msg.sender)
    {
        uint256[19] calldata publicInputs = proof.publicSignals;
        address from = msg.sender;

        // validate public key
        _validatePublicKey(from, [publicInputs[0], publicInputs[1]]);

        // validate auditor public key
        _validateAuditorPublicKey([publicInputs[10], publicInputs[11]]);

        // Verify the zero-knowledge proof
        bool isVerified = burnVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        // provided encrypted balance
        EGCT memory providedBalance = EGCT({
            c1: Point({x: publicInputs[2], y: publicInputs[3]}),
            c2: Point({x: publicInputs[4], y: publicInputs[5]})
        });

        // extract encrypted burn amount
        EGCT memory encryptedBurnAmount = EGCT({
            c1: Point({x: publicInputs[6], y: publicInputs[7]}),
            c2: Point({x: publicInputs[8], y: publicInputs[9]})
        });

        // perform the burn (since burn is only for Standalone, always passing tokenId as 0)
        _privateBurn(from, 0, providedBalance, encryptedBurnAmount, balancePCT);

        // extract auditor PCT
        uint256[7] memory auditorPCT;
        for (uint256 i = 0; i < auditorPCT.length; i++) {
            auditorPCT[i] = publicInputs[12 + i];
        }

        emit PrivateBurn(from, auditorPCT, auditor);
    }

    /**
     * @notice Performs a private transfer between two users
     * @param to Address of the receiver
     * @param tokenId ID of the token to transfer
     * @param proof The transfer proof proving the validity of the transfer
     * @param balancePCT The balance PCT for the sender after the transfer
     * @dev This function:
     *      1. Validates both sender and receiver are registered
     *      2. Verifies both public keys match the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Verifies the zero-knowledge proof
     *      5. Updates both users' encrypted balances
     *
     * Requirements:
     * - Auditor must be set
     * - Both sender and receiver must be registered
     * - Proof must be valid
     */
    function transfer(
        address to,
        uint256 tokenId,
        TransferProof memory proof,
        uint256[7] calldata balancePCT
    )
        public
        onlyIfAuditorSet
        onlyIfUserRegistered(msg.sender)
        onlyIfUserRegistered(to)
    {
        uint256[32] memory publicInputs = proof.publicSignals;

        // validate user's public key
        _validatePublicKey(msg.sender, [publicInputs[0], publicInputs[1]]);
        _validatePublicKey(to, [publicInputs[10], publicInputs[11]]);

        _validateAuditorPublicKey([publicInputs[23], publicInputs[24]]);

        // Verify the zero-knowledge proof
        bool isVerified = transferVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        // Extract the inputs for the transfer operation
        TransferInputs memory transferInputs = _extractTransferInputs(
            publicInputs
        );

        // Perform the transfer
        _transfer({
            from: msg.sender,
            to: to,
            tokenId: tokenId,
            providedBalance: transferInputs.providedBalance,
            senderEncryptedAmount: transferInputs.senderEncryptedAmount,
            receiverEncryptedAmount: transferInputs.receiverEncryptedAmount,
            balancePCT: balancePCT,
            amountPCT: transferInputs.amountPCT
        });

        // Extract auditor PCT and emit event
        {
            uint256[7] memory auditorPCT;
            for (uint256 i = 0; i < 7; i++) {
                auditorPCT[i] = publicInputs[25 + i];
            }

            emit PrivateTransfer(msg.sender, to, auditorPCT, auditor);
        }
    }

    /**
     * @notice Deposits an existing ERC20 token into the contract
     * @param amount Amount of tokens to deposit
     * @param tokenAddress Address of the token to deposit
     * @param amountPCT Amount PCT for the deposit
     * @dev This function:
     *      1. Validates the user is registered
     *      2. Transfers the tokens from the user to the contract
     *      3. Converts the tokens to encrypted tokens
     *      4. Adds the encrypted amount to the user's balance
     *      5. Returns any dust (remainder) to the user
     *
     * Requirements:
     * - Auditor must be set
     * - Contract must be in converter mode
     * - Token must not be blacklisted
     * - User must be registered
     */
    function deposit(
        uint256 amount,
        address tokenAddress,
        uint256[7] memory amountPCT
    )
        public
        onlyIfAuditorSet
        onlyForConverter
        revertIfBlacklisted(tokenAddress)
        onlyIfUserRegistered(msg.sender)
    {
        IERC20 token = IERC20(tokenAddress);
        uint256 dust;
        uint256 tokenId;
        address to = msg.sender;

        // Get the contract's balance before the transfer
        uint256 balanceBefore = token.balanceOf(address(this));

        // Transfer tokens from user to contract
        SafeERC20.safeTransferFrom(token, to, address(this), amount);

        // Get the contract's balance after the transfer
        uint256 balanceAfter = token.balanceOf(address(this));

        // Verify that the actual transferred amount matches the expected amount
        uint256 actualTransferred = balanceAfter - balanceBefore;
        if (actualTransferred != amount) {
            revert TransferFailed();
        }

        // Convert tokens to encrypted tokens
        (dust, tokenId) = _convertFrom(to, amount, tokenAddress, amountPCT);

        // Return dust to user, if any
        if (dust > 0) {
            SafeERC20.safeTransfer(token, to, dust);
        }

        // Emit deposit event
        emit Deposit(to, amount, dust, tokenId);
    }

    /**
     * @notice Withdraws encrypted tokens as regular ERC20 tokens
     * @param tokenId ID of the token to withdraw
     * @param proof The withdraw proof proving the validity of the withdrawal
     * @param balancePCT The balance PCT for the user after the withdrawal
     * @dev This function:
     *      1. Validates the user is registered
     *      2. Verifies the user's public key matches the proof
     *      3. Verifies the auditor's public key matches the proof
     *      4. Verifies the zero-knowledge proof
     *      5. Subtracts the encrypted amount from the user's balance
     *      6. Converts the tokens to regular ERC20 tokens
     *
     * Requirements:
     * - Auditor must be set
     * - Contract must be in converter mode
     * - User must be registered
     * - Proof must be valid
     */
    function withdraw(
        uint256 tokenId,
        WithdrawProof memory proof,
        uint256[7] memory balancePCT
    )
        public
        onlyIfAuditorSet
        onlyForConverter
        onlyIfUserRegistered(msg.sender)
    {
        address from = msg.sender;
        uint256[16] memory publicInputs = proof.publicSignals;
        uint256 amount = publicInputs[0];

        // validate public keys
        _validatePublicKey(from, [publicInputs[1], publicInputs[2]]);
        _validateAuditorPublicKey([publicInputs[7], publicInputs[8]]);

        // Verify the zero-knowledge proof
        bool isVerified = withdrawVerifier.verifyProof(
            proof.proofPoints.a,
            proof.proofPoints.b,
            proof.proofPoints.c,
            proof.publicSignals
        );
        if (!isVerified) {
            revert InvalidProof();
        }

        // Perform the withdrawal
        _withdraw(from, amount, tokenId, publicInputs, balancePCT);

        // Extract auditor PCT and emit event
        {
            uint256[7] memory auditorPCT;
            for (uint256 i = 0; i < 7; i++) {
                auditorPCT[i] = publicInputs[9 + i];
            }

            emit Withdraw(from, amount, tokenId, auditorPCT, auditor);
        }
    }

    /**
     * @notice Gets the encrypted balance for a token address
     * @param user Address of the user
     * @param tokenAddress Address of the token
     * @return eGCT The ElGamal ciphertext representing the encrypted balance
     * @return nonce The current nonce used for balance validation
     * @return amountPCTs Array of amount PCTs for transaction history
     * @return balancePCT The current balance PCT
     * @return transactionIndex The current transaction index
     * @dev This is a convenience function that looks up the token ID and calls balanceOf
     */
    function getBalanceFromTokenAddress(
        address user,
        address tokenAddress
    )
        public
        view
        returns (
            EGCT memory eGCT,
            uint256 nonce,
            AmountPCT[] memory amountPCTs,
            uint256[7] memory balancePCT,
            uint256 transactionIndex
        )
    {
        uint256 tokenId = tokenIds[tokenAddress];
        return balanceOf(user, tokenId);
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Performs the internal logic for a private withdrawal
     * @param from Address of the user withdrawing tokens
     * @param amount Amount of tokens to withdraw
     * @param tokenId ID of the token to withdraw
     * @param publicInputs Public inputs from the proof
     * @param balancePCT The balance PCT for the user after the withdrawal
     * @dev This function:
     *      1. Validates the token exists
     *      2. Verifies the provided balance is valid
     *      3. Subtracts the encrypted amount from the user's balance
     *      4. Converts the tokens to regular ERC20 tokens
     */
    function _withdraw(
        address from,
        uint256 amount,
        uint256 tokenId,
        uint256[16] memory publicInputs,
        uint256[7] memory balancePCT
    ) internal {
        address tokenAddress = tokenAddresses[tokenId];
        if (tokenAddress == address(0)) {
            revert UnknownToken();
        }

        {
            // Extract the provided balance from the proof
            EGCT memory providedBalance = EGCT({
                c1: Point({x: publicInputs[3], y: publicInputs[4]}),
                c2: Point({x: publicInputs[5], y: publicInputs[6]})
            });

            // Encrypt the withdrawn amount
            EGCT memory encryptedWithdrawnAmount = BabyJubJub.encrypt(
                Point({x: publicInputs[1], y: publicInputs[2]}),
                amount
            );

            _privateBurn(
                from,
                tokenId,
                providedBalance,
                encryptedWithdrawnAmount,
                balancePCT
            );
        }

        // Convert and transfer the tokens
        _convertTo(from, amount, tokenAddress);
    }

    /**
     * @notice Converts regular ERC20 tokens to encrypted tokens
     * @param to Address of the receiver
     * @param amount Amount of tokens to convert
     * @param tokenAddress Address of the token to convert
     * @param amountPCT Amount PCT for the conversion
     * @return dust The dust (remainder) from the conversion
     * @return tokenId The ID of the token
     * @dev This function:
     *      1. Handles decimal scaling between tokens
     *      2. Registers the token if it's new
     *      3. Encrypts the amount with the receiver's public key
     *      4. Adds the encrypted amount to the receiver's balance
     */
    function _convertFrom(
        address to,
        uint256 amount,
        address tokenAddress,
        uint256[7] memory amountPCT
    ) internal returns (uint256 dust, uint256 tokenId) {
        // Get token decimals and handle scaling
        uint8 tokenDecimals = IERC20Metadata(tokenAddress).decimals();

        uint256 value = amount;
        dust = 0;

        // Scale down if token has more decimals
        if (tokenDecimals > decimals) {
            uint256 scalingFactor = 10 ** (tokenDecimals - decimals);
            value = amount / scalingFactor;
            dust = amount % scalingFactor;
        }
        // Scale up if token has fewer decimals
        else if (tokenDecimals < decimals) {
            uint256 scalingFactor = 10 ** (decimals - tokenDecimals);
            value = amount * scalingFactor;
            dust = 0;
        }

        // Register the token if it's new
        if (tokenIds[tokenAddress] == 0) {
            _addToken(tokenAddress);
        }
        tokenId = tokenIds[tokenAddress];

        // Return early if the scaled value is zero
        if (value == 0) {
            return (dust, tokenId);
        }

        // Encrypt and add to balance
        {
            // Get the receiver's public key
            uint256[2] memory publicKey = registrar.getUserPublicKey(to);

            // Encrypt the value with the receiver's public key
            EGCT memory eGCT = BabyJubJub.encrypt(
                Point({x: publicKey[0], y: publicKey[1]}),
                value
            );

            // Add to the receiver's balance
            EncryptedBalance storage balance = balances[to][tokenId];

            if (balance.eGCT.c1.x == 0 && balance.eGCT.c1.y == 0) {
                balance.eGCT = eGCT;
            } else {
                balance.eGCT.c1 = BabyJubJub._add(balance.eGCT.c1, eGCT.c1);
                balance.eGCT.c2 = BabyJubJub._add(balance.eGCT.c2, eGCT.c2);
            }

            // Update transaction history
            balance.amountPCTs.push(
                AmountPCT({pct: amountPCT, index: balance.transactionIndex})
            );
            balance.transactionIndex++;

            // Commit the new balance
            _commitUserBalance(to, tokenId);
        }

        return (dust, tokenId);
    }

    /**
     * @notice Converts encrypted tokens to regular ERC20 tokens
     * @param to Address of the receiver
     * @param amount Amount of tokens to convert
     * @param tokenAddress Address of the token to convert to
     * @dev This function:
     *      1. Handles decimal scaling between tokens
     *      2. Transfers the tokens to the receiver
     */
    function _convertTo(
        address to,
        uint256 amount,
        address tokenAddress
    ) internal {
        // Get token decimals and handle scaling
        uint256 tokenDecimals = IERC20Metadata(tokenAddress).decimals();

        uint256 value = amount;
        uint256 scalingFactor = 0;

        // Scale up if token has more decimals
        if (tokenDecimals > decimals) {
            scalingFactor = 10 ** (tokenDecimals - decimals);
            value = amount * scalingFactor;
        }
        // Scale down if token has fewer decimals
        else if (tokenDecimals < decimals) {
            scalingFactor = 10 ** (decimals - tokenDecimals);
            value = amount / scalingFactor;
        }

        // Transfer the tokens to the receiver
        IERC20 token = IERC20(tokenAddress);
        SafeERC20.safeTransfer(token, to, value);
    }

    /**
     * @notice Performs the internal logic for a private mint
     * @param user Address of the user to mint tokens to
     * @param encryptedAmount The encrypted amount to mint
     * @param amountPCT The amount PCT for the mint
     * @dev This function:
     *      1. Adds the encrypted amount to the user's balance
     *      2. Emits a PrivateMint event
     */
    function _privateMint(
        address user,
        EGCT memory encryptedAmount,
        uint256[7] memory amountPCT
    ) internal {
        // since private mint is only for the standalone ERC, tokenId is always 0
        _addToUserBalance(user, 0, encryptedAmount, amountPCT);
    }

    /**
     * @notice Performs the internal logic for a private transfer
     * @param from address The address of the sender
     * @param to address The address of the receiver
     * @param tokenId uint256 The ID of the token to transfer
     * @param providedBalance EGCT The provided balance from the proof
     * @param senderEncryptedAmount EGCT The encrypted amount to subtract from the sender's balance
     * @param receiverEncryptedAmount EGCT The encrypted amount to add to the receiver's balance
     * @param balancePCT uint256[7] The balance PCT for the sender after the transfer
     * @param amountPCT uint256[7] The amount PCT for the transfer
     * @dev This function:
     *      1. Verifies the sender's balance is valid
     *      2. Subtracts the encrypted amount from the sender's balance
     *      3. Adds the encrypted amount to the receiver's balance
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId,
        EGCT memory providedBalance,
        EGCT memory senderEncryptedAmount,
        EGCT memory receiverEncryptedAmount,
        uint256[7] memory balancePCT,
        uint256[7] memory amountPCT
    ) internal {
        {
            // 1. for sender operation is very similar to the private burn
            _privateBurn(
                from,
                tokenId,
                providedBalance,
                senderEncryptedAmount,
                balancePCT
            );
        }

        {
            // 2. for receiver operation is very similar to the private mint
            _addToUserBalance(to, tokenId, receiverEncryptedAmount, amountPCT);
        }
    }

    /**
     * @notice Performs the internal logic for a private burn
     * @param from Address of the user to burn tokens from
     * @param tokenId ID of the token to burn
     * @param providedBalance The provided balance from the proof
     * @param encryptedAmount The encrypted amount to subtract
     * @param balancePCT The balance PCT for the user after the burn
     * @dev This function:
     *      1. Verifies the user's balance is valid
     *      2. Subtracts the encrypted amount from the user's balance
     */
    function _privateBurn(
        address from,
        uint256 tokenId,
        EGCT memory providedBalance,
        EGCT memory encryptedAmount,
        uint256[7] memory balancePCT
    ) internal {
        // verify user encrypted balance
        uint256 transactionIndex = _verifyUserBalance(
            from,
            tokenId,
            providedBalance
        );

        // subtract from user's balance
        _subtractFromUserBalance(
            from,
            tokenId,
            encryptedAmount,
            balancePCT,
            transactionIndex
        );
    }

    /**
     * @notice Validates a user's public key
     * @param user The address of the user
     * @param providedPublicKey The public key to validate
     * @dev Function fetches the user's public key from the registrar contract
     * @dev If the public key is not valid, it reverts with InvalidProof error
     */
    function _validatePublicKey(
        address user,
        uint256[2] memory providedPublicKey
    ) internal view {
        uint256[2] memory userPublicKey = registrar.getUserPublicKey(user);

        if (
            userPublicKey[0] != providedPublicKey[0] ||
            userPublicKey[1] != providedPublicKey[1]
        ) {
            revert InvalidProof();
        }
    }

    /**
     * @notice Validates the auditor's public key
     * @param providedPublicKey The public key to validate
     * @dev If the public key is not match with the auditor's public key, it reverts with InvalidProof error
     */
    function _validateAuditorPublicKey(
        uint256[2] memory providedPublicKey
    ) internal view {
        if (
            auditorPublicKey.x != providedPublicKey[0] ||
            auditorPublicKey.y != providedPublicKey[1]
        ) {
            revert InvalidProof();
        }
    }

    /**
     * @notice Extracts the inputs for a transfer operation
     * @param input The input array containing the transfer data
     * @return transferInputs TransferInputs struct containing:
     *         - providedBalance (EGCT): The provided balance from the proof
     *         - senderEncryptedAmount (EGCT): The encrypted amount to subtract from sender
     *         - receiverEncryptedAmount (EGCT): The encrypted amount to add to receiver
     *         - amountPCT (uint256[7]): The amount PCT for the transfer
     */
    function _extractTransferInputs(
        uint256[32] memory input
    ) internal pure returns (TransferInputs memory transferInputs) {
        transferInputs.providedBalance = EGCT({
            c1: Point({x: input[2], y: input[3]}),
            c2: Point({x: input[4], y: input[5]})
        });

        transferInputs.senderEncryptedAmount = EGCT({
            c1: Point({x: input[6], y: input[7]}),
            c2: Point({x: input[8], y: input[9]})
        });

        transferInputs.receiverEncryptedAmount = EGCT({
            c1: Point({x: input[12], y: input[13]}),
            c2: Point({x: input[14], y: input[15]})
        });

        for (uint256 i = 0; i < 7; i++) {
            transferInputs.amountPCT[i] = input[16 + i];
        }
    }
}



================================================
FILE: contracts/EncryptedUserBalances.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {EncryptedBalance, EGCT, BalanceHistory, AmountPCT} from "./types/Types.sol";
import {InvalidProof} from "./errors/Errors.sol";
import {BabyJubJub} from "./libraries/BabyJubJub.sol";

/**
 * @title EncryptedUserBalances
 * @notice Contract for managing encrypted user balances in the privacy-preserving ERC system
 * @dev This contract handles:
 *      1. Storage and retrieval of encrypted balances
 *      2. Balance history tracking for transaction validation
 *      3. Cryptographic operations on encrypted balances
 *
 * The contract uses ElGamal encryption (EGCT) to store balances privately,
 * allowing users to prove they have sufficient funds without revealing the actual amount.
 */
contract EncryptedUserBalances {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice Mapping of user addresses to their encrypted balances for each token
    /// @dev Structure: user => tokenId => EncryptedBalance
    mapping(address user => mapping(uint256 tokenId => EncryptedBalance balance))
        public balances;

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Returns the encrypted balance for a user's standalone token
     * @param user The address of the user
     * @return eGCT The ElGamal ciphertext representing the encrypted balance
     * @return nonce The current nonce used for balance validation
     * @return amountPCTs Array of amount PCT
     * @return balancePCT The current balance PCT
     * @return transactionIndex The current transaction index
     * @dev Since in standalone mode, the tokenId is always 0
     */
    function balanceOfStandalone(
        address user
    )
        external
        view
        returns (
            EGCT memory eGCT,
            uint256 nonce,
            AmountPCT[] memory amountPCTs,
            uint256[7] memory balancePCT,
            uint256 transactionIndex
        )
    {
        return balanceOf(user, 0);
    }

    /**
     * @notice Returns the encrypted balance for a user's specified token
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @return eGCT The ElGamal ciphertext representing the encrypted balance
     * @return nonce The current nonce used for balance validation
     * @return amountPCTs Array of amount PCT
     * @return balancePCT The current balance PCT
     * @return transactionIndex The current transaction index
     */
    function balanceOf(
        address user,
        uint256 tokenId
    )
        public
        view
        returns (
            EGCT memory eGCT,
            uint256 nonce,
            AmountPCT[] memory amountPCTs,
            uint256[7] memory balancePCT,
            uint256 transactionIndex
        )
    {
        EncryptedBalance storage balance = balances[user][tokenId];
        return (
            balance.eGCT,
            balance.nonce,
            balance.amountPCTs,
            balance.balancePCT,
            balance.transactionIndex
        );
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Adds an encrypted amount to a user's balance
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param eGCT The ElGamal ciphertext representing the amount to add
     * @param amountPCT The amount PCT for transaction history
     * @dev This function:
     *      1. Initializes the balance if it's the first transaction
     *      2. Adds the encrypted amount to the existing balance
     *      3. Updates the user history (by adding new amount PCT)
     */
    function _addToUserBalance(
        address user,
        uint256 tokenId,
        EGCT memory eGCT,
        uint256[7] memory amountPCT
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        // if user balance is not initialized, initialize it
        if (balance.eGCT.c1.x == 0 && balance.eGCT.c1.y == 0) {
            balance.eGCT = eGCT;
        } else {
            // if user balance is already initialized, add the encrypted amount to the balance
            balance.eGCT.c1 = BabyJubJub._add(balance.eGCT.c1, eGCT.c1);
            balance.eGCT.c2 = BabyJubJub._add(balance.eGCT.c2, eGCT.c2);
        }

        // in all the case
        _addToUserHistory(user, tokenId, amountPCT);
    }

    /**
     * @notice Subtracts an encrypted amount from a user's balance
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param eGCT The ElGamal ciphertext representing the amount to subtract
     * @param balancePCT The new balance PCT after subtraction
     * @param transactionIndex The transaction index to delete from history
     * @dev This function:
     *      1. Subtracts the encrypted amount from the balance
     *      2. Updates the user history (by removing the specified transaction)
     *      3. Updates the balance PCT for user
     */
    function _subtractFromUserBalance(
        address user,
        uint256 tokenId,
        EGCT memory eGCT,
        uint256[7] memory balancePCT,
        uint256 transactionIndex
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        balance.eGCT.c1 = BabyJubJub._sub(balance.eGCT.c1, eGCT.c1);
        balance.eGCT.c2 = BabyJubJub._sub(balance.eGCT.c2, eGCT.c2);

        // delete the amount pct from the balance
        _deleteUserHistory(user, tokenId, transactionIndex);

        // update balance pct
        balance.balancePCT = balancePCT;
    }

    /**
     * @notice Adds a transaction to the user's balance history
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param amountPCT The amount PCT for the transaction
     * @dev This function:
     *      1. Calculates a unique hash for the current balance state
     *      2. Marks this hash as valid in the balance history
     *      3. Adds the amount PCT to the transaction history
     *      4. Increments the transaction index
     *
     * The balance hash is unique for each transaction because it includes the nonce,
     * which is incremented after each transaction. This ensures that each transaction
     * can be uniquely identified and validated.
     */
    function _addToUserHistory(
        address user,
        uint256 tokenId,
        uint256[7] memory amountPCT
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        uint256 nonce = balance.nonce;
        uint256 balanceHash = _hashEGCT(balance.eGCT);
        balanceHash = uint256(keccak256(abi.encode(balanceHash, nonce)));

        // mark the balance hash as valid
        balance.balanceList[balanceHash] = BalanceHistory({
            index: balance.transactionIndex,
            isValid: true
        });

        // add the amount pct to the balance
        balance.amountPCTs.push(
            AmountPCT({pct: amountPCT, index: balance.transactionIndex})
        );

        balance.transactionIndex++;
    }

    /**
     * @notice Commits the current balance state to the user's history
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @dev This function:
     *      1. Calculates a unique hash for the current balance state
     *      2. Marks this hash as valid in the balance history
     *      3. Increments the transaction index
     *
     * This is used to create a checkpoint of the balance state after operations
     * that don't change the balance amount but need to be recorded in history.
     */
    function _commitUserBalance(address user, uint256 tokenId) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        uint256 nonce = balance.nonce;
        uint256 balanceHash = _hashEGCT(balance.eGCT);
        balanceHash = uint256(keccak256(abi.encode(balanceHash, nonce)));

        balance.balanceList[balanceHash] = BalanceHistory({
            index: balance.transactionIndex,
            isValid: true
        });

        balance.transactionIndex++;
    }

    /**
     * @notice Deletes transaction history up to a specific transaction index
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param transactionIndex The transaction index to delete up to
     * @dev This function:
     *      1. Removes amount PCTs from the history up to the specified index
     *      2. Increments the nonce (invalidate all previous balance hashes)
     *      3. Commits the new balance state to history
     *
     * Instead of deleting individual history entries, this function uses the nonce
     * to invalidate all previous balance hashes at once, which is more gas efficient.
     */
    function _deleteUserHistory(
        address user,
        uint256 tokenId,
        uint256 transactionIndex
    ) internal {
        EncryptedBalance storage balance = balances[user][tokenId];

        for (uint256 i = balance.amountPCTs.length; i > 0; i--) {
            uint256 index = i - 1;

            if (balance.amountPCTs[index].index <= transactionIndex) {
                balance.amountPCTs[index] = balance.amountPCTs[
                    balance.amountPCTs.length - 1
                ];
                balance.amountPCTs.pop();
            }
        }

        balance.nonce++;

        _commitUserBalance(user, tokenId);
    }

    /**
     * @notice Checks if a balance hash is valid for a user
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param balanceHash The hash to validate
     * @return isValid True if the hash is valid, false otherwise
     * @return index The transaction index associated with the hash
     * This is used to validate that a user is using a recent and valid balance
     * in their transactions.
     */
    function _isBalanceValid(
        address user,
        uint256 tokenId,
        uint256 balanceHash
    ) internal view returns (bool, uint256) {
        uint256 nonce = balances[user][tokenId].nonce;
        uint256 hashWithNonce = uint256(
            keccak256(abi.encode(balanceHash, nonce))
        );
        return (
            balances[user][tokenId].balanceList[hashWithNonce].isValid,
            balances[user][tokenId].balanceList[hashWithNonce].index
        );
    }

    /**
     * @notice Verifies a user's balance
     * @param user The address of the user
     * @param tokenId The ID of the token
     * @param eGCT The ElGamal ciphertext representing the balance
     * @return transactionIndex The transaction index associated with the balance
     * @dev If balance is not valid, it reverts with InvalidProof error
     */
    function _verifyUserBalance(
        address user,
        uint256 tokenId,
        EGCT memory eGCT
    ) internal view returns (uint256) {
        // hash the encrypted balance
        uint256 balanceHash = _hashEGCT(eGCT);

        (bool isValid, uint256 transactionIndex) = _isBalanceValid(
            user,
            tokenId,
            balanceHash
        );
        if (!isValid) {
            revert InvalidProof();
        }

        return transactionIndex;
    }

    /**
     * @notice Calculates a hash of an ElGamal ciphertext
     * @param eGCT The ElGamal ciphertext to hash
     * @return The hash of the ciphertext
     * @dev This function creates a unique identifier for an encrypted balance
     *      by hashing all components of the ElGamal ciphertext.
     */
    function _hashEGCT(EGCT memory eGCT) internal pure returns (uint256) {
        return
            uint256(
                keccak256(
                    abi.encode(eGCT.c1.x, eGCT.c1.y, eGCT.c2.x, eGCT.c2.y)
                )
            );
    }
}



================================================
FILE: contracts/NewRegistrationVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
// This is the generated verifier for the REGISTER circuit with gnark v0.11.0
// Generated to match the circuit proof that is being created

pragma solidity ^0.8.0;

/// @title Groth16 verifier template.
/// @author Remco Bloemen
/// @notice Supports verifying Groth16 proofs. Proofs can be in uncompressed
/// (256 bytes) and compressed (128 bytes) format. A view function is provided
/// to compress proofs.
/// @notice See <https://2œÄ.com/23/bn254-compression> for further explanation.
contract Verifier {

    /// Some of the provided public input values are larger than the field modulus.
    /// @dev Public input elements are not automatically reduced, as this is can be
    /// a dangerous source of bugs.
    error PublicInputNotInField();

    /// The proof is invalid.
    /// @dev This can mean that provided Groth16 proof points are not on their
    /// curves, that pairing equation fails, or that the proof is not for the
    /// provided public input.
    error ProofInvalid();

    // Addresses of precompiles
    uint256 constant PRECOMPILE_MODEXP = 0x05;
    uint256 constant PRECOMPILE_ADD = 0x06;
    uint256 constant PRECOMPILE_MUL = 0x07;
    uint256 constant PRECOMPILE_VERIFY = 0x08;

    // Base field Fp order P and scalar field Fr order R.
    // For BN254 these are computed as follows:
    //     t = 4965661367192848881
    //     P = 36‚ãÖt‚Å¥ + 36‚ãÖt¬≥ + 24‚ãÖt¬≤ + 6‚ãÖt + 1
    //     R = 36‚ãÖt‚Å¥ + 36‚ãÖt¬≥ + 18‚ãÖt¬≤ + 6‚ãÖt + 1
    uint256 constant P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;
    uint256 constant R = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;

    // Extension field Fp2 = Fp[i] / (i¬≤ + 1)
    // Note: This is the complex extension field of Fp with i¬≤ = -1.
    //       Values in Fp2 are represented as a pair of Fp elements (a‚ÇÄ, a‚ÇÅ) as a‚ÇÄ + a‚ÇÅ‚ãÖi.
    // Note: The order of Fp2 elements is *opposite* that of the pairing contract, which
    //       expects Fp2 elements in order (a‚ÇÅ, a‚ÇÄ). This is also the order in which
    //       Fp2 elements are encoded in the public interface as this became convention.

    // Constants in Fp
    uint256 constant FRACTION_1_2_FP = 0x183227397098d014dc2822db40c0ac2ecbc0b548b438e5469e10460b6c3e7ea4;
    uint256 constant FRACTION_27_82_FP = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;
    uint256 constant FRACTION_3_82_FP = 0x2fcd3ac2a640a154eb23960892a85a68f031ca0c8344b23a577dcf1052b9e775;

    // Exponents for inversions and square roots mod P
    uint256 constant EXP_INVERSE_FP = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45; // P - 2
    uint256 constant EXP_SQRT_FP = 0xC19139CB84C680A6E14116DA060561765E05AA45A1C72A34F082305B61F3F52; // (P + 1) / 4;

    // Groth16 alpha point in G1
    uint256 constant ALPHA_X = 6058531991783539937838466006718729123815878216610639129477846879114840812414;
    uint256 constant ALPHA_Y = 1757265288700136031909296301036593197966020043341513024002351200367188093642;

    // Groth16 beta point in G2 in powers of i
    uint256 constant BETA_NEG_X_0 = 15785413215907563493908613526779820812660376562606613683068513306308072640111;
    uint256 constant BETA_NEG_X_1 = 9580429729931877154841629545118162949840435297985967602379239001225158606952;
    uint256 constant BETA_NEG_Y_0 = 4804688102402038569503902501595148572329177084091215587522569404574260161768;
    uint256 constant BETA_NEG_Y_1 = 21686782596700358723231548886478230839599119790234036596905874935206730764976;

    // Groth16 gamma point in G2 in powers of i
    uint256 constant GAMMA_NEG_X_0 = 2506571248857031470806792582338149346032578793265495280808842745646037977132;
    uint256 constant GAMMA_NEG_X_1 = 14081851590971011823794047272064155342148649946332314896030617150304498463767;
    uint256 constant GAMMA_NEG_Y_0 = 11662525729503254711720962463494958325176458678888332352409671770836354833258;
    uint256 constant GAMMA_NEG_Y_1 = 16948752876861056186014817074235098941689023635324073397162764621215527937052;

    // Groth16 delta point in G2 in powers of i
    uint256 constant DELTA_NEG_X_0 = 11449403835681522469866660158226279192853127383826903814694657227600935026276;
    uint256 constant DELTA_NEG_X_1 = 8543886663480291910194003740115255107893321264851115105407146975225019432246;
    uint256 constant DELTA_NEG_Y_0 = 8821281208049649433304468393684339740332665975078672697139432768504415939612;
    uint256 constant DELTA_NEG_Y_1 = 1382213998114274450534689530703389478291732520472084714293585131222792609403;

    // Constant and public input points
    uint256 constant CONSTANT_X = 6115371029985218321625063499569308606361376763441805250995618339797687153901;
    uint256 constant CONSTANT_Y = 17262869048355424701399424649596772411532809516619303118027349682974201643015;
    uint256 constant PUB_0_X = 18976671950045927643181105671353952683115497642336956815594922177846966060259;
    uint256 constant PUB_0_Y = 2436446393294413456463365861697104613080737799605490010395849158989757633126;
    uint256 constant PUB_1_X = 10500175356543893674664750842377654137370606144996899215820845696939097598513;
    uint256 constant PUB_1_Y = 3094289125365710433375452334987110559038943194775869042931539403452432231085;
    uint256 constant PUB_2_X = 6252912239610118503848180768160858102600017599206157685267553906949608592066;
    uint256 constant PUB_2_Y = 9672724188235829239545872205311965972953628277960403201452776941564264786257;
    uint256 constant PUB_3_X = 4450324871438313753846462874213951085965992034332587915908207196010859076866;
    uint256 constant PUB_3_Y = 18550233370568200256255744689940785001752334780325704789290678976898386010906;
    uint256 constant PUB_4_X = 10234238342117068190174928914748315701007271619081041776511782702732917830285;
    uint256 constant PUB_4_Y = 17794443457775109161061880093530565528564624390259704671033793420542983844404;

    /// Negation in Fp.
    /// @notice Returns a number x such that a + x = 0 in Fp.
    /// @notice The input does not need to be reduced.
    /// @param a the base
    /// @return x the result
    function negate(uint256 a) internal pure returns (uint256 x) {
        unchecked {
            x = (P - (a % P)) % P; // Modulo is cheaper than branching
        }
    }

    /// Exponentiation in Fp.
    /// @notice Returns a number x such that a ^ e = x in Fp.
    /// @notice The input does not need to be reduced.
    /// @param a the base
    /// @param e the exponent
    /// @return x the result
    function exp(uint256 a, uint256 e) internal view returns (uint256 x) {
        bool success;
        assembly ("memory-safe") {
            let f := mload(0x40)
            mstore(f, 0x20)
            mstore(add(f, 0x20), 0x20)
            mstore(add(f, 0x40), 0x20)
            mstore(add(f, 0x60), a)
            mstore(add(f, 0x80), e)
            mstore(add(f, 0xa0), P)
            success := staticcall(gas(), PRECOMPILE_MODEXP, f, 0xc0, f, 0x20)
            x := mload(f)
        }
        if (!success) {
            // Exponentiation failed.
            // Should not happen.
            revert ProofInvalid();
        }
    }

    /// Invertsion in Fp.
    /// @notice Returns a number x such that a * x = 1 in Fp.
    /// @notice The input does not need to be reduced.
    /// @notice Reverts with ProofInvalid() if the inverse does not exist
    /// @param a the input
    /// @return x the solution
    function invert_Fp(uint256 a) internal view returns (uint256 x) {
        x = exp(a, EXP_INVERSE_FP);
        if (mulmod(a, x, P) != 1) {
            // Inverse does not exist.
            // Can only happen during G2 point decompression.
            revert ProofInvalid();
        }
    }

    /// Square root in Fp.
    /// @notice Returns a number x such that x * x = a in Fp.
    /// @notice Will revert with InvalidProof() if the input is not a square
    /// or not reduced.
    /// @param a the square
    /// @return x the solution
    function sqrt_Fp(uint256 a) internal view returns (uint256 x) {
        x = exp(a, EXP_SQRT_FP);
        if (mulmod(x, x, P) != a) {
            // Square root does not exist or a is not reduced.
            // Happens when G1 point is not on curve.
            revert ProofInvalid();
        }
    }

    /// Square test in Fp.
    /// @notice Returns whether a number x exists such that x * x = a in Fp.
    /// @notice Will revert with InvalidProof() if the input is not a square
    /// or not reduced.
    /// @param a the square
    /// @return x the solution
    function isSquare_Fp(uint256 a) internal view returns (bool) {
        uint256 x = exp(a, EXP_SQRT_FP);
        return mulmod(x, x, P) == a;
    }

    /// Square root in Fp2.
    /// @notice Fp2 is the complex extension Fp[i]/(i^2 + 1). The input is
    /// a0 + a1 ‚ãÖ i and the result is x0 + x1 ‚ãÖ i.
    /// @notice Will revert with InvalidProof() if
    ///   * the input is not a square,
    ///   * the hint is incorrect, or
    ///   * the input coefficents are not reduced.
    /// @param a0 The real part of the input.
    /// @param a1 The imaginary part of the input.
    /// @param hint A hint which of two possible signs to pick in the equation.
    /// @return x0 The real part of the square root.
    /// @return x1 The imaginary part of the square root.
    function sqrt_Fp2(uint256 a0, uint256 a1, bool hint) internal view returns (uint256 x0, uint256 x1) {
        // If this square root reverts there is no solution in Fp2.
        uint256 d = sqrt_Fp(addmod(mulmod(a0, a0, P), mulmod(a1, a1, P), P));
        if (hint) {
            d = negate(d);
        }
        // If this square root reverts there is no solution in Fp2.
        x0 = sqrt_Fp(mulmod(addmod(a0, d, P), FRACTION_1_2_FP, P));
        x1 = mulmod(a1, invert_Fp(mulmod(x0, 2, P)), P);

        // Check result to make sure we found a root.
        // Note: this also fails if a0 or a1 is not reduced.
        if (a0 != addmod(mulmod(x0, x0, P), negate(mulmod(x1, x1, P)), P)
        ||  a1 != mulmod(2, mulmod(x0, x1, P), P)) {
            revert ProofInvalid();
        }
    }

    /// Compress a G1 point.
    /// @notice Reverts with InvalidProof if the coordinates are not reduced
    /// or if the point is not on the curve.
    /// @notice The point at infinity is encoded as (0,0) and compressed to 0.
    /// @param x The X coordinate in Fp.
    /// @param y The Y coordinate in Fp.
    /// @return c The compresed point (x with one signal bit).
    function compress_g1(uint256 x, uint256 y) internal view returns (uint256 c) {
        if (x >= P || y >= P) {
            // G1 point not in field.
            revert ProofInvalid();
        }
        if (x == 0 && y == 0) {
            // Point at infinity
            return 0;
        }

        // Note: sqrt_Fp reverts if there is no solution, i.e. the x coordinate is invalid.
        uint256 y_pos = sqrt_Fp(addmod(mulmod(mulmod(x, x, P), x, P), 3, P));
        if (y == y_pos) {
            return (x << 1) | 0;
        } else if (y == negate(y_pos)) {
            return (x << 1) | 1;
        } else {
            // G1 point not on curve.
            revert ProofInvalid();
        }
    }

    /// Decompress a G1 point.
    /// @notice Reverts with InvalidProof if the input does not represent a valid point.
    /// @notice The point at infinity is encoded as (0,0) and compressed to 0.
    /// @param c The compresed point (x with one signal bit).
    /// @return x The X coordinate in Fp.
    /// @return y The Y coordinate in Fp.
    function decompress_g1(uint256 c) internal view returns (uint256 x, uint256 y) {
        // Note that X = 0 is not on the curve since 0¬≥ + 3 = 3 is not a square.
        // so we can use it to represent the point at infinity.
        if (c == 0) {
            // Point at infinity as encoded in EIP196 and EIP197.
            return (0, 0);
        }
        bool negate_point = c & 1 == 1;
        x = c >> 1;
        if (x >= P) {
            // G1 x coordinate not in field.
            revert ProofInvalid();
        }

        // Note: (x¬≥ + 3) is irreducible in Fp, so it can not be zero and therefore
        //       y can not be zero.
        // Note: sqrt_Fp reverts if there is no solution, i.e. the point is not on the curve.
        y = sqrt_Fp(addmod(mulmod(mulmod(x, x, P), x, P), 3, P));
        if (negate_point) {
            y = negate(y);
        }
    }

    /// Compress a G2 point.
    /// @notice Reverts with InvalidProof if the coefficients are not reduced
    /// or if the point is not on the curve.
    /// @notice The G2 curve is defined over the complex extension Fp[i]/(i^2 + 1)
    /// with coordinates (x0 + x1 ‚ãÖ i, y0 + y1 ‚ãÖ i).
    /// @notice The point at infinity is encoded as (0,0,0,0) and compressed to (0,0).
    /// @param x0 The real part of the X coordinate.
    /// @param x1 The imaginary poart of the X coordinate.
    /// @param y0 The real part of the Y coordinate.
    /// @param y1 The imaginary part of the Y coordinate.
    /// @return c0 The first half of the compresed point (x0 with two signal bits).
    /// @return c1 The second half of the compressed point (x1 unmodified).
    function compress_g2(uint256 x0, uint256 x1, uint256 y0, uint256 y1)
    internal view returns (uint256 c0, uint256 c1) {
        if (x0 >= P || x1 >= P || y0 >= P || y1 >= P) {
            // G2 point not in field.
            revert ProofInvalid();
        }
        if ((x0 | x1 | y0 | y1) == 0) {
            // Point at infinity
            return (0, 0);
        }

        // Compute y^2
        // Note: shadowing variables and scoping to avoid stack-to-deep.
        uint256 y0_pos;
        uint256 y1_pos;
        {
            uint256 n3ab = mulmod(mulmod(x0, x1, P), P-3, P);
            uint256 a_3 = mulmod(mulmod(x0, x0, P), x0, P);
            uint256 b_3 = mulmod(mulmod(x1, x1, P), x1, P);
            y0_pos = addmod(FRACTION_27_82_FP, addmod(a_3, mulmod(n3ab, x1, P), P), P);
            y1_pos = negate(addmod(FRACTION_3_82_FP,  addmod(b_3, mulmod(n3ab, x0, P), P), P));
        }

        // Determine hint bit
        // If this sqrt fails the x coordinate is not on the curve.
        bool hint;
        {
            uint256 d = sqrt_Fp(addmod(mulmod(y0_pos, y0_pos, P), mulmod(y1_pos, y1_pos, P), P));
            hint = !isSquare_Fp(mulmod(addmod(y0_pos, d, P), FRACTION_1_2_FP, P));
        }

        // Recover y
        (y0_pos, y1_pos) = sqrt_Fp2(y0_pos, y1_pos, hint);
        if (y0 == y0_pos && y1 == y1_pos) {
            c0 = (x0 << 2) | (hint ? 2  : 0) | 0;
            c1 = x1;
        } else if (y0 == negate(y0_pos) && y1 == negate(y1_pos)) {
            c0 = (x0 << 2) | (hint ? 2  : 0) | 1;
            c1 = x1;
        } else {
            // G1 point not on curve.
            revert ProofInvalid();
        }
    }

    /// Decompress a G2 point.
    /// @notice Reverts with InvalidProof if the input does not represent a valid point.
    /// @notice The G2 curve is defined over the complex extension Fp[i]/(i^2 + 1)
    /// with coordinates (x0 + x1 ‚ãÖ i, y0 + y1 ‚ãÖ i).
    /// @notice The point at infinity is encoded as (0,0,0,0) and compressed to (0,0).
    /// @param c0 The first half of the compresed point (x0 with two signal bits).
    /// @param c1 The second half of the compressed point (x1 unmodified).
    /// @return x0 The real part of the X coordinate.
    /// @return x1 The imaginary poart of the X coordinate.
    /// @return y0 The real part of the Y coordinate.
    /// @return y1 The imaginary part of the Y coordinate.
    function decompress_g2(uint256 c0, uint256 c1)
    internal view returns (uint256 x0, uint256 x1, uint256 y0, uint256 y1) {
        // Note that X = (0, 0) is not on the curve since 0¬≥ + 3/(9 + i) is not a square.
        // so we can use it to represent the point at infinity.
        if (c0 == 0 && c1 == 0) {
            // Point at infinity as encoded in EIP197.
            return (0, 0, 0, 0);
        }
        bool negate_point = c0 & 1 == 1;
        bool hint = c0 & 2 == 2;
        x0 = c0 >> 2;
        x1 = c1;
        if (x0 >= P || x1 >= P) {
            // G2 x0 or x1 coefficient not in field.
            revert ProofInvalid();
        }

        uint256 n3ab = mulmod(mulmod(x0, x1, P), P-3, P);
        uint256 a_3 = mulmod(mulmod(x0, x0, P), x0, P);
        uint256 b_3 = mulmod(mulmod(x1, x1, P), x1, P);

        y0 = addmod(FRACTION_27_82_FP, addmod(a_3, mulmod(n3ab, x1, P), P), P);
        y1 = negate(addmod(FRACTION_3_82_FP,  addmod(b_3, mulmod(n3ab, x0, P), P), P));

        // Note: sqrt_Fp2 reverts if there is no solution, i.e. the point is not on the curve.
        // Note: (X¬≥ + 3/(9 + i)) is irreducible in Fp2, so y can not be zero.
        //       But y0 or y1 may still independently be zero.
        (y0, y1) = sqrt_Fp2(y0, y1, hint);
        if (negate_point) {
            y0 = negate(y0);
            y1 = negate(y1);
        }
    }

    /// Compute the public input linear combination.
    /// @notice Reverts with PublicInputNotInField if the input is not in the field.
    /// @notice Computes the multi-scalar-multiplication of the public input
    /// elements and the verification key including the constant term.
    /// @param input The public inputs. These are elements of the scalar field Fr.
    /// @return x The X coordinate of the resulting G1 point.
    /// @return y The Y coordinate of the resulting G1 point.
    function publicInputMSM(uint256[5] calldata input)
    internal view returns (uint256 x, uint256 y) {
        // Note: The ECMUL precompile does not reject unreduced values, so we check this.
        // Note: Unrolling this loop does not cost much extra in code-size, the bulk of the
        //       code-size is in the PUB_ constants.
        // ECMUL has input (x, y, scalar) and output (x', y').
        // ECADD has input (x1, y1, x2, y2) and output (x', y').
        // We reduce commitments(if any) with constants as the first point argument to ECADD.
        // We call them such that ecmul output is already in the second point
        // argument to ECADD so we can have a tight loop.
        bool success = true;
        assembly ("memory-safe") {
            let f := mload(0x40)
            let g := add(f, 0x40)
            let s
            mstore(f, CONSTANT_X)
            mstore(add(f, 0x20), CONSTANT_Y)
            mstore(g, PUB_0_X)
            mstore(add(g, 0x20), PUB_0_Y)
            s :=  calldataload(input)
            mstore(add(g, 0x40), s)
            success := and(success, lt(s, R))
            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))
            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))
            mstore(g, PUB_1_X)
            mstore(add(g, 0x20), PUB_1_Y)
            s :=  calldataload(add(input, 32))
            mstore(add(g, 0x40), s)
            success := and(success, lt(s, R))
            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))
            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))
            mstore(g, PUB_2_X)
            mstore(add(g, 0x20), PUB_2_Y)
            s :=  calldataload(add(input, 64))
            mstore(add(g, 0x40), s)
            success := and(success, lt(s, R))
            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))
            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))
            mstore(g, PUB_3_X)
            mstore(add(g, 0x20), PUB_3_Y)
            s :=  calldataload(add(input, 96))
            mstore(add(g, 0x40), s)
            success := and(success, lt(s, R))
            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))
            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))
            mstore(g, PUB_4_X)
            mstore(add(g, 0x20), PUB_4_Y)
            s :=  calldataload(add(input, 128))
            mstore(add(g, 0x40), s)
            success := and(success, lt(s, R))
            success := and(success, staticcall(gas(), PRECOMPILE_MUL, g, 0x60, g, 0x40))
            success := and(success, staticcall(gas(), PRECOMPILE_ADD, f, 0x80, f, 0x40))

            x := mload(f)
            y := mload(add(f, 0x20))
        }
        if (!success) {
            // Either Public input not in field, or verification key invalid.
            // We assume the contract is correctly generated, so the verification key is valid.
            revert PublicInputNotInField();
        }
    }

    /// Compress a proof.
    /// @notice Will revert with InvalidProof if the curve points are invalid,
    /// but does not verify the proof itself.
    /// @param proof The uncompressed Groth16 proof. Elements are in the same order as for
    /// verifyProof. I.e. Groth16 points (A, B, C) encoded as in EIP-197.
    /// @return compressed The compressed proof. Elements are in the same order as for
    /// verifyCompressedProof. I.e. points (A, B, C) in compressed format.
    function compressProof(uint256[8] calldata proof)
    public view returns (uint256[4] memory compressed) {
        compressed[0] = compress_g1(proof[0], proof[1]);
        (compressed[2], compressed[1]) = compress_g2(proof[3], proof[2], proof[5], proof[4]);
        compressed[3] = compress_g1(proof[6], proof[7]);
    }

    /// Verify a Groth16 proof with compressed points.
    /// @notice Reverts with InvalidProof if the proof is invalid or
    /// with PublicInputNotInField the public input is not reduced.
    /// @notice There is no return value. If the function does not revert, the
    /// proof was successfully verified.
    /// @param compressedProof the points (A, B, C) in compressed format
    /// matching the output of compressProof.
    /// @param input the public input field elements in the scalar field Fr.
    /// Elements must be reduced.
    function verifyCompressedProof(
        uint256[4] calldata compressedProof,
        uint256[5] calldata input
    ) public view {
        uint256[24] memory pairings;

        {
            (uint256 Ax, uint256 Ay) = decompress_g1(compressedProof[0]);
            (uint256 Bx0, uint256 Bx1, uint256 By0, uint256 By1) = decompress_g2(compressedProof[2], compressedProof[1]);
            (uint256 Cx, uint256 Cy) = decompress_g1(compressedProof[3]);
            (uint256 Lx, uint256 Ly) = publicInputMSM(input);

            // Verify the pairing
            // Note: The precompile expects the F2 coefficients in big-endian order.
            // Note: The pairing precompile rejects unreduced values, so we won't check that here.
            // e(A, B)
            pairings[ 0] = Ax;
            pairings[ 1] = Ay;
            pairings[ 2] = Bx1;
            pairings[ 3] = Bx0;
            pairings[ 4] = By1;
            pairings[ 5] = By0;
            // e(C, -Œ¥)
            pairings[ 6] = Cx;
            pairings[ 7] = Cy;
            pairings[ 8] = DELTA_NEG_X_1;
            pairings[ 9] = DELTA_NEG_X_0;
            pairings[10] = DELTA_NEG_Y_1;
            pairings[11] = DELTA_NEG_Y_0;
            // e(Œ±, -Œ≤)
            pairings[12] = ALPHA_X;
            pairings[13] = ALPHA_Y;
            pairings[14] = BETA_NEG_X_1;
            pairings[15] = BETA_NEG_X_0;
            pairings[16] = BETA_NEG_Y_1;
            pairings[17] = BETA_NEG_Y_0;
            // e(L_pub, -Œ≥)
            pairings[18] = Lx;
            pairings[19] = Ly;
            pairings[20] = GAMMA_NEG_X_1;
            pairings[21] = GAMMA_NEG_X_0;
            pairings[22] = GAMMA_NEG_Y_1;
            pairings[23] = GAMMA_NEG_Y_0;

            // Check pairing equation.
            bool success;
            uint256[1] memory output;
            assembly ("memory-safe") {
                success := staticcall(gas(), PRECOMPILE_VERIFY, pairings, 0x300, output, 0x20)
            }
            if (!success || output[0] != 1) {
                // Either proof or verification key invalid.
                // We assume the contract is correctly generated, so the verification key is valid.
                revert ProofInvalid();
            }
        }
    }

    /// Verify an uncompressed Groth16 proof.
    /// @notice Reverts with InvalidProof if the proof is invalid or
    /// with PublicInputNotInField the public input is not reduced.
    /// @notice There is no return value. If the function does not revert, the
    /// proof was successfully verified.
    /// @param proof the points (A, B, C) in EIP-197 format matching the output
    /// of compressProof.
    /// @param input the public input field elements in the scalar field Fr.
    /// Elements must be reduced.
    function verifyProof(
        uint256[8] calldata proof,
        uint256[5] calldata input
    ) public view {
        (uint256 x, uint256 y) = publicInputMSM(input);

        // Note: The precompile expects the F2 coefficients in big-endian order.
        // Note: The pairing precompile rejects unreduced values, so we won't check that here.
        bool success;
        assembly ("memory-safe") {
            let f := mload(0x40) // Free memory pointer.

            // Copy points (A, B, C) to memory. They are already in correct encoding.
            // This is pairing e(A, B) and G1 of e(C, -Œ¥).
            calldatacopy(f, proof, 0x100)

            // Complete e(C, -Œ¥) and write e(Œ±, -Œ≤), e(L_pub, -Œ≥) to memory.
            // OPT: This could be better done using a single codecopy, but
            //      Solidity (unlike standalone Yul) doesn't provide a way to
            //      to do this.
            mstore(add(f, 0x100), DELTA_NEG_X_1)
            mstore(add(f, 0x120), DELTA_NEG_X_0)
            mstore(add(f, 0x140), DELTA_NEG_Y_1)
            mstore(add(f, 0x160), DELTA_NEG_Y_0)
            mstore(add(f, 0x180), ALPHA_X)
            mstore(add(f, 0x1a0), ALPHA_Y)
            mstore(add(f, 0x1c0), BETA_NEG_X_1)
            mstore(add(f, 0x1e0), BETA_NEG_X_0)
            mstore(add(f, 0x200), BETA_NEG_Y_1)
            mstore(add(f, 0x220), BETA_NEG_Y_0)
            mstore(add(f, 0x240), x)
            mstore(add(f, 0x260), y)
            mstore(add(f, 0x280), GAMMA_NEG_X_1)
            mstore(add(f, 0x2a0), GAMMA_NEG_X_0)
            mstore(add(f, 0x2c0), GAMMA_NEG_Y_1)
            mstore(add(f, 0x2e0), GAMMA_NEG_Y_0)

            // Check pairing equation.
            success := staticcall(gas(), PRECOMPILE_VERIFY, f, 0x300, f, 0x20)
            // Also check returned value (both are either 1 or 0).
            success := and(success, mload(f))
        }
        if (!success) {
            // Either proof or verification key invalid.
            // We assume the contract is correctly generated, so the verification key is valid.
            revert ProofInvalid();
        }
    }
}



================================================
FILE: contracts/Registrar.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {Point, RegisterProof} from "./types/Types.sol";
import {IRegistrationVerifier} from "./interfaces/verifiers/IRegistrationVerifier.sol";
import {UserAlreadyRegistered, InvalidChainId, InvalidSender, InvalidRegistrationHash, InvalidProof} from "./errors/Errors.sol";

// libraries
import {BabyJubJub} from "./libraries/BabyJubJub.sol";

/**
 * @title Registrar
 * @notice Contract for managing user registration in the privacy-preserving ERC system
 * @dev This contract handles:
 *      1. User registration with public keys
 *      2. Verification of registration proofs
 *
 * The Registrar is a critical component that:
 * - Associates Ethereum addresses with public keys for encrypted operations
 */
contract Registrar {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice The verifier contract used to validate registration proofs
    IRegistrationVerifier public registrationVerifier;

    /// @notice Mapping of user addresses to their public keys
    mapping(address userAddress => Point userPublicKey) public userPublicKeys;

    /// @notice Mapping of registration hashes to registration status
    /// @dev Used to prevent duplicate registrations
    mapping(uint256 registrationHash => bool isRegistered) public isRegistered;

    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /// @notice Emitted when a user is registered
    /// @param user Address of the user
    /// @param publicKey Public key of the user
    event Register(address indexed user, Point publicKey);

    ///////////////////////////////////////////////////
    ///                   Constructor               ///
    ///////////////////////////////////////////////////

    /**
     * @notice Initializes the Registrar contract
     * @param registrationVerifier_ Address of the registration verifier contract
     */
    constructor(address registrationVerifier_) {
        registrationVerifier = IRegistrationVerifier(registrationVerifier_);
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Registers a user with their public key
     * @param proof The zero-knowledge proof proving the validity of the registration
     * @dev This function:
     *      1. Verifies the sender matches the account in the proof
     *      2. Checks the chain ID matches
     *      3. Validates the registration hash
     *      4. Verifies the zero-knowledge proof
     *      5. Registers the user with their public key
     *
     * Requirements:
     * - Sender must match the account in the proof
     * - Chain ID must match
     * - Registration hash must be valid
     * - User must not be already registered
     * - Proof must be valid
     */
    function register(RegisterProof calldata proof) external {
        // extract public inputs
        uint256[5] memory input = proof.publicSignals;

        address account = address(uint160(input[2]));

        // check if the sender matches the account in the proof
        if (msg.sender != account) {
            revert InvalidSender();
        }

        // check if the chain ID matches
        if (block.chainid != input[3]) {
            revert InvalidChainId();
        }

        // check if the registration hash is valid
        uint256 registrationHash = input[4];
        if (registrationHash >= BabyJubJub.Q) {
            revert InvalidRegistrationHash();
        }

        // check if the user is already registered
        if (isRegistered[registrationHash] && isUserRegistered(account)) {
            revert UserAlreadyRegistered();
        }

        // Verify the proof
        _verifyProof(proof);

        _register(account, Point({x: input[0], y: input[1]}), registrationHash);
    }

    /**
     * @notice Checks if a user is registered
     * @param user The address of the user to check
     * @return bool True if the user is registered, false otherwise
     * @dev A user is considered registered if their public key is not the zero point (0,0)
     */
    function isUserRegistered(address user) public view returns (bool) {
        return userPublicKeys[user].x != 0 && userPublicKeys[user].y != 0;
    }

    /**
     * @notice Gets the public key of a user
     * @param user The address of the user
     * @return publicKey The public key of the user as a uint256 array
     * @dev Returns the x and y coordinates of the user's public key
     */
    function getUserPublicKey(
        address user
    ) public view returns (uint256[2] memory publicKey) {
        return [userPublicKeys[user].x, userPublicKeys[user].y];
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Registers a user with their public key
     * @param user The address of the user
     * @param publicKey The public key of the user
     * @param registrationHash The registration hash
     * @dev This function:
     *      1. Sets the user's public key
     *      2. Marks the registration hash as used
     *      3. Emits a Register event
     */
    function _register(
        address user,
        Point memory publicKey,
        uint256 registrationHash
    ) internal {
        userPublicKeys[user] = publicKey;
        isRegistered[registrationHash] = true;
        emit Register(user, publicKey);
    }

    /**
     * @notice Verifies a registration proof
     * @param proof_ The proof to verify
     * @dev This function:
     *      1. Extracts the proof points and public inputs
     *      2. Calls the verifier contract to verify the proof
     *      3. Reverts if the proof is invalid
     */
    function _verifyProof(RegisterProof calldata proof_) internal view {
        uint256[2] memory pointA_ = proof_.proofPoints.a;
        uint256[2][2] memory pointB_ = proof_.proofPoints.b;
        uint256[2] memory pointC_ = proof_.proofPoints.c;
        uint256[5] memory input = proof_.publicSignals;

        // Verify the proof
        bool verified_ = registrationVerifier.verifyProof(
            pointA_,
            pointB_,
            pointC_,
            input
        );

        if (!verified_) {
            revert InvalidProof();
        }
    }
}



================================================
FILE: contracts/auditor/AuditorManager.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem
pragma solidity 0.8.27;

import {Point} from "../types/Types.sol";
import {ZeroAddress} from "../errors/Errors.sol";

/**
 * @title AuditorManager
 * @notice Abstract contract that manages auditor-related functionality for encrypted ERC operations
 * @dev This contract is responsible for:
 *      1. Storing and managing the auditor's address and public key
 *      2. Providing access control for auditor-related operations
 *      3. Emitting events when auditor information changes
 *
 * The auditor is a crucial component in the encrypted ERC system that:
 * - Ensures compliance with regulatory requirements
 * - Provides oversight for private operations
 */
abstract contract AuditorManager {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice The address of the current auditor
    /// @dev This address is used to identify the auditor and for access control
    address public auditor = address(0);

    /// @notice The public key of the current auditor
    /// @dev This is used in zero-knowledge proofs to validate auditor signatures
    ///      The point (0,1) is considered invalid as it's the identity point in the elliptic curve
    Point public auditorPublicKey = Point({x: 0, y: 0});

    ///////////////////////////////////////////////////
    ///                    Events                   ///
    ///////////////////////////////////////////////////

    /**
     * @notice Emitted when the auditor's information is updated
     * @param oldAuditor The previous auditor's address
     * @param newAuditor The new auditor's address
     */
    event AuditorChanged(
        address indexed oldAuditor,
        address indexed newAuditor
    );

    ///////////////////////////////////////////////////
    ///                   Modifiers                 ///
    ///////////////////////////////////////////////////

    /**
     * @notice Ensures that an auditor is properly
     * @dev This modifier checks two conditions:
     *      1. The auditor's public key is valid (not the identity point)
     *      2. The auditor's address is not the zero address
     *
     * Requirements:
     * - Auditor public key must be set (not the identity point)
     * - Auditor address must be set (not zero address)
     */
    modifier onlyIfAuditorSet() {
        require(
            auditorPublicKey.x != 0 && auditorPublicKey.y != 1,
            "Auditor public key not set"
        );
        require(auditor != address(0), "Auditor not set");
        _;
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Checks if the auditor's public key is properly set
     * @return bool True if the auditor's public key is set and valid
     * @dev This function is used to verify if the contract is ready for
     *      operations that require auditor validation
     */
    function isAuditorKeySet() external view returns (bool) {
        return auditorPublicKey.x != 0 && auditorPublicKey.y != 1;
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Updates the auditor's information
     * @param newAuditor The address of the new auditor
     * @param publicKey The public key of the new auditor
     * @dev This function:
     *      1. Validates the new auditor's address
     *      2. Updates the auditor's information
     *      3. Emits an event to track the change
     *
     * Requirements:
     * - newAuditor must not be the zero address
     * - publicKey must be a valid point on the elliptic curve
     */
    function _updateAuditor(
        address newAuditor,
        uint256[2] memory publicKey
    ) internal {
        address oldAuditor = auditor;
        // check if the auditor is the zero address
        if (newAuditor == address(0)) {
            revert ZeroAddress();
        }

        auditor = newAuditor;
        auditorPublicKey = Point({x: publicKey[0], y: publicKey[1]});

        emit AuditorChanged(oldAuditor, newAuditor);
    }
}



================================================
FILE: contracts/errors/Errors.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

error UserAlreadyRegistered();
error UserNotRegistered();
error UnauthorizedAccess();
error AuditorKeyNotSet();
error InvalidProof();
error InvalidOperation();
error TransferFailed();
error UnknownToken();
error InvalidChainId();
error InvalidNullifier();
error InvalidSender();
error InvalidRegistrationHash();
error ZeroAddress();
error TokenBlacklisted(address token);



================================================
FILE: contracts/interfaces/IEncryptedERC.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IEncryptedERC {
    /**
     * @notice Sets the balance percentage for a user and token.
     * @param user User address
     * @param tokenId Token ID
     * @param pct Balance percentage array
     * @dev Only the registrar can set the balance percentage
     */
    function setUserBalancePCT(
        address user,
        uint256 tokenId,
        uint256[7] memory pct
    ) external;
}



================================================
FILE: contracts/interfaces/IRegistrar.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IRegistrar {
    /**
     * @dev Returns the public key of a user.
     * @param user Address of the user.
     * @return publicKey The public key of the user as an array of two uint256 values.
     */
    function getUserPublicKey(
        address user
    ) external view returns (uint256[2] memory publicKey);

    /**
     * @dev Returns true if the user is registered.
     * @param user Address of the user.
     * @return isRegistered True if the user is registered, false otherwise.
     */
    function isUserRegistered(address user) external view returns (bool);
}



================================================
FILE: contracts/interfaces/verifiers/IBurnVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IBurnVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[19] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/IMintVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IMintVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[24] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/IRegistrationVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IRegistrationVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[5] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/ITransferVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface ITransferVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[32] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/interfaces/verifiers/IWithdrawVerifier.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

interface IWithdrawVerifier {
    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[16] memory publicSignals_
    ) external view returns (bool verified_);
}



================================================
FILE: contracts/libraries/BabyJubJub.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

// Structs
import {Point, EGCT} from "../types/Types.sol";

/**
 * @dev BabyJubJub curve operations
 */
library BabyJubJub {
    // Curve parameters
    // E: A^2 + y^2 = 1 + Dx^2y^2 (mod Q)
    uint256 internal constant A = 168700;
    uint256 internal constant D = 168696;
    uint256 public constant Q =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    uint256 internal constant H =
        10944121435919637611123202872628637544274182200208017171849102093287904247808;
    uint256 internal constant R =
        2736030358979909402780800718157159386076813972158567259200215660948447373041;

    /**
     * @dev Subtract a BabyJubJub point from another BabyJubJub point
     * @param _point1 the point which will be subtracted from
     * @param _point2 point to subtract
     * @return result
     */
    function _sub(
        Point memory _point1,
        Point memory _point2
    ) public view returns (Point memory) {
        return _add(_point1, negate(_point2));
    }

    /**
     * @dev Add 2 points on BabyJubJub curve
     * Formulae for adding 2 points on a twisted Edwards curve:
     * x3 = (x1y2 + y1x2) / (1 + dx1x2y1y2)
     * y3 = (y1y2 - ax1x2) / (1 - dx1x2y1y2)
     * @param _point1 first point
     * @param _point2 second point
     * @return resulting point
     */
    function _add(
        Point memory _point1,
        Point memory _point2
    ) public view returns (Point memory) {
        uint256 x1x2 = mulmod(_point1.x, _point2.x, Q);
        uint256 y1y2 = mulmod(_point1.y, _point2.y, Q);

        uint256 dx1x2y1y2 = mulmod(D, mulmod(x1x2, y1y2, Q), Q);

        uint256 x3Num = addmod(
            mulmod(_point1.x, _point2.y, Q),
            mulmod(_point1.y, _point2.x, Q),
            Q
        );
        uint256 y3Num = submod(y1y2, mulmod(A, x1x2, Q));

        return
            Point({
                x: mulmod(x3Num, invmod(addmod(1, dx1x2y1y2, Q)), Q),
                y: mulmod(y3Num, invmod(submod(1, dx1x2y1y2)), Q)
            });
    }

    /**
     * @dev Multiply a BabyJubJub point by a scalar
     * Use the double and add algorithm
     * @param _point point be multiplied by a scalar
     * @param _scalar scalar value
     * @return resulting point
     */
    function scalarMultiply(
        Point memory _point,
        uint256 _scalar
    ) public view returns (Point memory) {
        // Initial scalar remainder
        uint256 remaining = _scalar % R;

        // Copy initial point so that we don't mutate it
        Point memory initial = _point;

        // Initialize result
        Point memory result = Point({x: 0, y: 1});

        // Loop while remainder is greater than 0
        while (remaining != 0) {
            // If the right-most binary digit is 1 (number is odd) add initial point to result
            if ((remaining & 1) != 0) {
                result = _add(result, initial);
            }

            // Double initial point
            initial = double(initial);

            // Shift bits to the right
            remaining = remaining >> 1;
        }

        return result;
    }

    /**
     *
     * @param _publicKey Public Key that will be used in encryption
     * @param _msg Message in scalar form to be encrypted
     */
    function elGamalEncryption(
        Point memory _publicKey,
        uint256 _msg
    ) public view returns (EGCT memory) {
        uint256 random = 1;
        Point memory b8 = base8();

        Point memory c1 = scalarMultiply(b8, random);
        Point memory pkr = scalarMultiply(_publicKey, random);
        Point memory pMsg = scalarMultiply(b8, _msg);

        Point memory c2 = _add(pkr, pMsg);

        return EGCT({c1: c1, c2: c2});
    }

    // elgamal encryption with a given message
    function encrypt(
        Point memory _publicKey,
        uint256 _msg
    ) public view returns (EGCT memory) {
        return elGamalEncryption(_publicKey, _msg);
    }

    /**
     * @dev Default generator
     */
    function base8() public pure returns (Point memory) {
        return
            Point({
                x: 5299619240641551281634865583518297030282874472190772894086521144482721001553,
                y: 16950150798460657717958625567821834550301663161624707787222815936182638968203
            });
    }

    /**
     * @dev Double a point on BabyJubJub curve
     * @param _p point to double
     * @return doubled point
     */
    function double(Point memory _p) internal view returns (Point memory) {
        return _add(_p, _p);
    }

    /**
     * @dev Compute modular inverse of a number
     * @param _a the value to be inverted in mod Q
     */
    function invmod(uint256 _a) internal view returns (uint256) {
        // We can use Euler's theorem instead of the extended Euclidean algorithm
        // Since m = Q and Q is prime we have: a^-1 = a^(m - 2) (mod m)
        return
            expmod(
                _a,
                0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffffff
            );
    }

    /**
     * @dev Exponentiation modulo Q
     * @param _base the base of the exponentiation
     * @param _exponent the exponent
     * @return result
     */
    function expmod(
        uint256 _base,
        uint256 _exponent
    ) internal view returns (uint256) {
        uint256 result;

        // solhint-disable-next-line no-inline-assembly
        assembly {
            let
                localQ
            := 0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001
            let memPtr := mload(0x40)
            mstore(memPtr, 0x20) // Length of base _b
            mstore(add(memPtr, 0x20), 0x20) // Length of exponent _e
            mstore(add(memPtr, 0x40), 0x20) // Length of modulus Q
            mstore(add(memPtr, 0x60), _base) // Base _b
            mstore(add(memPtr, 0x80), _exponent) // Exponent _e
            mstore(add(memPtr, 0xa0), localQ) // Modulus Q

            // The bigModExp precompile is at 0x05
            let success := staticcall(gas(), 0x05, memPtr, 0xc0, memPtr, 0x20)
            switch success
            case 0 {
                revert(0x0, 0x0)
            }
            default {
                result := mload(memPtr)
            }
        }

        return result;
    }

    /**
     * @dev Negate a BabyJubJub point
     * @param _point point to negate
     * @return p = -(_p)
     */
    function negate(Point memory _point) internal pure returns (Point memory) {
        return Point({x: Q - _point.x, y: _point.y});
    }

    /**
     * @dev Modular subtract (mod n).
     * @param _a The first number
     * @param _b The number to be subtracted
     * @return result
     */
    function submod(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return addmod(_a, Q - _b, Q);
    }
}



================================================
FILE: contracts/prod/BurnVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract BurnVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 20500123508036250241732436039045855491142840147741568076165900093824331281316;
    uint256 constant deltax2 = 17951494579165795533532847235529611089521789751209994758862962564682445617412;
    uint256 constant deltay1 = 5834387578477044714458263369208539598498352288497332887384107712494722576583;
    uint256 constant deltay2 = 15268404118840851015046775717571916089738924216088942953684197626467386210997;

    
    uint256 constant IC0x = 11786268729161045937652164714990691490770027441460947932012316631529733292940;
    uint256 constant IC0y = 9581132102330540074693305331254898451475664668584360899026097918947512977366;
    
    uint256 constant IC1x = 914822366018062648285730205402683692599853766866159406178623354781735659599;
    uint256 constant IC1y = 8553697750564092712813746981763759579862680918228138684307182805192139236520;
    
    uint256 constant IC2x = 17908121343774581376092646765067170799970925894057937307165335210962871507135;
    uint256 constant IC2y = 6739483966006459958647545663755815825611388802168101513616676265213547687212;
    
    uint256 constant IC3x = 143359351657650308208480824138891765346610788279862658068353643164441844115;
    uint256 constant IC3y = 1688658345879791302522420761526578526163188876279486731177660400972657648742;
    
    uint256 constant IC4x = 18309718863517978042660293994537440591428742486455947599492279373595114219500;
    uint256 constant IC4y = 3543366565414834921232477531525858456841505305202548147687587105557694958104;
    
    uint256 constant IC5x = 2179968961403977829543241099157331775731416225717055667057125732267317798366;
    uint256 constant IC5y = 14579564811228528586131093319854876770716135551807922280189147940915226636750;
    
    uint256 constant IC6x = 12128037778350917133400346467296434075039661406517118820895803963198786951800;
    uint256 constant IC6y = 12810377956478161485381774828600271058686148075894654796038454545352947160776;
    
    uint256 constant IC7x = 9593873745453136272405518724864540111195676150385738265238288297101461351389;
    uint256 constant IC7y = 18140226050853380485925948980064648409518762214351351505488025177062130412015;
    
    uint256 constant IC8x = 5344462067192893979551241744484644250693230460027867247351105468329395690915;
    uint256 constant IC8y = 2435072349815413116277252545573449685604686772441816336584542983683379409914;
    
    uint256 constant IC9x = 15867459271796662494529143386082298582993967528167005628586571617103329782767;
    uint256 constant IC9y = 1031216327552632558464991513003642749331915406636029936411939647607628738052;
    
    uint256 constant IC10x = 11710830742293210758218398274130454937288722189717294688374583983853957500247;
    uint256 constant IC10y = 18095934287133238566717320534781010028273178446261522698705303702525394211898;
    
    uint256 constant IC11x = 5451223849987641096615559250356903902465481513182931751171182631482949381911;
    uint256 constant IC11y = 6791511973211811945927811502706661666842895298126970397039460184655612620453;
    
    uint256 constant IC12x = 12576390828389735220141209658777087276380270144557056528857559882798323629447;
    uint256 constant IC12y = 19191122649652045476856774223103624470066531140701020233373995430155185392289;
    
    uint256 constant IC13x = 3208115974817470421120218397409974778673673537533531169452261659740974257278;
    uint256 constant IC13y = 1563495302870822079389756646952495877672019554537528044396737285924026906103;
    
    uint256 constant IC14x = 15803266454704411593372706477399336420388826076293995292354385277988446601281;
    uint256 constant IC14y = 14061261779941396671642560007918916383355024387096318566313366433584709024499;
    
    uint256 constant IC15x = 1473892103720096233092115851822223251992401285317974909943916318348184767365;
    uint256 constant IC15y = 3670020837101119839757171869792531530222770849398108379916390350369899561438;
    
    uint256 constant IC16x = 8909686676336745813415338575513600352109241710831786249590248291624151036333;
    uint256 constant IC16y = 4561980313802046241453616743996179799784948333408123666456078054975402233930;
    
    uint256 constant IC17x = 9644420134970614917918276763660740255881705883613568754990717610748161142338;
    uint256 constant IC17y = 6057246608400625128574045490366205109267182635495031148770746354579442521952;
    
    uint256 constant IC18x = 3478588600416828411411103709929443364350875935722379535054531373495869197302;
    uint256 constant IC18y = 14312139497598775136457694532354226575027823182198251149840842365373433448408;
    
    uint256 constant IC19x = 16478469522390352876826812932849485876750021274758447084770343652372421581875;
    uint256 constant IC19y = 5525105724620928136283079314841429313946285054350434613540639344526895834484;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[19] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ‚àà F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/MintVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract MintVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 6506135815943976343670204718908252778100436948044695952269504614489235747522;
    uint256 constant deltax2 = 12917761706367159448552669332158549008424338800753983174002760426851264899916;
    uint256 constant deltay1 = 21054759061354342502671069523347944444365476693281335142489232816218318279843;
    uint256 constant deltay2 = 921807516250667254679639816527091672038652453691410152532432179406742682074;

    
    uint256 constant IC0x = 10121904041541460154551260390411876526139574666949788432677764574044027742051;
    uint256 constant IC0y = 6395114105467352463516423639828272877440036954754220055848039516989817256674;
    
    uint256 constant IC1x = 5586762719201810155133862083740714325655748243483738877755810028542797644739;
    uint256 constant IC1y = 9387879719287370926595730382657598610335084850078203728936667449453246554359;
    
    uint256 constant IC2x = 19420434315212518030589186167981244595406343548992012458488730749825996100239;
    uint256 constant IC2y = 3482657374383353276279298693752239555763142972311841530862645391131143881873;
    
    uint256 constant IC3x = 21667521945257749121492909465236139091096077691835364325355606431375269082282;
    uint256 constant IC3y = 12156175257782822331801928906256367913221851960540994586932487722549923413345;
    
    uint256 constant IC4x = 16828357126590671631798447095302651492589140460428270542352941484237941156483;
    uint256 constant IC4y = 3785759973408012513975276660945174958105045591429994983968533282503371539336;
    
    uint256 constant IC5x = 21244321325522105477060254124915502034148248502931960755663601081500950076300;
    uint256 constant IC5y = 14687177467139662957844534389099557537735007475047254307829149459337997284150;
    
    uint256 constant IC6x = 21404447565616225355770439075122853382066792760583316781611395109968504614761;
    uint256 constant IC6y = 3777910210505077428584254669424713454396973987622630869249106067166590299357;
    
    uint256 constant IC7x = 5644690004940482546460856256670502914882531219591199090065888636589494736039;
    uint256 constant IC7y = 16345970805899097192278870928687506101715169625232631539981164972434652655022;
    
    uint256 constant IC8x = 16593367704572145491497340027058421406291597779030039134573703992464863830646;
    uint256 constant IC8y = 19275772679724763916884927502599327291258343548738975909520313332884772129528;
    
    uint256 constant IC9x = 18338635157990571739660769292280252719367811451620901782236478705200001456515;
    uint256 constant IC9y = 12580365946981294431067603413481570211192375767222833113101936660967490853342;
    
    uint256 constant IC10x = 19880773599746588943745194809450382516728304373879942615347513263173728275196;
    uint256 constant IC10y = 128548754750873577554444615682746852358621588347676854260473817368140033519;
    
    uint256 constant IC11x = 6476719107464483530164368276818653110527411272303410163053488615734788766586;
    uint256 constant IC11y = 13331539055996208679678758084320772815107338352425913859433335410845899223811;
    
    uint256 constant IC12x = 17393436839515851750885277096607160266036302533767007170590322671069079326483;
    uint256 constant IC12y = 17336491525577930609097646312281682071744277090982994234361498925040239739760;
    
    uint256 constant IC13x = 14059139663320156276001577403575266145309546640724899667521029234074221180403;
    uint256 constant IC13y = 5963232262834884334488206091864494084893490405377454589196552297795638041488;
    
    uint256 constant IC14x = 13813470258321934033051704279698252148783024920181797002453328082368105474789;
    uint256 constant IC14y = 19760333797981660449134124218356560284106192590380149679255903109561686546313;
    
    uint256 constant IC15x = 11858117840318587547791069185551586430435948995333725070770764697634898894992;
    uint256 constant IC15y = 16621799951101200543458233987158204772158254202860685491749532125765298740749;
    
    uint256 constant IC16x = 13584356250500421508084566767718022822120888453124821650989966819848963029582;
    uint256 constant IC16y = 21121442557480691564262522113115528175177021588076736568194595390503813944019;
    
    uint256 constant IC17x = 4326226245481542040767942040881999777137473163343274779447151141265545792486;
    uint256 constant IC17y = 21183580388477113613358837765893868421637670220571970210021457037640835173809;
    
    uint256 constant IC18x = 2704745980008452624320271214496436840853635777289985169457654318338905712053;
    uint256 constant IC18y = 5498942242451865915343845370075402718280213375705928811712272696867696623122;
    
    uint256 constant IC19x = 18021323881247358977456866382503667963535769536490271165761105041938333860259;
    uint256 constant IC19y = 15056011404667104875167366478630077579580289596849055349190254216447781136049;
    
    uint256 constant IC20x = 2428670635260390602473903592482933886252233168437493591205178349351514000281;
    uint256 constant IC20y = 862350060646299115005420081148519933461348146447694025974629367115211964519;
    
    uint256 constant IC21x = 20557922324599650576215164022162024912213509843003042307546636524489843547931;
    uint256 constant IC21y = 1061522392679391742130691544383963509531829000498209937975610885874122363387;
    
    uint256 constant IC22x = 9114256858842496488535186312068922854228150055952688114444862375910254881995;
    uint256 constant IC22y = 20868937436899006110617091404782344741103549613810098330797141428653796030423;
    
    uint256 constant IC23x = 392332888128429361037702708407695212788446855280618226506466973682041689462;
    uint256 constant IC23y = 10986782868722900357976121669302445297980271976862420955075995610762868745084;
    
    uint256 constant IC24x = 12335561474727855982123382035622477594232361573497391299243618736725476900631;
    uint256 constant IC24y = 20340286770637453607265533856091115758478742882346824576410498508028320071146;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[24] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ‚àà F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/RegistrationVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract RegistrationVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 19753714125923452630385433581442722093941065264298048276246815338797167448169;
    uint256 constant deltax2 = 2824093012045694268556486522753590084359236940213189502690301706344424715581;
    uint256 constant deltay1 = 18067530836866733450125362089378459710977233400131368676354166923678178030850;
    uint256 constant deltay2 = 12986835757414062294165220819491853575831232959693796161862995405626568533639;

    
    uint256 constant IC0x = 5049073754175979375715331231494813434614104647476713784192278874636518287456;
    uint256 constant IC0y = 13973039660095243213304729343482928815131903560133937124822026621516335683252;
    
    uint256 constant IC1x = 6960760860997719127050640389023071189120419160885047633543132031266205842967;
    uint256 constant IC1y = 14311210142759362992805316832152765774097518712372467130307901891389375007789;
    
    uint256 constant IC2x = 14970325264892984291437720194401230916657388050759523602370378142660744831477;
    uint256 constant IC2y = 15860538555168123807647719982845297214031403618163443664157964964439662885432;
    
    uint256 constant IC3x = 9095633778879314058949553908878900274830732566924382454865365752356228820208;
    uint256 constant IC3y = 872555237120135122336016443589602918886936394020805627011933688108936774726;
    
    uint256 constant IC4x = 16383214040587918206822141493152567743771449527138865305823970747014581995205;
    uint256 constant IC4y = 15807972914519003321398888297328267389104135252699104466520087670194802499103;
    
    uint256 constant IC5x = 19865793340402973866436804410911022538640660662316164831277333170166538152800;
    uint256 constant IC5y = 1466380730966029920868782474285618825793197367831481952454164420798011324299;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[5] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ‚àà F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/TransferVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract TransferVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 3763145489265154227084511171694601212878632438189047805035774181671200721579;
    uint256 constant deltax2 = 19123758782558680960137049284286660834755919438304772090386326942336280507607;
    uint256 constant deltay1 = 2055449651368268424611099662557640196156614451951214953872156041652270884888;
    uint256 constant deltay2 = 4894238513642303098263860622238471992887790214981922367145986542927713649242;

    
    uint256 constant IC0x = 10534947708174160215201992304779041355498470735561003306499717122566742770626;
    uint256 constant IC0y = 977905257499899758791217822505228003462337033122097368830210745360601555342;
    
    uint256 constant IC1x = 3280711512314934753992505317526746468153049821370324146752079659712174232300;
    uint256 constant IC1y = 9336028462433315123867796333994191785575550026414826950323988687234821492567;
    
    uint256 constant IC2x = 15162904757480315297547642942646568889101029164132171480256830884259150251283;
    uint256 constant IC2y = 5543236365374398176471504758808152977042933422387633848583378303299793270756;
    
    uint256 constant IC3x = 6084599581719503190421548874454410642759752303455385862653438619168850972257;
    uint256 constant IC3y = 18221408640134590893699663063879232072826509494821669770579541736533993832423;
    
    uint256 constant IC4x = 13515294784299896617263177420364080405138679960108803709127908717931838641125;
    uint256 constant IC4y = 18537954088397403593567974022084871913708328503334967617431436055023979447391;
    
    uint256 constant IC5x = 18052165982957660268255521614825223786335394780677647206458385784232406504157;
    uint256 constant IC5y = 15194585058280412021740640814141568454746627730826424655106679430538982053654;
    
    uint256 constant IC6x = 6795673837897345581582685299965371845759418273539377917021912839836254998739;
    uint256 constant IC6y = 21657993441803516491832636271681043591945604671357149970048825080204553686618;
    
    uint256 constant IC7x = 11289069591450532499401972724447572002376453520281915368481681110785600567292;
    uint256 constant IC7y = 11928539623033527208857415982521538988739084305734749009299860340216923817607;
    
    uint256 constant IC8x = 21069306450658538733134282147277445263698906490240400327689099847099016892805;
    uint256 constant IC8y = 17386225215792739261329655602621235879743955668381844924635942683420074576174;
    
    uint256 constant IC9x = 14345437456753227245495940686700720956058390526322202366808609527984033660993;
    uint256 constant IC9y = 20783457650276182735214466418096310752840639854110597710747660731724327511323;
    
    uint256 constant IC10x = 4486441340824192164364882510367580608217147444088109552210786362403055241932;
    uint256 constant IC10y = 16553383197162304205323300390384875515644589603157855319848881923653657055218;
    
    uint256 constant IC11x = 7299849271075286253602519481881832740498497504048928918662655218108429284825;
    uint256 constant IC11y = 21860902462897801250346538563498742432578812847135047747638191825760100188844;
    
    uint256 constant IC12x = 20812311364493619358550828916571084941809811622004047558332288367068444292636;
    uint256 constant IC12y = 12016931719373400562450857278580603432222260403491989130190760226223433669838;
    
    uint256 constant IC13x = 5497135883066110411842507436361453534364438777740194801977407015457789050083;
    uint256 constant IC13y = 960289848958742655061746467902157315103658957325800360115467733778920704760;
    
    uint256 constant IC14x = 5231929274251912956972062967045818685875910122905492872577246977634648737843;
    uint256 constant IC14y = 2405680064306334170931852015314781533305421897621973941278348820986549273557;
    
    uint256 constant IC15x = 14432423838507076163732475853088150200901869051870980078541847122928808702858;
    uint256 constant IC15y = 13162477912034036392091090217125050953003275307601447359448369192560307791075;
    
    uint256 constant IC16x = 6035380084134788387796489655621652133939237219692536713085830198890102531157;
    uint256 constant IC16y = 2399413675745655961934247765244583346698339793807331712093749883838255391396;
    
    uint256 constant IC17x = 1755840344064269003982904724784588829875883176859314530482477354204358128073;
    uint256 constant IC17y = 2254035658088032093438783815005800506175183609989063203400053587352866305963;
    
    uint256 constant IC18x = 10798890848385583150817432575812471927781281538956290209396088794995757251699;
    uint256 constant IC18y = 17954866604704083608550796134404236420626288308545111154506695506614087706302;
    
    uint256 constant IC19x = 16347505387353659907142234702135154337293088908179815677326286365566466652892;
    uint256 constant IC19y = 8145400935245335001708439352534792707071085106081878093341920760316939810339;
    
    uint256 constant IC20x = 1675146216777597460950545026188423914140684419320163593588767283439513220964;
    uint256 constant IC20y = 3350896492191726464487860464991880712916569207980460035951208489640794805493;
    
    uint256 constant IC21x = 14963360443843679002951981438607054782948196458205149005110445616986857962149;
    uint256 constant IC21y = 5453682123596332752358242170390357649813170313370080322693195792615766005582;
    
    uint256 constant IC22x = 15857139261281078612816698520673496528634524033018907015066869560007114561368;
    uint256 constant IC22y = 1980632957785357477112204530352463186795117003870653324765557649080191593069;
    
    uint256 constant IC23x = 16478788219117512612181000397725550334291930466463033672428118170129909755975;
    uint256 constant IC23y = 448496014898525130300582250347934155241571361910686004171961088395557906873;
    
    uint256 constant IC24x = 1666825517524796314004984207461413135984918930374439646195676102947777182322;
    uint256 constant IC24y = 4231769516076965497747593863600552237823540573882692739018851158660080939768;
    
    uint256 constant IC25x = 3076619425752586210204729303861073992338095413231945893603783564036991027253;
    uint256 constant IC25y = 18163258048301667325957382686787210971933697470347155712452125397431467657627;
    
    uint256 constant IC26x = 12240984649194028123658663640999248201069935674255565459899301410323450592735;
    uint256 constant IC26y = 7409006959659622318645744477945350299438380296542336739366936950900796739795;
    
    uint256 constant IC27x = 14527565647042473833164468956000362795519314198262866225352631554103417406048;
    uint256 constant IC27y = 19163038429636451765415902370901493252440686868311522712756801834049736087286;
    
    uint256 constant IC28x = 4563064787502578607504522503795653524780441771903390561095040321594991012805;
    uint256 constant IC28y = 17132961897233615551711030277418083026528303676258815957139396120116493761491;
    
    uint256 constant IC29x = 10825384216191058605866379876945565560465943245071973007006264312285398033060;
    uint256 constant IC29y = 21577743268709413526652653885555866375927505893806393223914213433533358336358;
    
    uint256 constant IC30x = 6397191691971602863357148514208654665119261190406272901198661597143240375;
    uint256 constant IC30y = 19034368636483100848266322777417046441872774162624857636955426992047727086319;
    
    uint256 constant IC31x = 13887187887323344570981409187274970320617448786085046258948210932080686653886;
    uint256 constant IC31y = 18715879836330833238341482186679228139561235361790447129420164142460558259244;
    
    uint256 constant IC32x = 11249333327764660601508194401900817731177098928541819675032435010243826533510;
    uint256 constant IC32y = 18594519484247875970157793842670472272992161543336964034550143549078316481776;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[32] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                
                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))
                
                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))
                
                g1_mulAccC(_pVk, IC19x, IC19y, calldataload(add(pubSignals, 576)))
                
                g1_mulAccC(_pVk, IC20x, IC20y, calldataload(add(pubSignals, 608)))
                
                g1_mulAccC(_pVk, IC21x, IC21y, calldataload(add(pubSignals, 640)))
                
                g1_mulAccC(_pVk, IC22x, IC22y, calldataload(add(pubSignals, 672)))
                
                g1_mulAccC(_pVk, IC23x, IC23y, calldataload(add(pubSignals, 704)))
                
                g1_mulAccC(_pVk, IC24x, IC24y, calldataload(add(pubSignals, 736)))
                
                g1_mulAccC(_pVk, IC25x, IC25y, calldataload(add(pubSignals, 768)))
                
                g1_mulAccC(_pVk, IC26x, IC26y, calldataload(add(pubSignals, 800)))
                
                g1_mulAccC(_pVk, IC27x, IC27y, calldataload(add(pubSignals, 832)))
                
                g1_mulAccC(_pVk, IC28x, IC28y, calldataload(add(pubSignals, 864)))
                
                g1_mulAccC(_pVk, IC29x, IC29y, calldataload(add(pubSignals, 896)))
                
                g1_mulAccC(_pVk, IC30x, IC30y, calldataload(add(pubSignals, 928)))
                
                g1_mulAccC(_pVk, IC31x, IC31y, calldataload(add(pubSignals, 960)))
                
                g1_mulAccC(_pVk, IC32x, IC32y, calldataload(add(pubSignals, 992)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ‚àà F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            
            checkField(calldataload(add(_pubSignals, 512)))
            
            checkField(calldataload(add(_pubSignals, 544)))
            
            checkField(calldataload(add(_pubSignals, 576)))
            
            checkField(calldataload(add(_pubSignals, 608)))
            
            checkField(calldataload(add(_pubSignals, 640)))
            
            checkField(calldataload(add(_pubSignals, 672)))
            
            checkField(calldataload(add(_pubSignals, 704)))
            
            checkField(calldataload(add(_pubSignals, 736)))
            
            checkField(calldataload(add(_pubSignals, 768)))
            
            checkField(calldataload(add(_pubSignals, 800)))
            
            checkField(calldataload(add(_pubSignals, 832)))
            
            checkField(calldataload(add(_pubSignals, 864)))
            
            checkField(calldataload(add(_pubSignals, 896)))
            
            checkField(calldataload(add(_pubSignals, 928)))
            
            checkField(calldataload(add(_pubSignals, 960)))
            
            checkField(calldataload(add(_pubSignals, 992)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/prod/WithdrawVerifier.sol
================================================
// SPDX-License-Identifier: GPL-3.0
/*
    Copyright 2021 0KIMS association.

    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).

    snarkJS is a free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    snarkJS is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
    License for more details.

    You should have received a copy of the GNU General Public License
    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.
*/

pragma solidity >=0.7.0 <0.9.0;

contract WithdrawVerifier {
    // Scalar field size
    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Base field size
    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key data
    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 constant deltax1 = 17937261609492175473978423283366042492782788118934277743325590061927472686823;
    uint256 constant deltax2 = 9134393277137786117877602562175203472042554058536880581948679621094751253663;
    uint256 constant deltay1 = 21830579691680039608885512644157042138865859432216493093304779889887319651703;
    uint256 constant deltay2 = 13560247966092290370160513680671248860780213214350811711788627488150106599867;

    
    uint256 constant IC0x = 17592896514411238838534259943087906039445412467749501855660552694930011809103;
    uint256 constant IC0y = 12732983330708765219970549274392016128270173019293005848551474757324971194427;
    
    uint256 constant IC1x = 4884577932082347864149139524102040008488705064603684844915539314596644874132;
    uint256 constant IC1y = 5456447315604083878474265800827509892021228387863831389892962189069605516459;
    
    uint256 constant IC2x = 17313454373712045907554165434725963402117845429222578159130609582778779362163;
    uint256 constant IC2y = 4407461008783085705651216674025467181197484228135456843989535495240785812495;
    
    uint256 constant IC3x = 10893636774628876142899763192646905724708189468282917758613650147010478133301;
    uint256 constant IC3y = 148896310776292842756025446759984436974180847194558332931999839598427070960;
    
    uint256 constant IC4x = 10775675593870925743575084889624246391515781987722804772444693341240701433005;
    uint256 constant IC4y = 21091396295200083161363697039830865943762788335711072967082811732416412142212;
    
    uint256 constant IC5x = 3277805223442060778292405741942548007218490041051348547437304074109624107356;
    uint256 constant IC5y = 14423944753390168508001610935122911632893435927783118919600891838924075393335;
    
    uint256 constant IC6x = 16279740598746831017838829127065220413108847820004536437353222843036288927209;
    uint256 constant IC6y = 11934056246616513677892280054066225650223628502415902228226616908265848867449;
    
    uint256 constant IC7x = 5071131858486439523644545889310168311903353944707113398976996997278587799687;
    uint256 constant IC7y = 11022965843210062064457659632129711893317662131236104884153566306811626505122;
    
    uint256 constant IC8x = 19131780283367531273448020668619041357172962162156115675741827445246630873287;
    uint256 constant IC8y = 10224436589841763650559926912214172567856653421053590774767009207269607380898;
    
    uint256 constant IC9x = 9015890207964856811111785067351720194541561850029096381425406768947368358563;
    uint256 constant IC9y = 6047643904429654109574184105636835293535463759429215740849034643735922891159;
    
    uint256 constant IC10x = 14203417831592538293633573944212232646895161398477212007798306234115933198031;
    uint256 constant IC10y = 16402598342815946882326203254821041228554468765346033642071484587006914175418;
    
    uint256 constant IC11x = 20547058030012031602382050197843576579725635037139342207584317836070120910810;
    uint256 constant IC11y = 18032163858711245709516724511475426102219042616668426511217798974437856519723;
    
    uint256 constant IC12x = 148439843878200889608411203087042067351611646430696078100079098168514978714;
    uint256 constant IC12y = 9307113381205316554384865850704068163340346564569932871492676068849222362101;
    
    uint256 constant IC13x = 21753481289618352374517009260504147501427757590648179575845005895425333005720;
    uint256 constant IC13y = 15435923224398640375717587240417911857458317269020496236194087111795302601904;
    
    uint256 constant IC14x = 15556836099875422007583907774078621468033908465380872159150755233143098695951;
    uint256 constant IC14y = 1129744811704326861736580949783332840905388382080396668503461990830533174097;
    
    uint256 constant IC15x = 13442230315665714018082790733663853073869607935268797374915472095839891294991;
    uint256 constant IC15y = 6217288894318109502763318183559473125294772219565374069029777927475585687108;
    
    uint256 constant IC16x = 13992512973627636194543618755294557224102658899504040367095379192332931057711;
    uint256 constant IC16y = 5489859536562727184655955989301069690715491550780438666774255315815483859767;
    
 
    // Memory data
    uint16 constant pVk = 0;
    uint16 constant pPairing = 128;

    uint16 constant pLastMem = 896;

    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[16] calldata _pubSignals) public view returns (bool) {
        assembly {
            function checkField(v) {
                if iszero(lt(v, r)) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }
            
            // G1 function to multiply a G1 value(x,y) to value in an address
            function g1_mulAccC(pR, x, y, s) {
                let success
                let mIn := mload(0x40)
                mstore(mIn, x)
                mstore(add(mIn, 32), y)
                mstore(add(mIn, 64), s)

                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }

                mstore(add(mIn, 64), mload(pR))
                mstore(add(mIn, 96), mload(add(pR, 32)))

                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)

                if iszero(success) {
                    mstore(0, 0)
                    return(0, 0x20)
                }
            }

            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {
                let _pPairing := add(pMem, pPairing)
                let _pVk := add(pMem, pVk)

                mstore(_pVk, IC0x)
                mstore(add(_pVk, 32), IC0y)

                // Compute the linear combination vk_x
                
                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))
                
                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))
                
                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))
                
                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))
                
                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))
                
                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))
                
                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))
                
                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))
                
                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))
                
                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))
                
                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))
                
                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))
                
                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))
                
                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))
                
                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))
                
                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))
                

                // -A
                mstore(_pPairing, calldataload(pA))
                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))

                // B
                mstore(add(_pPairing, 64), calldataload(pB))
                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))
                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))
                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))

                // alpha1
                mstore(add(_pPairing, 192), alphax)
                mstore(add(_pPairing, 224), alphay)

                // beta2
                mstore(add(_pPairing, 256), betax1)
                mstore(add(_pPairing, 288), betax2)
                mstore(add(_pPairing, 320), betay1)
                mstore(add(_pPairing, 352), betay2)

                // vk_x
                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))
                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))


                // gamma2
                mstore(add(_pPairing, 448), gammax1)
                mstore(add(_pPairing, 480), gammax2)
                mstore(add(_pPairing, 512), gammay1)
                mstore(add(_pPairing, 544), gammay2)

                // C
                mstore(add(_pPairing, 576), calldataload(pC))
                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))

                // delta2
                mstore(add(_pPairing, 640), deltax1)
                mstore(add(_pPairing, 672), deltax2)
                mstore(add(_pPairing, 704), deltay1)
                mstore(add(_pPairing, 736), deltay2)


                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)

                isOk := and(success, mload(_pPairing))
            }

            let pMem := mload(0x40)
            mstore(0x40, add(pMem, pLastMem))

            // Validate that all evaluations ‚àà F
            
            checkField(calldataload(add(_pubSignals, 0)))
            
            checkField(calldataload(add(_pubSignals, 32)))
            
            checkField(calldataload(add(_pubSignals, 64)))
            
            checkField(calldataload(add(_pubSignals, 96)))
            
            checkField(calldataload(add(_pubSignals, 128)))
            
            checkField(calldataload(add(_pubSignals, 160)))
            
            checkField(calldataload(add(_pubSignals, 192)))
            
            checkField(calldataload(add(_pubSignals, 224)))
            
            checkField(calldataload(add(_pubSignals, 256)))
            
            checkField(calldataload(add(_pubSignals, 288)))
            
            checkField(calldataload(add(_pubSignals, 320)))
            
            checkField(calldataload(add(_pubSignals, 352)))
            
            checkField(calldataload(add(_pubSignals, 384)))
            
            checkField(calldataload(add(_pubSignals, 416)))
            
            checkField(calldataload(add(_pubSignals, 448)))
            
            checkField(calldataload(add(_pubSignals, 480)))
            

            // Validate all evaluations
            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)

            mstore(0, isValid)
             return(0, 0x20)
         }
     }
 }



================================================
FILE: contracts/tokens/FeeERC20.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {SimpleERC20} from "./SimpleERC20.sol";

/**
 * @title FeeERC20
 * @dev ERC20 token with a fee mechanism for testing
 */
contract FeeERC20 is SimpleERC20 {
    uint256 public feeRate;
    address public feeCollector;

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimal,
        uint256 feeRates,
        address feeCollectors
    ) SimpleERC20(name, symbol, decimal) {
        feeRate = feeRates;
        feeCollector = feeCollectors;
    }

    /**
     * @dev Override transferFrom to apply a fee
     * @param sender The address to transfer from
     * @param recipient The address to transfer to
     * @param amount The amount to transfer
     * @return A boolean that indicates if the operation was successful
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = _msgSender();

        // Calculate fee
        uint256 fee = (amount * feeRate) / 100;
        uint256 amountAfterFee = amount - fee;

        // Deduct allowance
        _spendAllowance(sender, spender, amount);

        // Transfer amount after fee to recipient
        _transfer(sender, recipient, amountAfterFee);

        // Transfer fee to fee collector
        if (fee > 0) {
            _transfer(sender, feeCollector, fee);
        }

        return true;
    }
}



================================================
FILE: contracts/tokens/SimpleERC20.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract SimpleERC20 is ERC20 {
    // token decimals
    uint8 public decimals_;
    
    // Faucet functionality
    uint256 public constant FAUCET_AMOUNT = 1000 * 10**18; // 1000 tokens
    uint256 public constant FAUCET_COOLDOWN = 24 hours;
    mapping(address => uint256) public lastFaucetClaim;
    
    event FaucetClaimed(address indexed user, uint256 amount, uint256 timestamp);

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimal
    ) ERC20(name, symbol) {
        decimals_ = decimal;
    }

    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }

    function decimals() public view virtual override returns (uint8) {
        return decimals_;
    }
    
    /**
     * @dev Allows anyone to claim tokens from the faucet once every 24 hours
     */
    function claimFromFaucet() external {
        require(
            block.timestamp >= lastFaucetClaim[msg.sender] + FAUCET_COOLDOWN,
            "Faucet: Cooldown period not elapsed"
        );
        
        lastFaucetClaim[msg.sender] = block.timestamp;
        _mint(msg.sender, FAUCET_AMOUNT);
        
        emit FaucetClaimed(msg.sender, FAUCET_AMOUNT, block.timestamp);
    }
    
    /**
     * @dev Returns the timestamp when the user can next claim from the faucet
     */
    function getNextFaucetClaimTime(address user) external view returns (uint256) {
        return lastFaucetClaim[user] + FAUCET_COOLDOWN;
    }
    
    /**
     * @dev Returns whether the user can currently claim from the faucet
     */
    function canClaimFromFaucet(address user) external view returns (bool) {
        return block.timestamp >= lastFaucetClaim[user] + FAUCET_COOLDOWN;
    }
}



================================================
FILE: contracts/tokens/TokenTracker.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

import {Ownable2Step, Ownable} from "@openzeppelin/contracts/access/Ownable2Step.sol";
import {TokenBlacklisted, InvalidOperation} from "../errors/Errors.sol";

/**
 * @title TokenTracker
 * @notice Contract for tracking ERC20 tokens in the encrypted ERC system
 * @dev This contract manages:
 *      1. Token registration and identification
 *      2. Token blacklisting for security
 *      3. Contract Mode (converter vs standalone)
 *
 * The contract can operate in two modes:
 * - Converter Mode: Wraps existing ERC20 tokens into encrypted tokens
 * - Standalone Mode: Operates as a standalone encrypted token
 */
contract TokenTracker is Ownable2Step {
    ///////////////////////////////////////////////////
    ///                   State Variables           ///
    ///////////////////////////////////////////////////

    /// @notice The next available token ID
    /// @dev Token IDs start from 1, with 0 reserved for the standalone version
    uint256 public nextTokenId = 1;

    /// @notice Indicates if the contract is operating in converter mode
    bool public isConverter;

    /// @notice Mapping from token address to token ID
    mapping(address tokenAddress => uint256 tokenId) public tokenIds;

    /// @notice Mapping from token ID to token address
    mapping(uint256 tokenId => address tokenAddress) public tokenAddresses;

    /// @notice Array of all registered token addresses
    address[] public tokens;

    /// @notice Mapping to track blacklisted tokens
    mapping(address tokenAddress => bool isBlacklisted)
        public blacklistedTokens;

    ///////////////////////////////////////////////////
    ///                   Modifiers                 ///
    ///////////////////////////////////////////////////

    /**
     * @notice Ensures the function is only called in converter mode
     * @dev Reverts with InvalidOperation if called in standalone mode
     */
    modifier onlyForConverter() {
        if (!isConverter) {
            revert InvalidOperation();
        }
        _;
    }

    /**
     * @notice Ensures the function is only called in standalone mode
     * @dev Reverts with InvalidOperation if called in converter mode
     */
    modifier onlyForStandalone() {
        if (isConverter) {
            revert InvalidOperation();
        }
        _;
    }

    /**
     * @notice Ensures the token is not blacklisted
     * @param tokenAddress Address of the token to check
     * @dev Reverts with TokenBlacklisted if the token is blacklisted
     */
    modifier revertIfBlacklisted(address tokenAddress) {
        if (blacklistedTokens[tokenAddress]) {
            revert TokenBlacklisted(tokenAddress);
        }
        _;
    }

    ///////////////////////////////////////////////////
    ///                   Constructor               ///
    ///////////////////////////////////////////////////

    /**
     * @notice Initializes the TokenTracker contract
     * @param isConverter_ Determines if the contract operates in converter mode
     * @dev Sets the initial mode of operation and initializes the owner
     */
    constructor(bool isConverter_) Ownable(msg.sender) {
        isConverter = isConverter_;
    }

    ///////////////////////////////////////////////////
    ///                   External                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Sets the blacklist status of a token
     * @param token Address of the token to blacklist/unblacklist
     * @param blacklisted True to blacklist, false to unblacklist
     * @dev Only the owner can call this function
     */
    function setTokenBlacklist(
        address token,
        bool blacklisted
    ) external onlyOwner {
        blacklistedTokens[token] = blacklisted;
    }

    /**
     * @notice Returns an array of all registered token addresses
     * @return Array of token addresses
     * @dev Used for enumeration and listing all supported tokens
     */
    function getTokens() external view returns (address[] memory) {
        return tokens;
    }

    ///////////////////////////////////////////////////
    ///                   Internal                  ///
    ///////////////////////////////////////////////////

    /**
     * @notice Adds a new token to the tracker
     * @param tokenAddress Address of the token to add
     * @dev This function:
     *      1. Assigns a new token ID
     *      2. Updates the token mappings
     *      3. Adds the token to the tokens array
     *      4. Increments the next token ID
     */
    function _addToken(address tokenAddress) internal {
        uint256 newTokenId = nextTokenId;
        tokenIds[tokenAddress] = newTokenId;
        tokenAddresses[newTokenId] = tokenAddress;
        tokens.push(tokenAddress);
        nextTokenId++;
    }
}



================================================
FILE: contracts/types/Types.sol
================================================
// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: Ecosystem

pragma solidity 0.8.27;

struct Point {
    uint256 x;
    uint256 y;
}

struct CreateEncryptedERCParams {
    // registrar contract address for fetching users public key
    address registrar;
    // eERC is converter mode or not
    bool isConverter;
    // eERC Token
    string name;
    string symbol;
    uint8 decimals;
    // verifiers
    address mintVerifier;
    address withdrawVerifier;
    address transferVerifier;
    address burnVerifier;
}

struct AmountPCT {
    uint256[7] pct;
    uint256 index;
}

struct EncryptedBalance {
    EGCT eGCT;
    mapping(uint256 index => BalanceHistory history) balanceList;
    uint256 nonce;
    uint256 transactionIndex;
    uint256[7] balancePCT; // user balance pcts
    AmountPCT[] amountPCTs; // user amount pcts
}

struct BalanceHistory {
    uint256 index;
    bool isValid;
}

struct EGCT {
    Point c1;
    Point c2;
}

/// @dev The proof base is used to verify the proof
struct ProofPoints {
    uint256[2] a;
    uint256[2][2] b;
    uint256[2] c;
}

struct RegisterProof {
    ProofPoints proofPoints;
    uint256[5] publicSignals;
}

struct MintProof {
    ProofPoints proofPoints;
    uint256[24] publicSignals;
}

struct TransferProof {
    ProofPoints proofPoints;
    uint256[32] publicSignals;
}

struct BurnProof {
    ProofPoints proofPoints;
    uint256[19] publicSignals;
}

struct WithdrawProof {
    ProofPoints proofPoints;
    uint256[16] publicSignals;
}

struct TransferInputs {
    EGCT providedBalance;
    EGCT senderEncryptedAmount;
    EGCT receiverEncryptedAmount;
    uint256[7] amountPCT;
}



================================================
FILE: contracts/verifiers/BurnCircuitGroth16Verifier.sol
================================================
// SPDX-License-Identifier: MIT

/* AUTOGENERATED FILE BY HARDHAT-ZKIT. DO NOT EDIT. */

pragma solidity >=0.7.0 <0.9.0;

contract BurnCircuitGroth16Verifier {
    // @dev scalar field size
    uint256 public constant SCALAR_FIELD_SIZE =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    /// @dev base field size
    uint256 public constant BASE_FIELD_SIZE =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    /// @dev verification key data
    uint256 public constant ALPHA_X =
        20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 public constant ALPHA_Y =
        9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 public constant BETA_X1 =
        4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 public constant BETA_X2 =
        6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 public constant BETA_Y1 =
        21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 public constant BETA_Y2 =
        10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 public constant GAMMA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant GAMMA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant GAMMA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant GAMMA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 public constant DELTA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant DELTA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant DELTA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant DELTA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;

    uint256 public constant IC0_X =
        6901175356638081608311197414548846861180656487838344346821425826024891512425;
    uint256 public constant IC0_Y =
        16944064565335445729234872967061190126362989003416853826016805426130180238191;
    uint256 public constant IC1_X =
        17908121343774581376092646765067170799970925894057937307165335210962871507135;
    uint256 public constant IC1_Y =
        6739483966006459958647545663755815825611388802168101513616676265213547687212;
    uint256 public constant IC2_X =
        766312427469543414624781412742178740436577019446000599209144238628925292414;
    uint256 public constant IC2_Y =
        11956596380120466965959213032841211036588141256244479446912141909087743946449;
    uint256 public constant IC3_X =
        9834218022277006635455703178457965188100848955744692108208207593466809819916;
    uint256 public constant IC3_Y =
        5985476150835890762503639978680541204908901815001963876083809679448099772187;
    uint256 public constant IC4_X =
        14827234556798753501841602996273223453620286706976793196274886644504394417263;
    uint256 public constant IC4_Y =
        17185284608112950506629319460803937653685676730131697135772583956246683209368;
    uint256 public constant IC5_X =
        17529671244301122497049371127369274616617935801308036584230660946886543200270;
    uint256 public constant IC5_Y =
        21375965875653643781871988041044406562099360028820246922430008152355558076267;
    uint256 public constant IC6_X =
        2071394549783234155236090578090590694025714713435714686283263242515370887037;
    uint256 public constant IC6_Y =
        1360924170815016231172148644602657489538698591468910875031083731851187567999;
    uint256 public constant IC7_X =
        10294779462906061052931321788054691400173934802237652306928745571023248394387;
    uint256 public constant IC7_Y =
        6555248292739776048079409559973894167013450042783785080733702895769749566613;
    uint256 public constant IC8_X =
        4433257889246655161353853222728772973385032114589816543634201923482683435584;
    uint256 public constant IC8_Y =
        14737241692493285661348398748630216205024305186831037514190361703045651615269;
    uint256 public constant IC9_X =
        14662929317288257322870633955431196105372083992377701985085624881517883523163;
    uint256 public constant IC9_Y =
        13045157851276202363238319024416490799176208505845980771766086158756862458455;
    uint256 public constant IC10_X =
        10464607531594481747431773960796216724225398526452385781876076453050117351904;
    uint256 public constant IC10_Y =
        17227459943128246860971844058080372581110192073599679941420162883374908732283;
    uint256 public constant IC11_X =
        745839102907798772556197076666683733791895469218705021459706695701505037999;
    uint256 public constant IC11_Y =
        11282995679713265974084133361652481201591627543141168082075682177048149337453;
    uint256 public constant IC12_X =
        17929575843708091862123276864146152761508698565499701379217956191629740643940;
    uint256 public constant IC12_Y =
        19694868618398715637769102075783868212304717698983166562284533403937378692315;
    uint256 public constant IC13_X =
        19788140654052540486857453303544057569825570368720987020309299320004547960581;
    uint256 public constant IC13_Y =
        6883822212531810402176678585679740471039138816982867861815020183660906571642;
    uint256 public constant IC14_X =
        6016243318855719046735289125777883097005663608233773332990082345142498280371;
    uint256 public constant IC14_Y =
        21204516959587943017810864594613242220785397660490599724380523851223540954454;
    uint256 public constant IC15_X =
        9891573095652303648634434897797773521123041746620991186215470158961116717665;
    uint256 public constant IC15_Y =
        15129361566109667756079905439551006265474721391302786501924664404711249139905;
    uint256 public constant IC16_X =
        9439270817025434198507441583978754692817321436471324362734438362897111301924;
    uint256 public constant IC16_Y =
        17736726489009951896104159456871058989709210357063650885766330312145063724146;
    uint256 public constant IC17_X =
        7287813417026604917333767312326818451716773551965506932628922979658721400484;
    uint256 public constant IC17_Y =
        21190069513632277449640126663995547292551888059992765226941465993312580710136;
    uint256 public constant IC18_X =
        18870427155174730509179857527710685647524233977259143240992234215761896727263;
    uint256 public constant IC18_Y =
        21595208618611453816106702920660402890633778123650117008434425697322727495324;
    uint256 public constant IC19_X =
        2474736367332117814843921180480737874685068379574560055026846626150944220277;
    uint256 public constant IC19_Y =
        11798959751686284671429858411798094190882362783079508053655067482307321072055;
    
    /// @dev memory pointer size
    uint256 public constant P_TOTAL_SIZE = 768;

    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[19] memory publicSignals_
    ) public view returns (bool verified_) {
        assembly {
            function checkField(signal_) -> res_ {
                res_ := lt(signal_, SCALAR_FIELD_SIZE)
            }

            function g1MulAdd(pointer_, x_, y_, s_) -> res_ {
                mstore(add(pointer_, 64), x_)
                mstore(add(pointer_, 96), y_)
                mstore(add(pointer_, 128), s_)

                res_ := staticcall(6000, 7, add(pointer_, 64), 96, add(pointer_, 64), 64) // ecMul
                res_ := and(res_, gt(returndatasize(), 0)) // check that multiplication succeeded

                if iszero(res_) {
                    leave
                }

                res_ := staticcall(150, 6, pointer_, 128, pointer_, 64) // ecAdd
                res_ := and(res_, gt(returndatasize(), 0)) // check that addition succeeded
            }

            function checkPairing(pA_, pB_, pC_, pubSignals_, pointer_) -> res_ {
                mstore(pointer_, IC0_X)
                mstore(add(pointer_, 32), IC0_Y)

                /// @dev compute the linear combination of public signals
                if iszero(g1MulAdd(pointer_, IC1_X, IC1_Y, mload(add(pubSignals_, 0)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC2_X, IC2_Y, mload(add(pubSignals_, 32)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC3_X, IC3_Y, mload(add(pubSignals_, 64)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC4_X, IC4_Y, mload(add(pubSignals_, 96)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC5_X, IC5_Y, mload(add(pubSignals_, 128)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC6_X, IC6_Y, mload(add(pubSignals_, 160)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC7_X, IC7_Y, mload(add(pubSignals_, 192)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC8_X, IC8_Y, mload(add(pubSignals_, 224)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC9_X, IC9_Y, mload(add(pubSignals_, 256)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC10_X, IC10_Y, mload(add(pubSignals_, 288)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC11_X, IC11_Y, mload(add(pubSignals_, 320)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC12_X, IC12_Y, mload(add(pubSignals_, 352)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC13_X, IC13_Y, mload(add(pubSignals_, 384)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC14_X, IC14_Y, mload(add(pubSignals_, 416)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC15_X, IC15_Y, mload(add(pubSignals_, 448)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC16_X, IC16_Y, mload(add(pubSignals_, 480)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC17_X, IC17_Y, mload(add(pubSignals_, 512)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC18_X, IC18_Y, mload(add(pubSignals_, 544)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC19_X, IC19_Y, mload(add(pubSignals_, 576)))) {
                    leave
                }
                
                /// @dev gamma2
                mstore(add(pointer_, 64), GAMMA_X1)
                mstore(add(pointer_, 96), GAMMA_X2)
                mstore(add(pointer_, 128), GAMMA_Y1)
                mstore(add(pointer_, 160), GAMMA_Y2)

                /// @dev -A
                mstore(add(pointer_, 192), mload(pA_))
                mstore(
                    add(pointer_, 224),
                    mod(sub(BASE_FIELD_SIZE, mload(add(pA_, 32))), BASE_FIELD_SIZE)
                )

                /// @dev B
                mstore(add(pointer_, 256), mload(mload(pB_)))
                mstore(add(pointer_, 288), mload(add(mload(pB_), 32)))
                mstore(add(pointer_, 320), mload(mload(add(pB_, 32))))
                mstore(add(pointer_, 352), mload(add(mload(add(pB_, 32)), 32)))

                /// @dev alpha1
                mstore(add(pointer_, 384), ALPHA_X)
                mstore(add(pointer_, 416), ALPHA_Y)

                /// @dev beta2
                mstore(add(pointer_, 448), BETA_X1)
                mstore(add(pointer_, 480), BETA_X2)
                mstore(add(pointer_, 512), BETA_Y1)
                mstore(add(pointer_, 544), BETA_Y2)

                /// @dev C
                mstore(add(pointer_, 576), mload(pC_))
                mstore(add(pointer_, 608), mload(add(pC_, 32)))

                /// @dev delta2
                mstore(add(pointer_, 640), DELTA_X1)
                mstore(add(pointer_, 672), DELTA_X2)
                mstore(add(pointer_, 704), DELTA_Y1)
                mstore(add(pointer_, 736), DELTA_Y2)

                res_ := staticcall(181000, 8, pointer_, 768, pointer_, 32) // ecPairing
                res_ := and(res_, mload(pointer_)) // check that pairing succeeded
            }

            let pointer_ := mload(64) // free pointer
            mstore(64, add(pointer_, P_TOTAL_SIZE))

            /// @dev check that all public signals are in F
            verified_ := 1
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 0))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 32))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 64))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 96))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 128))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 160))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 192))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 224))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 256))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 288))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 320))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 352))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 384))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 416))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 448))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 480))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 512))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 544))))
            verified_ := and(verified_, checkField(mload(add(publicSignals_, 576))))
            
            /// @dev check pairings
            if not(iszero(verified_)) {
                verified_ := checkPairing(pointA_, pointB_, pointC_, publicSignals_, pointer_)
            }
        }
    }
}



================================================
FILE: contracts/verifiers/MintCircuitGroth16Verifier.sol
================================================
// SPDX-License-Identifier: MIT

/* AUTOGENERATED FILE BY HARDHAT-ZKIT. DO NOT EDIT. */

pragma solidity >=0.7.0 <0.9.0;

contract MintCircuitGroth16Verifier {
    // @dev scalar field size
    uint256 public constant SCALAR_FIELD_SIZE =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    /// @dev base field size
    uint256 public constant BASE_FIELD_SIZE =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    /// @dev verification key data
    uint256 public constant ALPHA_X =
        20491192805390485299153009773594534940189261866228447918068658471970481763042;
    uint256 public constant ALPHA_Y =
        9383485363053290200918347156157836566562967994039712273449902621266178545958;
    uint256 public constant BETA_X1 =
        4252822878758300859123897981450591353533073413197771768651442665752259397132;
    uint256 public constant BETA_X2 =
        6375614351688725206403948262868962793625744043794305715222011528459656738731;
    uint256 public constant BETA_Y1 =
        21847035105528745403288232691147584728191162732299865338377159692350059136679;
    uint256 public constant BETA_Y2 =
        10505242626370262277552901082094356697409835680220590971873171140371331206856;
    uint256 public constant GAMMA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant GAMMA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant GAMMA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant GAMMA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;
    uint256 public constant DELTA_X1 =
        11559732032986387107991004021392285783925812861821192530917403151452391805634;
    uint256 public constant DELTA_X2 =
        10857046999023057135944570762232829481370756359578518086990519993285655852781;
    uint256 public constant DELTA_Y1 =
        4082367875863433681332203403145435568316851327593401208105741076214120093531;
    uint256 public constant DELTA_Y2 =
        8495653923123431417604973247489272438418190587263600148770280649306958101930;

    uint256 public constant IC0_X =
        10121904041541460154551260390411876526139574666949788432677764574044027742051;
    uint256 public constant IC0_Y =
        6395114105467352463516423639828272877440036954754220055848039516989817256674;
    uint256 public constant IC1_X =
        5586762719201810155133862083740714325655748243483738877755810028542797644739;
    uint256 public constant IC1_Y =
        9387879719287370926595730382657598610335084850078203728936667449453246554359;
    uint256 public constant IC2_X =
        19420434315212518030589186167981244595406343548992012458488730749825996100239;
    uint256 public constant IC2_Y =
        3482657374383353276279298693752239555763142972311841530862645391131143881873;
    uint256 public constant IC3_X =
        21667521945257749121492909465236139091096077691835364325355606431375269082282;
    uint256 public constant IC3_Y =
        12156175257782822331801928906256367913221851960540994586932487722549923413345;
    uint256 public constant IC4_X =
        16828357126590671631798447095302651492589140460428270542352941484237941156483;
    uint256 public constant IC4_Y =
        3785759973408012513975276660945174958105045591429994983968533282503371539336;
    uint256 public constant IC5_X =
        21244321325522105477060254124915502034148248502931960755663601081500950076300;
    uint256 public constant IC5_Y =
        14687177467139662957844534389099557537735007475047254307829149459337997284150;
    uint256 public constant IC6_X =
        21404447565616225355770439075122853382066792760583316781611395109968504614761;
    uint256 public constant IC6_Y =
        3777910210505077428584254669424713454396973987622630869249106067166590299357;
    uint256 public constant IC7_X =
        5644690004940482546460856256670502914882531219591199090065888636589494736039;
    uint256 public constant IC7_Y =
        16345970805899097192278870928687506101715169625232631539981164972434652655022;
    uint256 public constant IC8_X =
        16593367704572145491497340027058421406291597779030039134573703992464863830646;
    uint256 public constant IC8_Y =
        19275772679724763916884927502599327291258343548738975909520313332884772129528;
    uint256 public constant IC9_X =
        18338635157990571739660769292280252719367811451620901782236478705200001456515;
    uint256 public constant IC9_Y =
        12580365946981294431067603413481570211192375767222833113101936660967490853342;
    uint256 public constant IC10_X =
        19880773599746588943745194809450382516728304373879942615347513263173728275196;
    uint256 public constant IC10_Y =
        128548754750873577554444615682746852358621588347676854260473817368140033519;
    uint256 public constant IC11_X =
        6476719107464483530164368276818653110527411272303410163053488615734788766586;
    uint256 public constant IC11_Y =
        13331539055996208679678758084320772815107338352425913859433335410845899223811;
    uint256 public constant IC12_X =
        17393436839515851750885277096607160266036302533767007170590322671069079326483;
    uint256 public constant IC12_Y =
        17336491525577930609097646312281682071744277090982994234361498925040239739760;
    uint256 public constant IC13_X =
        14059139663320156276001577403575266145309546640724899667521029234074221180403;
    uint256 public constant IC13_Y =
        5963232262834884334488206091864494084893490405377454589196552297795638041488;
    uint256 public constant IC14_X =
        13813470258321934033051704279698252148783024920181797002453328082368105474789;
    uint256 public constant IC14_Y =
        19760333797981660449134124218356560284106192590380149679255903109561686546313;
    uint256 public constant IC15_X =
        11858117840318587547791069185551586430435948995333725070770764697634898894992;
    uint256 public constant IC15_Y =
        16621799951101200543458233987158204772158254202860685491749532125765298740749;
    uint256 public constant IC16_X =
        13584356250500421508084566767718022822120888453124821650989966819848963029582;
    uint256 public constant IC16_Y =
        21121442557480691564262522113115528175177021588076736568194595390503813944019;
    uint256 public constant IC17_X =
        4326226245481542040767942040881999777137473163343274779447151141265545792486;
    uint256 public constant IC17_Y =
        21183580388477113613358837765893868421637670220571970210021457037640835173809;
    uint256 public constant IC18_X =
        2704745980008452624320271214496436840853635777289985169457654318338905712053;
    uint256 public constant IC18_Y =
        5498942242451865915343845370075402718280213375705928811712272696867696623122;
    uint256 public constant IC19_X =
        18021323881247358977456866382503667963535769536490271165761105041938333860259;
    uint256 public constant IC19_Y =
        15056011404667104875167366478630077579580289596849055349190254216447781136049;
    uint256 public constant IC20_X =
        2428670635260390602473903592482933886252233168437493591205178349351514000281;
    uint256 public constant IC20_Y =
        862350060646299115005420081148519933461348146447694025974629367115211964519;
    uint256 public constant IC21_X =
        20557922324599650576215164022162024912213509843003042307546636524489843547931;
    uint256 public constant IC21_Y =
        1061522392679391742130691544383963509531829000498209937975610885874122363387;
    uint256 public constant IC22_X =
        9114256858842496488535186312068922854228150055952688114444862375910254881995;
    uint256 public constant IC22_Y =
        20868937436899006110617091404782344741103549613810098330797141428653796030423;
    uint256 public constant IC23_X =
        392332888128429361037702708407695212788446855280618226506466973682041689462;
    uint256 public constant IC23_Y =
        10986782868722900357976121669302445297980271976862420955075995610762868745084;
    uint256 public constant IC24_X =
        12335561474727855982123382035622477594232361573497391299243618736725476900631;
    uint256 public constant IC24_Y =
        20340286770637453607265533856091115758478742882346824576410498508028320071146;
    
    /// @dev memory pointer size
    uint256 public constant P_TOTAL_SIZE = 768;

    function verifyProof(
        uint256[2] memory pointA_,
        uint256[2][2] memory pointB_,
        uint256[2] memory pointC_,
        uint256[24] memory publicSignals_
    ) public view returns (bool verified_) {
        assembly {
            function checkField(signal_) -> res_ {
                res_ := lt(signal_, SCALAR_FIELD_SIZE)
            }

            function g1MulAdd(pointer_, x_, y_, s_) -> res_ {
                mstore(add(pointer_, 64), x_)
                mstore(add(pointer_, 96), y_)
                mstore(add(pointer_, 128), s_)

                res_ := staticcall(6000, 7, add(pointer_, 64), 96, add(pointer_, 64), 64) // ecMul
                res_ := and(res_, gt(returndatasize(), 0)) // check that multiplication succeeded

                if iszero(res_) {
                    leave
                }

                res_ := staticcall(150, 6, pointer_, 128, pointer_, 64) // ecAdd
                res_ := and(res_, gt(returndatasize(), 0)) // check that addition succeeded
            }

            function checkPairing(pA_, pB_, pC_, pubSignals_, pointer_) -> res_ {
                mstore(pointer_, IC0_X)
                mstore(add(pointer_, 32), IC0_Y)

                /// @dev compute the linear combination of public signals
                if iszero(g1MulAdd(pointer_, IC1_X, IC1_Y, mload(add(pubSignals_, 0)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC2_X, IC2_Y, mload(add(pubSignals_, 32)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC3_X, IC3_Y, mload(add(pubSignals_, 64)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC4_X, IC4_Y, mload(add(pubSignals_, 96)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC5_X, IC5_Y, mload(add(pubSignals_, 128)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC6_X, IC6_Y, mload(add(pubSignals_, 160)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC7_X, IC7_Y, mload(add(pubSignals_, 192)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC8_X, IC8_Y, mload(add(pubSignals_, 224)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC9_X, IC9_Y, mload(add(pubSignals_, 256)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC10_X, IC10_Y, mload(add(pubSignals_, 288)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC11_X, IC11_Y, mload(add(pubSignals_, 320)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC12_X, IC12_Y, mload(add(pubSignals_, 352)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC13_X, IC13_Y, mload(add(pubSignals_, 384)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC14_X, IC14_Y, mload(add(pubSignals_, 416)))) {
                    leave
                }
                if iszero(g1MulAdd(pointer_, IC15_X, IC15_Y, mload(add(pubSignals_